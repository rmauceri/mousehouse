<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>üê≠ Mouse House</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%; overflow: hidden;
  background: #2b1d0e;
  font-family: 'Courier New', monospace;
}
body { display: flex; flex-direction: column; }
#gameCanvas {
  display: block; margin: 0 auto;
  image-rendering: pixelated; image-rendering: crisp-edges;
  cursor: pointer;
}

/* ---- HUD ---- */
#hud {
  position: absolute; top: 0; left: 0; width: 100%;
  display: none; flex-direction: column;
  background: rgba(30,20,10,0.85);
  color: #f5d68a; font-size: 16px; z-index: 10;
  border-bottom: 2px solid #a07040;
}
#hud-row1 {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 12px;
}
.hud-group { display: flex; align-items: center; gap: 6px; }
.hud-group-rooms { display: flex; align-items: center; gap: 3px; }
#hud-row2 {
  display: none; text-align: center; padding: 3px 12px 5px;
  border-top: 1px solid rgba(160,112,64,0.3);
}
#hud-row2.visible { display: block; }
#goal-display {
  font-size: 13px; color: #e8d5b5; white-space: normal;
  line-height: 1.3;
}
#hud button {
  background: #3d2b1a; color: #f5d68a; border: 2px solid #a07040;
  padding: 5px 12px; font-family: 'Courier New', monospace; font-size: 13px;
  cursor: pointer; border-radius: 4px;
  transition: background 0.15s;
}
#hud button:hover { background: #5a3d24; }
#hud button.active { background: #f5d68a; color: #2b1d0e; }
.room-tabs { display: flex; gap: 3px; }
.room-tabs button { font-size: 12px; padding: 4px 10px; }
/* Nav row: hidden on desktop, shown on mobile */
#hud-nav-row {
  display: none; justify-content: space-between; padding: 3px 8px 4px;
  border-top: 1px solid rgba(160,112,64,0.3);
}

/* ---- Modals ---- */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.8); display: flex; justify-content: center;
  align-items: center; z-index: 100;
}
.modal-content {
  background: #3d2b1a; border: 3px solid #f5d68a; border-radius: 12px;
  padding: 20px; max-width: 90vw; max-height: 85vh; overflow-y: auto;
  color: #e8d5b5; font-family: 'Courier New', monospace;
}
.modal-content h2 { color: #f5d68a; text-align: center; margin-bottom: 12px; }
.modal-content .close-btn {
  display: block; margin: 12px auto 0; background: #f5d68a; color: #2b1d0e;
  border: none; padding: 8px 24px; font-size: 16px; cursor: pointer;
  border-radius: 4px; font-family: 'Courier New', monospace; font-weight: bold;
}
.modal-content .close-btn:hover { background: #ffe4a0; }

/* ---- Shop grid ---- */
.shop-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px; margin: 10px 0;
}
.shop-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 10px; text-align: center; cursor: pointer; transition: border-color 0.2s;
}
.shop-item:hover { border-color: #f5d68a; }
.shop-item.owned { border-color: #7bc67e; opacity: 0.7; }
.shop-item .item-icon { font-size: 28px; margin-bottom: 4px; }
.shop-item .item-name { color: #f5d68a; font-size: 12px; font-weight: bold; }
.shop-item .item-desc { color: #a89070; font-size: 10px; margin: 4px 0; }
.shop-item .item-price { color: #f5d68a; font-size: 14px; font-weight: bold; }

/* ---- Minigame buttons ---- */
.minigame-btn {
  display: block; width: 80%; margin: 8px auto; padding: 12px;
  background: #2b1d0e; border: 2px solid #f5d68a; color: #f5d68a;
  font-family: 'Courier New', monospace; font-size: 14px; cursor: pointer;
  border-radius: 6px; text-align: center;
}
.minigame-btn:hover { background: #5a3d24; }

/* ---- Toast ---- */
#toast {
  position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
  background: rgba(30,20,10,0.92); color: #f5d68a; padding: 10px 22px;
  border-radius: 8px; font-size: 14px; pointer-events: none;
  opacity: 0; transition: opacity 0.3s; z-index: 50; text-align: center;
  border: 1px solid #a07040; max-width: 90vw;
  font-family: 'Courier New', monospace;
}
#toast.show { opacity: 1; }

/* ---- Placement bar (legacy, hidden) ---- */
#placement-bar { display: none !important; }

/* ---- Shop Flyout Panel ---- */
#shop-flyout, #games-flyout {
  position: fixed; top: 0; right: 0; width: 280px; height: 100%;
  background: rgba(30,20,10,0.95); border-left: 2px solid #a07040;
  z-index: 30; transform: translateX(100%); transition: transform 0.3s ease;
  display: flex; flex-direction: column; font-family: 'Courier New', monospace;
  overflow: hidden;
}
#shop-flyout.open, #games-flyout.open { transform: translateX(0); }
#shop-flyout .flyout-header {
  padding: 10px 14px; border-bottom: 2px solid #a07040;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0;
}
#shop-flyout .flyout-header h2 { color: #f5d68a; font-size: 16px; margin: 0; }
#shop-flyout .flyout-close {
  background: none; border: none; color: #f5d68a; font-size: 20px;
  cursor: pointer; padding: 2px 6px; line-height: 1;
}
#shop-flyout .flyout-coins {
  text-align: center; color: #a89070; font-size: 12px; padding: 6px 14px;
  border-bottom: 1px solid rgba(160,112,64,0.3); flex-shrink: 0;
}
#shop-flyout .flyout-coins strong { color: #f5d68a; }
#shop-flyout .flyout-items {
  flex: 1; overflow-y: auto; padding: 8px;
  display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
  align-content: start;
}
#shop-flyout .flyout-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 6px;
  padding: 8px 4px; text-align: center; cursor: pointer;
  transition: border-color 0.15s, background 0.15s;
}
#shop-flyout .flyout-item:hover { border-color: #f5d68a; }
#shop-flyout .flyout-item.owned { border-color: #7bc67e; }
#shop-flyout .flyout-item.cant-afford { opacity: 0.35; cursor: not-allowed; }
#shop-flyout .flyout-item .fi-icon { font-size: 22px; }
#shop-flyout .flyout-item .fi-name { color: #f5d68a; font-size: 10px; font-weight: bold; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#shop-flyout .flyout-item .fi-price { color: #a89070; font-size: 10px; margin-top: 2px; }
#shop-flyout .flyout-item.owned .fi-price { color: #7bc67e; }
#shop-flyout .flyout-footer {
  padding: 8px 14px; border-top: 2px solid #a07040; flex-shrink: 0;
  text-align: center;
}
#shop-flyout .flyout-footer button {
  background: #3d2b1a; color: #f5d68a; border: 2px solid #a07040;
  padding: 6px 14px; cursor: pointer; border-radius: 4px;
  font-family: 'Courier New', monospace; font-size: 12px; width: 100%;
  margin-bottom: 4px;
}
#shop-flyout .flyout-footer button:hover { background: #5a3d24; }
#shop-flyout .flyout-footer .loot-info { color: #a89070; font-size: 9px; margin-top: 2px; }

/* ---- Games Flyout ---- */
#games-flyout .flyout-header {
  padding: 10px 14px; border-bottom: 2px solid #a07040;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0;
}
#games-flyout .flyout-header h2 { color: #f5d68a; font-size: 16px; margin: 0; }
#games-flyout .flyout-close {
  background: none; border: none; color: #f5d68a; font-size: 20px;
  cursor: pointer; padding: 2px 6px; line-height: 1;
}
#games-flyout .flyout-subtitle {
  text-align: center; color: #a89070; font-size: 11px; padding: 6px 14px;
  border-bottom: 1px solid rgba(160,112,64,0.3); flex-shrink: 0;
}
#games-flyout .game-list {
  flex: 1; overflow-y: auto; padding: 10px 14px;
  display: flex; flex-direction: column; gap: 8px;
}
#games-flyout .game-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 12px; cursor: pointer; transition: border-color 0.15s, background 0.15s;
}
#games-flyout .game-item:hover { border-color: #f5d68a; background: #3d2b1a; }
#games-flyout .game-item .gi-title { color: #f5d68a; font-size: 14px; font-weight: bold; }
#games-flyout .game-item .gi-desc { color: #a89070; font-size: 10px; margin-top: 4px; }

/* ---- Item Tray (bottom palette) ---- */
#tray-toggle {
  position: fixed; bottom: 0; left: 50%; transform: translateX(-50%);
  z-index: 31; width: 40px; height: 22px; background: rgba(30,20,10,0.92);
  border: 2px solid #a07040; border-bottom: none; border-radius: 6px 6px 0 0;
  color: #f5d68a; font-size: 16px; cursor: pointer; display: none;
  align-items: center; justify-content: center; font-family: 'Courier New', monospace;
  transition: background 0.15s;
}
#tray-toggle:hover { background: #3d2b1a; }
#tray-toggle.open { bottom: 72px; }
#item-tray {
  position: fixed; bottom: 0; left: 0; width: 100%; height: 72px;
  background: rgba(30,20,10,0.92); border-top: 2px solid #a07040;
  z-index: 30; display: none; overflow-x: auto; overflow-y: hidden;
  white-space: nowrap; padding: 6px 10px;
  -webkit-overflow-scrolling: touch;
}
#item-tray.open { display: flex; align-items: center; gap: 6px; }
.tray-item {
  display: inline-flex; flex-direction: column; align-items: center;
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 6px;
  padding: 4px 8px; cursor: grab; user-select: none; -webkit-user-select: none;
  flex-shrink: 0; min-width: 56px; transition: border-color 0.15s;
}
.tray-item:hover { border-color: #f5d68a; }
.tray-item.active { border-color: #f5d68a; background: #3d2b1a; }
.tray-item .ti-icon { font-size: 20px; pointer-events: none; }
.tray-item .ti-name { font-size: 8px; color: #a89070; pointer-events: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 50px; }

/* ---- Trash Zone ---- */
#trash-zone {
  position: fixed; bottom: 0; left: 50%; transform: translateX(-50%);
  width: 120px; height: 50px; background: rgba(200,50,50,0.7);
  border: 2px dashed #ff6666; border-radius: 10px 10px 0 0;
  z-index: 35; display: none; justify-content: center; align-items: center;
  color: #fff; font-size: 24px; font-family: 'Courier New', monospace;
  pointer-events: none;
}
#trash-zone.visible { display: flex; }
#trash-zone.hover { background: rgba(200,50,50,0.95); border-color: #ff4444; }

/* ---- Birthday letter ---- */
.letter-content {
  background: #f5f0dc; color: #333; padding: 20px; border-radius: 8px;
  font-family: Georgia, serif; font-size: 15px; line-height: 1.6;
  max-width: 400px; margin: 0 auto;
}
.letter-content h3 { text-align: center; margin-bottom: 10px; color: #8b4513; }

/* ---- Title screen ---- */
#title-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: #2b1d0e; display: flex; flex-direction: column;
  justify-content: center; align-items: center; z-index: 200;
  cursor: pointer; overflow: hidden;
}
#title-screen h1 {
  color: #f5d68a; font-size: 52px; margin-bottom: 0; letter-spacing: 2px;
  text-shadow: 3px 3px 0 #1a0f05, 0 0 30px rgba(245,214,138,0.4);
}
#title-screen .adventure-subtitle {
  color: #c8a870; font-size: 16px; margin-bottom: 8px;
  text-shadow: 0 0 12px rgba(200,168,112,0.4);
}
#title-screen .start-text {
  color: #f5d68a; font-size: 16px;
  animation: pulse 1.5s ease-in-out infinite;
  margin-top: 12px;
}
#title-screen .mice-display {
  display: flex; gap: 40px; align-items: flex-end; margin-bottom: 8px;
}
#title-screen .mouse-art {
  display: flex; flex-direction: column; align-items: center; gap: 2px;
  overflow: hidden;
}
#title-screen .mouse-art .name {
  color: #d0b888; font-size: 13px; font-weight: bold;
}
#title-screen canvas { border-radius: 8px; }
#title-screen .title-buttons {
  display: flex; gap: 12px; margin-top: 14px;
}
#title-screen .title-buttons button {
  background: rgba(245,214,138,0.15); border: 1px solid #6b5030;
  color: #f5d68a; font-size: 13px; padding: 6px 16px; border-radius: 6px;
  cursor: pointer; font-family: monospace; transition: all 0.2s;
}
#title-screen .title-buttons button:hover {
  background: rgba(245,214,138,0.3); border-color: #f5d68a;
}
#title-about-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.7); z-index: 210; display: none;
  justify-content: center; align-items: center;
}
#title-about-overlay.visible { display: flex; }
#title-about-box {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 12px;
  padding: 20px 24px; max-width: 380px; max-height: 80vh; overflow-y: auto;
  color: #e8d5b5; font-family: monospace; font-size: 12px; line-height: 1.6;
}
#title-about-box h2 { color: #f5d68a; font-size: 18px; margin: 0 0 8px; }
#title-about-box h3 { color: #c8a870; font-size: 13px; margin: 10px 0 4px; }
#title-about-box p { margin: 4px 0; }
#title-about-box ul { margin: 4px 0 4px 16px; padding: 0; }
#title-about-box li { margin: 2px 0; }
#title-about-box .close-about {
  display: block; margin: 12px auto 0; background: #6b5030; border: none;
  color: #f5d68a; padding: 6px 20px; border-radius: 6px; cursor: pointer;
  font-family: monospace; font-size: 13px;
}
#title-about-box .close-about:hover { background: #8b6840; }
/* Floating cheese/sparkle particles on title */
.title-particle {
  position: absolute; font-size: 16px; pointer-events: none;
  animation: float-up 6s linear infinite;
  opacity: 0.6;
}
@keyframes float-up {
  0% { transform: translateY(0) rotate(0deg); opacity: 0; }
  10% { opacity: 0.6; }
  90% { opacity: 0.6; }
  100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
}
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

/* ---- Doomscroll posts ---- */
.doomscroll-post {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 12px; margin: 8px 0; cursor: pointer; transition: all 0.2s;
}
.doomscroll-post:hover { border-color: #f5d68a; }
.doomscroll-post .post-user { color: #a89070; font-size: 11px; margin-bottom: 4px; }
.doomscroll-post .post-text { color: #e8d5b5; font-size: 13px; }

/* ---- Flyout backdrop (light dismiss) ---- */
#flyout-backdrop {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.4); z-index: 29; display: none;
}
#flyout-backdrop.visible { display: block; }

/* ---- Mobile layout (portrait phones) ---- */
@media (max-width: 480px) {
  /* HUD flows above canvas instead of overlaying */
  #hud { position: relative; order: -1; }

  /* Row 1 on mobile: stats, store/games, letter/sound/exit */
  #hud-row1 { justify-content: space-between; padding: 4px 6px; }
  #hud-stats { display: flex; }
  #hud-actions .btn-label { display: none; }
  .hud-group-rooms { display: none; }

  /* Row 2 on mobile: room switcher centered */
  #hud-nav-row { display: flex; justify-content: center; padding: 4px 6px; }
  #hud button { padding: 4px 8px; font-size: 12px; }
  .room-tabs button { padding: 3px 8px; font-size: 12px; }

  /* Flyouts: full width on mobile */
  #shop-flyout, #games-flyout { width: 100%; }

  /* Item tray: bottom sheet grid instead of horizontal strip */
  #item-tray {
    height: auto !important; max-height: 50vh;
    overflow-y: auto !important; overflow-x: hidden !important;
    white-space: normal !important;
    flex-wrap: wrap !important;
    padding: 8px !important;
  }
  #item-tray.open {
    display: grid !important;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
  }
  .tray-item {
    min-width: unset; width: 100%;
    cursor: pointer;
  }
  #tray-toggle.open { bottom: auto; }
}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  <div id="hud-row1">
    <div class="hud-group" id="hud-stats">
      <span>üßÄ <span id="coin-display">0</span></span>
      <span id="happiness-display" title="Mouse Happiness">‚ù§Ô∏è <span id="happiness-value">80</span>%</span>
    </div>
    <div class="hud-group-rooms">
      <div class="room-tabs" id="room-tabs"></div>
    </div>
    <div class="hud-group" id="hud-actions">
      <button id="btn-shop">üõí<span class="btn-label"> aMouseZon</span></button>
      <button id="btn-games">üéÆ<span class="btn-label"> Games</span></button>
    </div>
    <div class="hud-group" id="hud-utils">
      <button id="btn-letter">üíå</button>
      <button id="btn-sound" title="Sound">üîá</button>
      <button id="btn-exit" title="Exit to title">üö™</button>
    </div>
  </div>
  <div id="hud-nav-row">
    <div class="room-tabs" id="room-tabs-mobile"></div>
  </div>
  <div id="hud-row2">
    <div id="goal-display"></div>
  </div>
</div>

<div id="volume-popup" style="display:none;position:fixed;z-index:15;background:rgba(30,20,10,0.95);border:2px solid #a07040;border-radius:8px;padding:10px 14px;font-family:'Courier New',monospace;">
  <label style="color:#f5d68a;font-size:12px;">Volume</label><br>
  <input type="range" id="volume-slider" min="0" max="100" value="50" style="width:100px;margin-top:4px;accent-color:#f5d68a;">
</div>

<div id="toast"></div>

<div id="placement-bar">
  <div class="info" id="placement-info">Click/tap a spot to place the item</div>
  <button id="btn-cancel-place">‚úñ Cancel</button>
  <button id="btn-remove-mode">üóë Remove</button>
</div>

<div id="flyout-backdrop"></div>

<div id="shop-flyout">
  <div class="flyout-header">
    <h2>üõí aMouseZon</h2>
    <button class="flyout-close" id="flyout-close-btn">‚úñ</button>
  </div>
  <div class="flyout-coins">Free 2-day delivery | üßÄ <strong id="flyout-coin-display">0</strong> coins</div>
  <div class="flyout-items" id="flyout-items"></div>
  <div class="flyout-footer">
    <button id="flyout-loot-btn">üéÅ Loot Crumbs ‚Äî Free Mystery Item!</button>
    <div class="loot-info" id="flyout-loot-info"></div>
  </div>
</div>

<div id="games-flyout">
  <div class="flyout-header">
    <h2>üéÆ Arcade</h2>
    <button class="flyout-close" id="games-flyout-close">‚úñ</button>
  </div>
  <div class="flyout-subtitle">Earn cheese coins to shop at aMouseZon!</div>
  <div class="game-list">
    <div class="game-item" onclick="startCheeseChase()">
      <div class="gi-title">üßÄ Cheese Chase</div>
      <div class="gi-desc">Dodge traps, collect cheese!</div>
    </div>
    <div class="game-item" onclick="startDoomscroll()">
      <div class="gi-title">üì± Doomscroll</div>
      <div class="gi-desc">Touch grass? Never heard of it.</div>
    </div>
    <div class="game-item" onclick="startMouseMaze()">
      <div class="gi-title">üèÅ Mouse Maze</div>
      <div class="gi-desc">Navigate the maze, collect cheese!</div>
    </div>
  </div>
</div>

<div id="tray-toggle" title="Toggle item tray"><span style="display:inline-block;transform:rotate(-90deg)">¬ª</span></div>
<div id="item-tray"></div>

<div id="trash-zone">üóë</div>

<div id="title-screen">
  <h1>Mouse House</h1>
  <div class="adventure-subtitle">‚ú® The Adventures of Pip & Chai ‚ú®</div>
  <div class="mice-display">
    <div class="mouse-art">
      <canvas id="title-pip" width="200" height="160"></canvas>
    </div>
    <div class="mouse-art">
      <canvas id="title-chai" width="200" height="160"></canvas>
    </div>
  </div>
  <div class="start-text">~ tap or click to start ~</div>
  <div class="title-buttons">
    <button id="title-about-btn" onclick="event.stopPropagation(); toggleTitleAbout()">üìñ About</button>
    <button id="title-mute-btn" onclick="event.stopPropagation(); toggleTitleMute()">üîä Sound</button>
  </div>
</div>

<div id="title-about-overlay" onclick="closeTitleAbout()">
  <div id="title-about-box" onclick="event.stopPropagation()">
    <h2>üê≠ Mouse House</h2>
    <p>A cozy virtual pet game for Nico & Rose! Watch Pip and Chai explore their dollhouse, buy them furniture, and play mini-games together.</p>
    <h3>üè† Features</h3>
    <ul>
      <li><b>4 rooms</b> ‚Äî Bedroom, Kitchen, Living Room & Exercise Room, each with platforms and ramps</li>
      <li><b>20+ furniture items</b> ‚Äî Buy from the aMouseZon shop and place anywhere</li>
      <li><b>3 mini-games</b> ‚Äî Cheese Chase, Doomscroll & Mouse Maze</li>
      <li><b>Exercise Wheel</b> ‚Äî Watch the mice spin (and get flung!)</li>
      <li><b>Mouse AI</b> ‚Äî Pip & Chai explore, climb, nap, chase each other, and share thoughts</li>
    </ul>
    <h3>ü™ô How to Play</h3>
    <ul>
      <li>Earn coins by petting mice, playing mini-games, and completing goals</li>
      <li>Spend coins in the <b>aMouseZon</b> shop (üõç button) to buy furniture</li>
      <li>Drag items from the tray to place them; double-click placed items to reposition</li>
      <li>Click empty space to close the shop (light dismiss)</li>
      <li>Switch rooms using the tabs at the top</li>
    </ul>
    <h3>üí° Tips</h3>
    <ul>
      <li><b>Pet the mice!</b> Click/tap on them for coins and happiness</li>
      <li><b>Feed them!</b> Buy cheese üßÄ or blueberries ü´ê ‚Äî they get hungry over time</li>
      <li><b>Double-click status bar</b> (bottom) to jump to a mouse's room</li>
      <li><b>Goals</b> appear at the top ‚Äî complete them for bonus coins</li>
      <li><b>Loot Crumbs</b> button in the shop gives free coins (once per day)</li>
      <li>Food items are consumable ‚Äî buy more when they run out! (üîÑ in shop)</li>
      <li>Mice have personalities: Pip is chaotic & hungry, Chai is cozy & chill</li>
    </ul>
    <button class="close-about" onclick="closeTitleAbout()">Got it! üê≠</button>
  </div>
</div>

<div id="modal-container"></div>

<script>
// ============================================================
// CONFIG ‚Äî Easy to change names, colors, messages
// ============================================================
const CONFIG = {
  mice: {
    pip: {
      name: 'Pip', bodyColor: '#4a4a4a', earColor: '#3a3a3a',
      bellyColor: '#5e5e5e', eyeColor: '#111', noseColor: '#ffaaaa',
      personality: 'chaotic', // more zoomies, sarcastic quotes
      scale: 1.15 // Pip is slightly larger than Chai
    },
    chai: {
      name: 'Chai', bodyColor: '#b8b8b8', earColor: '#a5a5a5',
      bellyColor: '#d0d0d0', eyeColor: '#222', noseColor: '#ffbbbb',
      personality: 'chill', // more sleeping, wholesome quotes
      scale: 1.0
    }
  },
  twins: { name1: 'Nico', name2: 'Rose', age: 20, birthday: 'February 21' },
  startingCoins: 50,
  birthdayMessage: `Dear Nico & Rose,

Happy 20th birthday! üéÇ

Twenty years of watching you two grow into the amazing, hilarious, kind humans you are. From tiny babies to tiny-mouse enthusiasts, you've filled every day with joy (and chaos, but mostly joy).

Pip and Chai are lucky to have you ‚Äî and so am I.

Here's a little mouse house for you to make your own. Decorate it, play some games, and know that every pixel was placed with love.

To the moon and back,
Dad üê≠üíõ`
};

// ============================================================
// AUDIO ENGINE (Web Audio API ‚Äî all synthesized)
// ============================================================
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let audioMuted = true;
let audioVolume = 0.5;
let musicPlaying = false;
let musicTimeout = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);
  masterGain.gain.value = audioMuted ? 0 : audioVolume;

  musicGain = audioCtx.createGain();
  musicGain.connect(masterGain);
  musicGain.gain.value = 0.3;

  sfxGain = audioCtx.createGain();
  sfxGain.connect(masterGain);
  sfxGain.gain.value = 0.7;
}

function updateSoundButtons() {
  document.getElementById('btn-sound').textContent = audioMuted ? 'üîá' : 'üîä';
}

function toggleMute() {
  initAudio();
  audioMuted = !audioMuted;
  masterGain.gain.setTargetAtTime(audioMuted ? 0 : audioVolume, audioCtx.currentTime, 0.05);
  updateSoundButtons();
  try { localStorage.setItem('mouseHouseAudio', JSON.stringify({ muted: audioMuted, volume: audioVolume })); } catch(e) {}
  if (!audioMuted && !musicPlaying) startMusic();
}

function setVolume(v) {
  audioVolume = v;
  if (masterGain && !audioMuted) {
    masterGain.gain.setTargetAtTime(audioVolume, audioCtx.currentTime, 0.05);
  }
  try { localStorage.setItem('mouseHouseAudio', JSON.stringify({ muted: audioMuted, volume: audioVolume })); } catch(e) {}
}

function loadAudioPrefs() {
  try {
    const d = JSON.parse(localStorage.getItem('mouseHouseAudio'));
    if (d) {
      audioMuted = d.muted ?? true;
      audioVolume = d.volume ?? 0.5;
      updateSoundButtons();
      document.getElementById('volume-slider').value = Math.round(audioVolume * 100);
    }
  } catch(e) {}
}

// --- Synth helpers ---
function playTone(freq, duration, type, gainVal, dest) {
  if (!audioCtx || audioMuted) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type || 'sine';
  osc.frequency.value = freq;
  g.gain.value = gainVal || 0.3;
  g.gain.setTargetAtTime(0, audioCtx.currentTime + duration * 0.7, duration * 0.15);
  osc.connect(g);
  g.connect(dest || sfxGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + duration);
}

function playNoise(duration, gainVal) {
  if (!audioCtx || audioMuted) return;
  const bufSize = audioCtx.sampleRate * duration;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.value = gainVal || 0.1;
  g.gain.setTargetAtTime(0, audioCtx.currentTime + duration * 0.5, duration * 0.2);
  src.connect(g);
  g.connect(sfxGain);
  src.start();
}

// --- Sound effects ---
function sfxSqueak() {
  if (!audioCtx) return;
  const baseFreq = 1800 + Math.random() * 600;
  playTone(baseFreq, 0.08, 'sine', 0.2);
  setTimeout(() => playTone(baseFreq * 1.2, 0.06, 'sine', 0.15), 50);
}

function sfxCoinCollect() {
  if (!audioCtx) return;
  playTone(880, 0.08, 'square', 0.12);
  setTimeout(() => playTone(1100, 0.08, 'square', 0.12), 60);
  setTimeout(() => playTone(1320, 0.1, 'square', 0.1), 120);
}

function sfxBuy() {
  if (!audioCtx) return;
  playTone(523, 0.06, 'square', 0.12);
  setTimeout(() => playTone(659, 0.06, 'square', 0.12), 50);
  setTimeout(() => playTone(784, 0.06, 'square', 0.12), 100);
  setTimeout(() => playTone(1047, 0.12, 'square', 0.1), 150);
}

function sfxPlace() {
  if (!audioCtx) return;
  playNoise(0.06, 0.15);
  setTimeout(() => playTone(600, 0.1, 'triangle', 0.1), 40);
  setTimeout(() => playTone(900, 0.08, 'sine', 0.06), 100);
}

function sfxPet() {
  if (!audioCtx) return;
  const f = 1400 + Math.random() * 400;
  playTone(f, 0.06, 'sine', 0.15);
  setTimeout(() => playTone(f * 1.15, 0.06, 'sine', 0.12), 60);
  setTimeout(() => playTone(f * 1.3, 0.08, 'sine', 0.1), 120);
}

function sfxZoomies() {
  if (!audioCtx) return;
  for (let i = 0; i < 4; i++) {
    setTimeout(() => playTone(400 + i * 150, 0.05, 'sawtooth', 0.06), i * 40);
  }
}

function sfxCheeseCollect() {
  if (!audioCtx) return;
  playTone(1200, 0.05, 'sine', 0.15);
  setTimeout(() => playTone(1600, 0.07, 'sine', 0.1), 40);
}

function sfxCrash() {
  if (!audioCtx) return;
  playNoise(0.15, 0.2);
  playTone(200, 0.2, 'sawtooth', 0.12);
  setTimeout(() => playTone(120, 0.25, 'sawtooth', 0.08), 80);
}

function sfxGoodLike() {
  if (!audioCtx) return;
  playTone(523, 0.08, 'triangle', 0.12);
  setTimeout(() => playTone(659, 0.08, 'triangle', 0.12), 70);
  setTimeout(() => playTone(784, 0.12, 'triangle', 0.1), 140);
}

function sfxBadLike() {
  if (!audioCtx) return;
  playTone(300, 0.15, 'sawtooth', 0.1);
  setTimeout(() => playTone(250, 0.15, 'sawtooth', 0.1), 150);
  setTimeout(() => playTone(200, 0.25, 'sawtooth', 0.08), 300);
}

function sfxFanfare() {
  if (!audioCtx) return;
  const notes = [523, 659, 784, 1047, 784, 1047, 1319];
  notes.forEach((n, i) => {
    setTimeout(() => playTone(n, 0.12, 'square', 0.1), i * 100);
  });
}

function sfxGoalComplete() {
  if (!audioCtx) return;
  const notes = [659, 784, 1047, 1319];
  notes.forEach((n, i) => {
    setTimeout(() => playTone(n, 0.1, 'triangle', 0.12), i * 80);
  });
}

function sfxSpeechBubble() {
  if (!audioCtx) return;
  const f = 1000 + Math.random() * 800;
  playTone(f, 0.03, 'sine', 0.06);
}

function sfxWheelSpin() {
  if (!audioCtx) return;
  playTone(300, 0.05, 'triangle', 0.04);
  setTimeout(() => playTone(350, 0.05, 'triangle', 0.04), 60);
}

function sfxWheelFling() {
  if (!audioCtx) return;
  playTone(600, 0.06, 'sawtooth', 0.1);
  setTimeout(() => playTone(400, 0.08, 'sawtooth', 0.08), 50);
  setTimeout(() => playTone(250, 0.12, 'triangle', 0.06), 120);
  setTimeout(() => playNoise(0.08, 0.1), 200);
}

function sfxUIClick() {
  if (!audioCtx) return;
  playTone(800, 0.03, 'square', 0.06);
}

// --- Background music (gentle pentatonic loop) ---
// Multiple melodic phrases that cycle for variety
const MUSIC_PHRASES = [
  // Phrase A: gentle ascending (C major pentatonic)
  [[262,300],[294,300],[330,300],[392,300],[440,300],[392,300],[330,600],
   [294,300],[330,300],[262,600]],
  // Phrase B: playful skip pattern
  [[330,200],[392,200],[330,200],[440,400],[392,300],[330,300],[294,300],[262,600],
   [294,200],[330,200],[392,600]],
  // Phrase C: lullaby feel (slower, wider intervals)
  [[262,500],[392,500],[330,400],[294,300],[262,300],
   [330,500],[440,500],[392,400],[330,600]],
  // Phrase D: cheerful bounce
  [[392,200],[392,200],[440,400],[330,200],[330,200],[392,400],
   [294,300],[330,300],[392,300],[440,300],[392,600]],
  // Phrase E: descending calm
  [[523,400],[440,300],[392,300],[330,400],[294,300],[262,300],
   [294,300],[330,300],[262,600]],
  // Phrase F: call and response
  [[262,300],[330,300],[392,600],[0,200],
   [440,300],[392,300],[330,600],[0,200],
   [294,300],[330,300],[262,600]],
];

let musicPhraseIndex = 0;
let musicNoteIndex = 0;
let musicPhrase = MUSIC_PHRASES[0];

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;
  musicPhraseIndex = Math.floor(Math.random() * MUSIC_PHRASES.length);
  musicPhrase = MUSIC_PHRASES[musicPhraseIndex];
  musicNoteIndex = 0;
  playMusicNote();
}

function stopMusic() {
  musicPlaying = false;
  if (musicTimeout) clearTimeout(musicTimeout);
}

function playMusicNote() {
  if (!musicPlaying || audioMuted) { musicPlaying = false; return; }

  // Advance to next phrase when current one finishes
  if (musicNoteIndex >= musicPhrase.length) {
    musicPhraseIndex = (musicPhraseIndex + 1 + Math.floor(Math.random() * (MUSIC_PHRASES.length - 1))) % MUSIC_PHRASES.length;
    musicPhrase = MUSIC_PHRASES[musicPhraseIndex];
    musicNoteIndex = 0;
  }

  const [freq, dur] = musicPhrase[musicNoteIndex];
  musicNoteIndex++;

  if (freq > 0) {
    // Soft triangle wave melody
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 0.04);
    g.gain.setTargetAtTime(0, audioCtx.currentTime + (dur / 1000) * 0.6, (dur / 1000) * 0.15);
    osc.connect(g);
    g.connect(musicGain);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + dur / 1000 + 0.1);

    // Harmony: soft fifth or third below on some notes
    if (musicNoteIndex % 3 === 0) {
      const harmRatio = musicNoteIndex % 6 === 0 ? 0.667 : 0.8; // fifth or major third
      const osc2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = freq * harmRatio;
      g2.gain.value = 0.03;
      g2.gain.setTargetAtTime(0, audioCtx.currentTime + (dur / 1000) * 0.5, (dur / 1000) * 0.2);
      osc2.connect(g2);
      g2.connect(musicGain);
      osc2.start(audioCtx.currentTime);
      osc2.stop(audioCtx.currentTime + dur / 1000 + 0.15);
    }

    // Occasional soft bass note on phrase downbeats
    if (musicNoteIndex === 1) {
      const osc3 = audioCtx.createOscillator();
      const g3 = audioCtx.createGain();
      osc3.type = 'sine';
      osc3.frequency.value = freq * 0.5;
      g3.gain.value = 0.025;
      g3.gain.setTargetAtTime(0, audioCtx.currentTime + 0.3, 0.15);
      osc3.connect(g3);
      g3.connect(musicGain);
      osc3.start(audioCtx.currentTime);
      osc3.stop(audioCtx.currentTime + 0.6);
    }
  }

  musicTimeout = setTimeout(playMusicNote, dur);
}

// ============================================================
// MINI-GAME SOUNDTRACKS
// ============================================================
let gameMusicPlaying = false;
let gameMusicTimeout = null;
let gameMusicIntensity = 0; // 0-1, drives tempo/layers

function stopGameMusic() {
  gameMusicPlaying = false;
  if (gameMusicTimeout) clearTimeout(gameMusicTimeout);
  gameMusicTimeout = null;
}

// --- Cheese Chase: frantic chase in minor key ---
const CHASE_NOTES = [
  // A minor pentatonic, frantic ascending/descending runs
  [440, 392, 349, 330, 294, 330, 349, 392],  // phrase A
  [440, 494, 523, 494, 440, 392, 349, 330],  // phrase B
  [523, 494, 440, 392, 440, 494, 523, 587],  // phrase C ‚Äî climbs higher
  [587, 523, 494, 440, 523, 587, 659, 587],  // phrase D ‚Äî intense
];
let chaseNoteIdx = 0, chasePhraseIdx = 0;

function startChaseMusic() {
  if (!audioCtx || audioMuted) return;
  gameMusicPlaying = true;
  gameMusicIntensity = 0;
  chaseNoteIdx = 0;
  chasePhraseIdx = 0;
  playChaseMusicNote();
}

function playChaseMusicNote() {
  if (!gameMusicPlaying || audioMuted) { gameMusicPlaying = false; return; }
  const phrase = CHASE_NOTES[chasePhraseIdx % CHASE_NOTES.length];
  const freq = phrase[chaseNoteIdx % phrase.length];
  // Tempo increases with intensity: 180ms ‚Üí 90ms
  const tempo = Math.max(90, 180 - gameMusicIntensity * 90);
  const dur = tempo * 0.8;

  // Lead: square wave for retro chase feel
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;
  const vol = 0.04 + gameMusicIntensity * 0.02;
  g.gain.setValueAtTime(0, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
  g.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.5, dur / 1000 * 0.15);
  osc.connect(g); g.connect(musicGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + dur / 1000 + 0.05);

  // Bass pulse on every 4th note
  if (chaseNoteIdx % 4 === 0) {
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'triangle';
    ob.frequency.value = freq * 0.25;
    gb.gain.value = 0.03 + gameMusicIntensity * 0.02;
    gb.gain.setTargetAtTime(0, audioCtx.currentTime + 0.08, 0.04);
    ob.connect(gb); gb.connect(musicGain);
    ob.start(audioCtx.currentTime);
    ob.stop(audioCtx.currentTime + 0.15);
  }

  // Harmony layer kicks in at intensity > 0.3
  if (gameMusicIntensity > 0.3 && chaseNoteIdx % 2 === 0) {
    const oh = audioCtx.createOscillator();
    const gh = audioCtx.createGain();
    oh.type = 'sawtooth';
    oh.frequency.value = freq * 1.5; // fifth above
    gh.gain.value = 0.015 + gameMusicIntensity * 0.01;
    gh.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.4, dur / 1000 * 0.1);
    oh.connect(gh); gh.connect(musicGain);
    oh.start(audioCtx.currentTime);
    oh.stop(audioCtx.currentTime + dur / 1000 + 0.05);
  }

  // High arpeggio at intensity > 0.6
  if (gameMusicIntensity > 0.6 && chaseNoteIdx % 3 === 0) {
    const oa = audioCtx.createOscillator();
    const ga = audioCtx.createGain();
    oa.type = 'sine';
    oa.frequency.value = freq * 2;
    ga.gain.value = 0.02;
    ga.gain.setTargetAtTime(0, audioCtx.currentTime + 0.04, 0.02);
    oa.connect(ga); ga.connect(musicGain);
    oa.start(audioCtx.currentTime);
    oa.stop(audioCtx.currentTime + 0.08);
  }

  chaseNoteIdx++;
  if (chaseNoteIdx >= phrase.length) {
    chaseNoteIdx = 0;
    // Pick higher-intensity phrases as game progresses
    chasePhraseIdx = Math.min(Math.floor(gameMusicIntensity * CHASE_NOTES.length), CHASE_NOTES.length - 1);
  }
  gameMusicTimeout = setTimeout(playChaseMusicNote, tempo);
}

// --- Doomscroll: chill lo-fi with tension on strikes ---
const LOFI_NOTES = [
  [262, 294, 330, 349, 330, 294, 262, 247], // C major chill
  [330, 349, 392, 349, 330, 294, 330, 349], // gentle rise
  [392, 349, 330, 294, 262, 294, 330, 262], // descend
];
let lofiNoteIdx = 0, lofiPhraseIdx = 0;

function startLofiMusic() {
  if (!audioCtx || audioMuted) return;
  gameMusicPlaying = true;
  gameMusicIntensity = 0;
  lofiNoteIdx = 0;
  lofiPhraseIdx = 0;
  playLofiMusicNote();
}

function playLofiMusicNote() {
  if (!gameMusicPlaying || audioMuted) { gameMusicPlaying = false; return; }
  const phrase = LOFI_NOTES[lofiPhraseIdx % LOFI_NOTES.length];
  const freq = phrase[lofiNoteIdx % phrase.length];
  // Tempo: relaxed 280ms, speeds up slightly with strikes
  const tempo = Math.max(180, 280 - gameMusicIntensity * 100);
  const dur = tempo * 1.2;

  // Warm sine pad
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.value = freq;
  g.gain.setValueAtTime(0, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.06);
  g.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.6, dur / 1000 * 0.2);
  osc.connect(g); g.connect(musicGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + dur / 1000 + 0.1);

  // Soft triangle harmony
  if (lofiNoteIdx % 3 === 0) {
    const oh = audioCtx.createOscillator();
    const gh = audioCtx.createGain();
    oh.type = 'triangle';
    oh.frequency.value = freq * 0.75; // third below
    gh.gain.value = 0.025;
    gh.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.4, dur / 1000 * 0.15);
    oh.connect(gh); gh.connect(musicGain);
    oh.start(audioCtx.currentTime);
    oh.stop(audioCtx.currentTime + dur / 1000 + 0.1);
  }

  // Dissonant tension notes as strikes increase
  if (gameMusicIntensity > 0.3 && lofiNoteIdx % 4 === 0) {
    const od = audioCtx.createOscillator();
    const gd = audioCtx.createGain();
    od.type = 'sawtooth';
    // Slightly off-key for tension
    od.frequency.value = freq * (1 + gameMusicIntensity * 0.08);
    gd.gain.value = 0.01 + gameMusicIntensity * 0.02;
    gd.gain.setTargetAtTime(0, audioCtx.currentTime + 0.1, 0.05);
    od.connect(gd); gd.connect(musicGain);
    od.start(audioCtx.currentTime);
    od.stop(audioCtx.currentTime + 0.2);
  }

  // Heartbeat bass at high tension
  if (gameMusicIntensity > 0.5 && lofiNoteIdx % 4 === 0) {
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'sine';
    ob.frequency.value = 80;
    gb.gain.value = 0.04;
    gb.gain.setTargetAtTime(0, audioCtx.currentTime + 0.06, 0.03);
    ob.connect(gb); gb.connect(musicGain);
    ob.start(audioCtx.currentTime);
    ob.stop(audioCtx.currentTime + 0.12);
  }

  lofiNoteIdx++;
  if (lofiNoteIdx >= phrase.length) {
    lofiNoteIdx = 0;
    lofiPhraseIdx++;
  }
  gameMusicTimeout = setTimeout(playLofiMusicNote, tempo);
}

// --- Mouse Maze: exploration to triumph ---
const MAZE_NOTES = [
  // Level 1: sparse, mysterious (E minor)
  [330, 0, 294, 0, 330, 370, 330, 0],
  // Level 2: more melodic (G major)
  [392, 440, 494, 440, 392, 349, 392, 440],
  // Level 3: triumphant (C major rising)
  [523, 494, 523, 587, 659, 587, 523, 659],
];
let mazeNoteIdx = 0;

function startMazeMusic() {
  if (!audioCtx || audioMuted) return;
  gameMusicPlaying = true;
  gameMusicIntensity = 0;
  mazeNoteIdx = 0;
  playMazeMusicNote();
}

function playMazeMusicNote() {
  if (!gameMusicPlaying || audioMuted) { gameMusicPlaying = false; return; }
  // Pick phrase based on level (intensity 0=L1, 0.33=L2, 0.67=L3)
  const phraseIdx = Math.min(Math.floor(gameMusicIntensity * 3), 2);
  const phrase = MAZE_NOTES[phraseIdx];
  const freq = phrase[mazeNoteIdx % phrase.length];
  // Tempo: starts slow 350ms, speeds up per level
  const tempo = Math.max(180, 350 - gameMusicIntensity * 170);
  const dur = tempo * 1.0;

  if (freq > 0) {
    // Echoey triangle for exploration feel
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    const vol = 0.04 + gameMusicIntensity * 0.03;
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.03);
    g.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.7, dur / 1000 * 0.25);
    osc.connect(g); g.connect(musicGain);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + dur / 1000 + 0.2);

    // Echo/delay effect ‚Äî faint repeat
    setTimeout(() => {
      if (!gameMusicPlaying || audioMuted) return;
      const osc2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = freq * 1.005; // very slight detune for shimmer
      g2.gain.value = 0.015;
      g2.gain.setTargetAtTime(0, audioCtx.currentTime + 0.1, 0.08);
      osc2.connect(g2); g2.connect(musicGain);
      osc2.start(audioCtx.currentTime);
      osc2.stop(audioCtx.currentTime + 0.2);
    }, tempo * 0.4);

    // Bass notes in later levels
    if (gameMusicIntensity > 0.3 && mazeNoteIdx % 4 === 0) {
      const ob = audioCtx.createOscillator();
      const gb = audioCtx.createGain();
      ob.type = 'sine';
      ob.frequency.value = freq * 0.5;
      gb.gain.value = 0.025;
      gb.gain.setTargetAtTime(0, audioCtx.currentTime + 0.15, 0.08);
      ob.connect(gb); gb.connect(musicGain);
      ob.start(audioCtx.currentTime);
      ob.stop(audioCtx.currentTime + 0.3);
    }

    // Chime harmony in level 3
    if (gameMusicIntensity > 0.6 && mazeNoteIdx % 2 === 0) {
      const oc = audioCtx.createOscillator();
      const gc = audioCtx.createGain();
      oc.type = 'sine';
      oc.frequency.value = freq * 2;
      gc.gain.value = 0.012;
      gc.gain.setTargetAtTime(0, audioCtx.currentTime + 0.06, 0.04);
      oc.connect(gc); gc.connect(musicGain);
      oc.start(audioCtx.currentTime);
      oc.stop(audioCtx.currentTime + 0.12);
    }
  }

  mazeNoteIdx++;
  if (mazeNoteIdx >= phrase.length) mazeNoteIdx = 0;
  gameMusicTimeout = setTimeout(playMazeMusicNote, tempo);
}

// Wire up sound button and volume slider
document.getElementById('btn-sound').addEventListener('click', (e) => {
  toggleMute();
  e.stopPropagation();
  // Position volume popup near the button
  const btn = document.getElementById('btn-sound');
  const popup = document.getElementById('volume-popup');
  if (!audioMuted) {
    const rect = btn.getBoundingClientRect();
    popup.style.top = (rect.bottom + 4) + 'px';
    popup.style.right = (window.innerWidth - rect.right) + 'px';
    popup.style.display = 'block';
    setTimeout(() => { popup.style.display = 'none'; }, 3000);
  } else {
    popup.style.display = 'none';
  }
});

document.getElementById('volume-slider').addEventListener('input', (e) => {
  setVolume(parseInt(e.target.value) / 100);
});

// ============================================================
// GAME STATE
// ============================================================
let state = {
  coins: CONFIG.startingCoins,
  currentRoom: 0,
  ownedItems: [],
  placedItems: [],
  miceState: {
    pip: { x: 120, y: 0, room: 0, action: 'idle', actionTimer: 0, dir: 1, frame: 0, animTimer: 0, happiness: 80, level: 'main-floor' },
    chai:  { x: 250, y: 0, room: 1, action: 'idle', actionTimer: 0, dir: -1, frame: 0, animTimer: 0, happiness: 80, level: 'main-floor' }
  },
  birthdayEventSeen: false,
  letterRead: false,
  lootCrumbsUsed: 0,
  totalCoinsEarned: 0,
  placementMode: null,
  removeMode: false,
  dragState: { active: false, itemId: null, screenX: 0, screenY: 0, fromPlaced: false, fromPlacedIdx: -1 },
  shopOpen: false,
  gameStarted: false,
  activeGoal: null
};

// ============================================================
// FURNITURE CATALOG
// ============================================================
const FURNITURE = [
  { id: 'matchbox-bed', name: 'Matchbox Bed', icon: 'üõè', price: 10,
    desc: 'A cozy matchbox. Smells like sulfur and dreams.', w: 2, h: 1,
    color: '#8B4513', mouseBehavior: 'sleeping' },
  { id: 'thimble-cup', name: 'Thimble Cup', icon: '‚òï', price: 5,
    desc: "One thimble of coffee. It's a latte, actually.", w: 1, h: 1,
    color: '#C0C0C0', mouseBehavior: 'eating' },
  { id: 'bottlecap-plate', name: 'Bottle Cap Plate', icon: 'üçΩ', price: 5,
    desc: 'Fine dining. Michelin star pending.', w: 1, h: 1,
    color: '#FF6347', mouseBehavior: 'eating' },
  { id: 'fairy-lights', name: 'Fairy Lights', icon: '‚ú®', price: 15,
    desc: 'Aesthetic‚Ñ¢. Very cottagecore.', w: 3, h: 1,
    color: '#FFD700', mouseBehavior: null, wallMount: true },
  { id: 'tiny-laptop', name: 'Tiny Laptop', icon: 'üíª', price: 30,
    desc: 'For doomscrolling at 3am. No judgment.', w: 1, h: 1,
    color: '#708090', mouseBehavior: 'doomscrolling' },
  { id: 'yoga-mat', name: 'Yoga Mat', icon: 'üßò', price: 12,
    desc: 'Namaste in bed, actually.', w: 2, h: 1,
    color: '#9370DB', mouseBehavior: 'yoga' },
  { id: 'live-laugh-cheese', name: '"Live Laugh Cheese"', icon: 'üìú', price: 8,
    desc: 'The pinnacle of interior design.', w: 2, h: 1,
    color: '#FFF8DC', mouseBehavior: null, wallMount: true },
  { id: 'sourdough', name: 'Sourdough Starter', icon: 'üçû', price: 20,
    desc: "Started in 2020. Has a name. Don't ask.", w: 1, h: 1,
    color: '#DEB887', mouseBehavior: 'eating', servings: 6 },
  { id: 'ring-light', name: 'Ring Light', icon: 'üí°', price: 18,
    desc: 'Content creation station. Very influencer.', w: 1, h: 1,
    color: '#FFE4B5', mouseBehavior: null },
  { id: 'cardboard-couch', name: 'Cardboard Couch', icon: 'üõã', price: 15,
    desc: "It's giving... IKEA but make it rodent.", w: 2, h: 1,
    color: '#8FBC8F', mouseBehavior: 'idle' },
  { id: 'spool-table', name: 'Spool Table', icon: 'ü™ë', price: 10,
    desc: 'Upcycled. Sustainable. Cottagecore.', w: 1, h: 1,
    color: '#D2691E', mouseBehavior: null },
  { id: 'eraser-tv', name: 'Eraser TV', icon: 'üì∫', price: 20,
    desc: 'Only shows static but they love it.', w: 1, h: 1,
    color: '#2F4F4F', mouseBehavior: 'watching' },
  { id: 'ethernet-rope', name: 'Ethernet Jump Rope', icon: 'üîå', price: 10,
    desc: 'Cat5e for cardio. Technically still connected.', w: 1, h: 1,
    color: '#4682B4', mouseBehavior: 'playing' },
  { id: 'cork-stool', name: 'Cork Stool', icon: 'ü™ë', price: 6,
    desc: 'Wine night leftover. Reduce reuse re-sit.', w: 1, h: 1,
    color: '#BC8F8F', mouseBehavior: null },
  { id: 'tiny-plant', name: 'Tiny Plant', icon: 'ü™¥', price: 8,
    desc: "It's fake but we don't talk about that.", w: 1, h: 1,
    color: '#228B22', mouseBehavior: null },
  { id: 'disco-ball', name: 'Disco Ball', icon: 'ü™©', price: 22,
    desc: 'For when the zoomies hit at midnight.', w: 1, h: 1,
    color: '#E0E0E0', mouseBehavior: 'zoomies', wallMount: true },
  { id: 'among-us-bean', name: 'Sus Beanbag', icon: 'ü´ò', price: 15,
    desc: 'A bit sus but very comfy. Emergency nap.', w: 1, h: 1,
    color: '#EF4444', mouseBehavior: 'sleeping' },
  { id: 'cheese-wheel', name: 'Cheese Wheel', icon: 'üßÄ', price: 25,
    desc: 'The holy grail. The one cheese to rule them all.', w: 1, h: 1,
    color: '#FFD700', mouseBehavior: 'eating', servings: 4 },
  { id: 'cheese-wedge', name: 'Cheese Wedge', icon: 'üßÄ', price: 5,
    desc: 'A lil snack. Gone in three bites.', w: 1, h: 1,
    color: '#f0c040', mouseBehavior: 'eating', servings: 3, isFood: true },
  { id: 'blueberry-bowl', name: 'Blueberry Bowl', icon: 'ü´ê', price: 3,
    desc: 'Antioxidants! Five tiny berries of joy.', w: 1, h: 1,
    color: '#4a5ab0', mouseBehavior: 'eating', servings: 5, isFood: true },
  { id: 'stamp-painting', name: 'Stamp Painting', icon: 'üñº', price: 8,
    desc: 'Is it modern art? Is it a stamp? Yes.', w: 1, h: 1,
    color: '#DDA0DD', mouseBehavior: null, wallMount: true },
  { id: 'tiny-hoodie', name: 'Tiny Hoodie Rack', icon: 'üß•', price: 12,
    desc: 'For when the vibes are chilly.', w: 1, h: 1,
    color: '#4169E1', mouseBehavior: null },
  // Birthday items (hidden until birthday event)
  { id: 'birthday-cake', name: 'Birthday Cake', icon: 'üéÇ', price: 0,
    desc: 'Happy 20th Nico & Rose! üéâ', w: 1, h: 1,
    color: '#FF69B4', mouseBehavior: 'eating', birthday: true },
  { id: 'party-banner', name: 'Party Banner', icon: 'üéâ', price: 0,
    desc: "It's giving... birthday.", w: 3, h: 1,
    color: '#FF1493', mouseBehavior: null, birthday: true, wallMount: true },
  { id: 'exercise-wheel', name: 'Exercise Wheel', icon: 'üé°', price: 0,
    desc: 'Cardio queen era. Spin to win.', w: 3, h: 3,
    color: '#708898', mouseBehavior: 'wheeling', exerciseRoom: true },
];

// ============================================================
// CANVAS SETUP ‚Äî 480x360 game coords, scaled to fit
// ============================================================
const canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
const GAME_W = 480;
const GAME_H = 360;
const GRID_SIZE = 24;
const SNAP_SIZE = 12; // finer placement grid (half-cell)
const ROOM_Y = 40;
const ROOM_H = 280;
const ROOM_W = GAME_W;
const FLOOR_H = 40;
const GRID_COLS = Math.floor((ROOM_W - 16) / GRID_SIZE);
const GRID_ROWS = Math.floor((ROOM_H - FLOOR_H - 30) / GRID_SIZE);
const SNAP_COLS = GRID_COLS * 2; // snap grid columns
const SNAP_ROWS = GRID_ROWS * 2; // snap grid rows
const GRID_OFFSET_X = 8;
const GRID_OFFSET_Y = ROOM_Y + 30;

let scale = 1, offsetX = 0, offsetY = 0;

function resizeCanvas() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const isMobile = w <= 480;
  // On mobile, HUD is in flow above canvas ‚Äî subtract its height
  const hudEl = document.getElementById('hud');
  const hudH = (isMobile && hudEl && hudEl.style.display !== 'none') ? hudEl.offsetHeight : 0;
  const availH = h - hudH;
  scale = Math.min(w / GAME_W, availH / GAME_H);
  canvas.style.width = (GAME_W * scale) + 'px';
  canvas.style.height = (GAME_H * scale) + 'px';
  const dpr = window.devicePixelRatio || 1;
  canvas.width = GAME_W * dpr;
  canvas.height = GAME_H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  offsetX = (w - GAME_W * scale) / 2;
  offsetY = isMobile ? 0 : (h - GAME_H * scale) / 2;
  canvas.style.marginLeft = offsetX + 'px';
  canvas.style.marginTop = isMobile ? '0px' : offsetY + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function screenToGame(sx, sy) {
  const rect = canvas.getBoundingClientRect();
  return { x: (sx - rect.left) / scale, y: (sy - rect.top) / scale };
}
function gameToGrid(gx, gy) {
  // Snap to half-cell (SNAP_SIZE) for finer placement precision
  return {
    col: Math.floor((gx - GRID_OFFSET_X) / SNAP_SIZE) / 2,
    row: Math.floor((gy - GRID_OFFSET_Y) / SNAP_SIZE) / 2
  };
}
function gridToGame(col, row) {
  return { x: GRID_OFFSET_X + col * GRID_SIZE, y: GRID_OFFSET_Y + row * GRID_SIZE };
}

// ============================================================
// TOAST
// ============================================================
let toastTimeout;
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => el.classList.remove('show'), 3000);
}

// ============================================================
// SAVE / LOAD
// ============================================================
function saveGame() {
  try {
    localStorage.setItem('mouseHouseSave', JSON.stringify({
      coins: state.coins, ownedItems: state.ownedItems,
      placedItems: state.placedItems, currentRoom: state.currentRoom,
      miceState: state.miceState, birthdayEventSeen: state.birthdayEventSeen,
      letterRead: state.letterRead, lootCrumbsUsed: state.lootCrumbsUsed,
      totalCoinsEarned: state.totalCoinsEarned, activeGoal: state.activeGoal
    }));
  } catch (e) {}
}

function loadGame() {
  try {
    const d = JSON.parse(localStorage.getItem('mouseHouseSave'));
    if (d) {
      state.coins = d.coins ?? CONFIG.startingCoins;
      state.ownedItems = d.ownedItems ?? [];
      state.placedItems = d.placedItems ?? [];
      // Initialize servings on food items loaded from old saves
      state.placedItems.forEach(p => {
        const item = FURNITURE.find(f => f.id === p.itemId);
        if (item && item.servings && p.servings === undefined) p.servings = item.servings;
      });
      // Remove stale food items with 0 servings (from interrupted saves)
      state.placedItems = state.placedItems.filter(p => {
        const item = FURNITURE.find(f => f.id === p.itemId);
        return !(item && item.servings && p.servings !== undefined && p.servings <= 0);
      });
      state.currentRoom = d.currentRoom ?? 0;
      state.birthdayEventSeen = d.birthdayEventSeen ?? false;
      state.letterRead = d.letterRead ?? false;
      state.lootCrumbsUsed = d.lootCrumbsUsed ?? 0;
      state.totalCoinsEarned = d.totalCoinsEarned ?? 0;
      state.activeGoal = d.activeGoal ?? null;
      if (d.miceState) {
        Object.assign(state.miceState.pip, d.miceState.pip || d.miceState.shadow || {});
        Object.assign(state.miceState.chai, d.miceState.chai || d.miceState.cloud || {});
      }
    }
  } catch (e) {}
}

function closeModal() { document.getElementById('modal-container').innerHTML = ''; }

function updateCoinDisplay() {
  document.getElementById('coin-display').textContent = state.coins;
  const flyoutCoins = document.getElementById('flyout-coin-display');
  if (flyoutCoins) flyoutCoins.textContent = state.coins;
}

// ============================================================
// ROOM TABS
// ============================================================
const ROOMS = [
  {
    name: 'Bedroom', icon: 'üõè',
    wallTop: '#5c4a6e', wallBot: '#4a3a5c', floor: '#6b5a50', floorAlt: '#5e4e44',
    baseboard: '#7a6a5a', ceiling: '#6e5a80', accent: '#8a70a0',
    windowNight: '#1a1a3e', windowGlow: '#2a2a5e', shelfColor: '#7a6a5a',
    // Window: left side to avoid loft on right
    window: { x: 60, y: ROOM_Y + 14, w: 58, h: 50 },
    // Shelves: left side only (right has the loft platform)
    shelves: [{ x: 20, y: ROOM_Y + 90, w: 70 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'loft', y: 175, xMin: 220, xMax: 460 }
    ],
    ramps: [
      { from: 'main-floor', to: 'loft', x1: 200, x2: 235, style: 'ladder' }
    ]
  },
  {
    name: 'Kitchen', icon: 'üç≥',
    wallTop: '#4a6e5a', wallBot: '#3a5c4a', floor: '#6b6050', floorAlt: '#5e5444',
    baseboard: '#7a6a5a', ceiling: '#5a8068', accent: '#70a08a',
    windowNight: '#1a2e1a', windowGlow: '#2a4e2a', shelfColor: '#8a7a60',
    // Window: right side, above counter area is clear
    window: { x: 340, y: ROOM_Y + 12, w: 72, h: 52 },
    // Shelves: right side only (left has counter platform)
    shelves: [{ x: ROOM_W - 110, y: ROOM_Y + 100, w: 80 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'counter', y: 190, xMin: 20, xMax: 230 }
    ],
    ramps: [
      { from: 'main-floor', to: 'counter', x1: 230, x2: 265, style: 'ramp' }
    ]
  },
  {
    name: 'Living Room', icon: 'üõã',
    wallTop: '#6e5a4a', wallBot: '#5c4a3a', floor: '#6b5a48', floorAlt: '#5e4e3e',
    baseboard: '#7a6a5a', ceiling: '#806a50', accent: '#a08a60',
    windowNight: '#2e1a1a', windowGlow: '#4e2a2a', shelfColor: '#7a6a50',
    // Window: centered-left, wide and short
    window: { x: 40, y: ROOM_Y + 18, w: 80, h: 44 },
    // Shelves: far right (box-shelf is center-left)
    shelves: [{ x: ROOM_W - 95, y: ROOM_Y + 85, w: 65 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'box-shelf', y: 195, xMin: 140, xMax: 350 }
    ],
    ramps: [
      { from: 'main-floor', to: 'box-shelf', x1: 120, x2: 155, style: 'ramp' }
    ]
  },
  {
    name: 'Exercise Room', icon: 'üèÉ',
    wallTop: '#4a5a6e', wallBot: '#3a4a5c', floor: '#5a6050', floorAlt: '#4e5444',
    baseboard: '#6a7a8a', ceiling: '#5a6a80', accent: '#6080a0',
    windowNight: '#1a1a2e', windowGlow: '#2a2a4e', shelfColor: '#6a7a8a',
    // Window: left side, tall narrow (gym-style)
    window: { x: 50, y: ROOM_Y + 10, w: 50, h: 60 },
    // Shelves: left side (perch is on the right)
    shelves: [{ x: 130, y: ROOM_Y + 95, w: 75 }, { x: 20, y: ROOM_Y + 130, w: 55 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'perch', y: 185, xMin: 340, xMax: 460 }
    ],
    ramps: [
      { from: 'main-floor', to: 'perch', x1: 318, x2: 350, style: 'ladder' }
    ]
  }
];

// Ring layout helpers: rooms connect in a circle 0‚Üî1‚Üî2‚Üî3‚Üî0
function roomLeft(i)  { return (i - 1 + ROOMS.length) % ROOMS.length; }
function roomRight(i) { return (i + 1) % ROOMS.length; }
// Shortest ring direction from 'from' to 'to': -1 = left, +1 = right, 0 = same
function ringDirection(from, to) {
  if (from === to) return 0;
  const n = ROOMS.length;
  const rightDist = (to - from + n) % n;
  const leftDist  = (from - to + n) % n;
  return rightDist <= leftDist ? 1 : -1;
}
// Next room one step toward 'to' on the ring
function ringStepToward(from, to) {
  const dir = ringDirection(from, to);
  if (dir === 0) return from;
  return dir > 0 ? roomRight(from) : roomLeft(from);
}

function buildRoomTabs() {
  const tabsHTML =
    ROOMS.map((r, i) =>
      `<button class="${i === state.currentRoom ? 'active' : ''}" onclick="switchRoom(${i})">${r.icon}</button>`
    ).join('');
  document.getElementById('room-tabs').innerHTML = tabsHTML;
  const mobile = document.getElementById('room-tabs-mobile');
  if (mobile) mobile.innerHTML = tabsHTML;
}
// Room slide transition state
let roomTransition = { active: false, from: 0, to: 0, dir: 0, progress: 0, duration: 300 };

function switchRoom(i) {
  if (i === state.currentRoom) return;
  if (roomTransition.active) return; // ignore during animation
  const prevRoom = state.currentRoom;
  // Determine slide direction on the ring
  const dir = ringDirection(prevRoom, i);
  // Start slide animation
  roomTransition = { active: true, from: prevRoom, to: i, dir, progress: 0, duration: 300 };
  state.currentRoom = i;
  buildRoomTabs();
  saveGame();

  // "Caught in the act" ‚Äî if a mouse is alone in this room doing mischief/grooming/eating
  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    if (mouse.room !== i) return;
    const otherKey = key === 'pip' ? 'chai' : 'pip';
    const other = state.miceState[otherKey];
    const isAlone = other.room !== i;
    const caughtActions = ['mischief', 'eating', 'grooming', 'doomscrolling'];
    if (isAlone && caughtActions.includes(mouse.action) && Math.random() < 0.5) {
      // Freeze and look guilty
      const prevAction = mouse.action;
      mouse.action = 'idle';
      mouse.actionTimer = 2000;
      mouse._startled = true;
      mouse._startleTimer = 800;
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== key);
      const caughtQuotes = prevAction === 'mischief'
        ? ['...wasn\'t doing anything üòÖ', 'this isn\'t what it looks like', 'I was just... inspecting', 'you saw nothing üôà']
        : prevAction === 'doomscrolling'
        ? ['I wasn\'t on my phone!', '*closes 47 tabs*', 'just checking the weather üòÖ']
        : ['totally normal behavior', 'how long were you watching üëÄ', 'oh hi! üò≥'];
      speechBubbles.push({
        x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: caughtQuotes[Math.floor(Math.random() * caughtQuotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey: key
      });
    }
  });
}

// Draw a room and its mice at a given x-offset (used for slide transitions)
function drawRoomScene(roomIndex, offsetX) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(Math.max(0, offsetX), 0, GAME_W, GAME_H);
  ctx.clip();
  ctx.translate(offsetX, 0);
  drawRoom(roomIndex);
  // Draw mice in this room
  const pip = state.miceState.pip;
  const chai = state.miceState.chai;
  if (pip.room === roomIndex && pip.action !== 'wheeling') {
    const fy = getMouseFloorY(pip);
    if (pip.action === 'flung') drawFlungMouse(pip, CONFIG.mice.pip);
    else drawMouse(pip.x, fy, CONFIG.mice.pip, pip.dir, pip.frame, pip.action, pip._startled);
    drawPartyHat(pip.action === 'flung' ? pip.flingX : pip.x,
                 pip.action === 'flung' ? pip.flingY : fy, pip.action, pip.dir, CONFIG.mice.pip);
  }
  if (chai.room === roomIndex && chai.action !== 'wheeling') {
    const fy = getMouseFloorY(chai);
    if (chai.action === 'flung') drawFlungMouse(chai, CONFIG.mice.chai);
    else drawMouse(chai.x, fy, CONFIG.mice.chai, chai.dir, chai.frame, chai.action, chai._startled);
    drawPartyHat(chai.action === 'flung' ? chai.flingX : chai.x,
                 chai.action === 'flung' ? chai.flingY : fy, chai.action, chai.dir, CONFIG.mice.chai);
  }
  ctx.restore();
}

// ============================================================
// PARTICLES (dust motes, floating in rooms)
// ============================================================
let particles = [];
function initParticles() {
  for (let i = 0; i < 25; i++) {
    particles.push({
      x: Math.random() * GAME_W,
      y: ROOM_Y + Math.random() * ROOM_H,
      size: 0.8 + Math.random() * 1.5,
      speedX: (Math.random() - 0.5) * 0.12,
      speedY: -0.04 - Math.random() * 0.08,
      alpha: 0.12 + Math.random() * 0.18,
      phase: Math.random() * Math.PI * 2, // for sine drift
      sizePhase: Math.random() * Math.PI * 2 // for size pulsing
    });
  }
}
function updateParticles(dt) {
  const t = Date.now() / 1000;
  particles.forEach(p => {
    p.x += (p.speedX + Math.sin(t * 0.7 + p.phase) * 0.04) * dt * 0.06;
    p.y += p.speedY * dt * 0.06;
    if (p.y < ROOM_Y) { p.y = ROOM_Y + ROOM_H; p.x = Math.random() * GAME_W; }
    if (p.x < 0) p.x = GAME_W;
    if (p.x > GAME_W) p.x = 0;
  });
}
function drawParticles() {
  const t = Date.now() / 1000;
  particles.forEach(p => {
    const pulsedSize = p.size + Math.sin(t * 1.5 + p.sizePhase) * 0.3;
    // Glow brighter near window light (check if in light cone area)
    const room = ROOMS[state.currentRoom];
    const win = room.window || { x: GAME_W / 2 - 34, y: ROOM_Y + 16, w: 68, h: 56 };
    const distToLight = Math.abs(p.x - (win.x + win.w / 2)) / GAME_W;
    const glowBoost = Math.max(0, 1 - distToLight * 3) * 0.15;
    const alpha = Math.min(0.45, p.alpha + glowBoost);
    // Radial gradient for luminous look
    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, pulsedSize * 2);
    grad.addColorStop(0, `rgba(255, 245, 220, ${alpha})`);
    grad.addColorStop(1, `rgba(255, 240, 210, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(p.x, p.y, pulsedSize * 2, 0, Math.PI * 2);
    ctx.fill();
  });
}

// ============================================================
// ROOM RENDERING
// ============================================================
function drawRoom(roomIndex) {
  const room = ROOMS[roomIndex];
  const t = Date.now() / 1000;

  // -- Top bar --
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, ROOM_Y);

  // -- Wall gradient (top to bottom) --
  const wallGrad = ctx.createLinearGradient(0, ROOM_Y, 0, ROOM_Y + ROOM_H - FLOOR_H);
  wallGrad.addColorStop(0, room.wallTop);
  wallGrad.addColorStop(1, room.wallBot);
  ctx.fillStyle = wallGrad;
  ctx.fillRect(0, ROOM_Y, ROOM_W, ROOM_H - FLOOR_H);

  // -- Subtle wall texture (soft horizontal lines) --
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  for (let y = ROOM_Y + 8; y < ROOM_Y + ROOM_H - FLOOR_H; y += 12) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(ROOM_W, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1.0;

  // -- Wall stipple texture (scattered tiny dots for grain) --
  ctx.fillStyle = 'rgba(0,0,0,0.03)';
  for (let i = 0; i < 60; i++) {
    // Deterministic positions based on room index for consistency
    const sx = ((i * 137 + roomIndex * 53) % 467) / 467 * ROOM_W;
    const sy = ROOM_Y + ((i * 89 + roomIndex * 31) % 239) / 239 * (ROOM_H - FLOOR_H);
    ctx.fillRect(sx, sy, 1, 1);
  }

  // -- Corner vignettes (darken edges for depth) --
  const vigL = ctx.createLinearGradient(0, 0, 60, 0);
  vigL.addColorStop(0, 'rgba(0,0,0,0.12)');
  vigL.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = vigL;
  ctx.fillRect(0, ROOM_Y, 60, ROOM_H - FLOOR_H);
  const vigR = ctx.createLinearGradient(ROOM_W, 0, ROOM_W - 60, 0);
  vigR.addColorStop(0, 'rgba(0,0,0,0.12)');
  vigR.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = vigR;
  ctx.fillRect(ROOM_W - 60, ROOM_Y, 60, ROOM_H - FLOOR_H);
  // Top corner darkening
  const vigT = ctx.createLinearGradient(0, ROOM_Y, 0, ROOM_Y + 40);
  vigT.addColorStop(0, 'rgba(0,0,0,0.08)');
  vigT.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = vigT;
  ctx.fillRect(0, ROOM_Y, ROOM_W, 40);

  // -- Window with night sky ‚Äî parallax layers --
  const win = room.window || { x: GAME_W / 2 - 34, y: ROOM_Y + 16, w: 68, h: 56 };
  const winX = win.x;
  const winY = win.y;
  const winW = win.w, winH = win.h;
  // Window recess shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(winX - 3, winY - 3, winW + 6, winH + 6);
  // Night sky base
  ctx.fillStyle = room.windowNight;
  ctx.fillRect(winX, winY, winW, winH);

  // Parallax offset based on average mouse position
  const pipInRoom = state.miceState.pip.room === roomIndex;
  const chaiInRoom = state.miceState.chai.room === roomIndex;
  let avgMX = GAME_W / 2;
  if (pipInRoom && chaiInRoom) avgMX = (state.miceState.pip.x + state.miceState.chai.x) / 2;
  else if (pipInRoom) avgMX = state.miceState.pip.x;
  else if (chaiInRoom) avgMX = state.miceState.chai.x;
  const pxOffset = (avgMX / GAME_W - 0.5) * 6; // ¬±3px shift

  // Clip to window frame for parallax content
  ctx.save();
  ctx.beginPath();
  ctx.rect(winX, winY, winW, winH);
  ctx.clip();

  // Layer 1: Distant stars (slow parallax 0.2x)
  const distStars = [
    [0.08,0.12],[0.18,0.55],[0.32,0.08],[0.42,0.38],[0.55,0.22],[0.68,0.62],
    [0.78,0.15],[0.88,0.45],[0.95,0.28],[0.12,0.72],[0.62,0.82],[0.38,0.68],
    [0.25,0.3],[0.72,0.4],[0.48,0.55],[0.85,0.7]
  ];
  distStars.forEach(([sx, sy], i) => {
    const twinkle = 0.3 + 0.5 * Math.abs(Math.sin(t * 0.8 + i * 2.3));
    ctx.globalAlpha = twinkle;
    ctx.fillStyle = i % 5 === 0 ? '#ffe8b0' : '#fffde0';
    const sz = i % 4 === 0 ? 1.5 : 0.8;
    ctx.beginPath();
    ctx.arc(winX + sx * winW + pxOffset * 0.2, winY + sy * winH, sz, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1.0;

  // Layer 2: Skyline silhouette (medium parallax 0.5x)
  ctx.fillStyle = 'rgba(15,10,30,0.6)';
  const skyY = winY + winH * 0.65;
  const skyOff = pxOffset * 0.5;
  ctx.beginPath();
  ctx.moveTo(winX - 5 + skyOff, winY + winH);
  // Varied building shapes
  const bldgs = [0, 0.12, 0.2, 0.28, 0.38, 0.48, 0.55, 0.65, 0.75, 0.85, 0.95, 1.05];
  const bHts =  [8, 18,   12,  22,   10,   26,   14,   20,   8,    16,   12,   6];
  bldgs.forEach((bx, i) => {
    const x = winX + bx * winW + skyOff;
    ctx.lineTo(x, skyY - bHts[i]);
    ctx.lineTo(x + winW * 0.06, skyY - bHts[i]);
  });
  ctx.lineTo(winX + winW + 5 + skyOff, winY + winH);
  ctx.closePath();
  ctx.fill();
  // Tiny lit windows in buildings
  ctx.fillStyle = 'rgba(255,220,100,0.4)';
  bldgs.forEach((bx, i) => {
    if (bHts[i] > 14 && Math.sin(t * 0.3 + i) > -0.3) {
      const x = winX + bx * winW + skyOff + winW * 0.015;
      ctx.fillRect(x, skyY - bHts[i] + 4, 2, 2);
      if (bHts[i] > 18) ctx.fillRect(x + 4, skyY - bHts[i] + 8, 2, 2);
    }
  });

  // Layer 3: Moon and close stars (full parallax 1x ‚Äî existing)
  // Moon glow
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = room.windowGlow;
  ctx.beginPath();
  ctx.arc(winX + winW - 14 + pxOffset, winY + 14, 18, 0, Math.PI * 2);
  ctx.fill();
  // Moon
  ctx.fillStyle = '#eee8d0';
  ctx.beginPath();
  ctx.arc(winX + winW - 14 + pxOffset, winY + 14, 7, 0, Math.PI * 2);
  ctx.fill();
  // Moon crescent shadow
  ctx.fillStyle = room.windowNight;
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.arc(winX + winW - 12 + pxOffset, winY + 13, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1.0;

  // Close twinkling stars
  const closeStars = [
    [0.15, 0.2], [0.3, 0.45], [0.5, 0.12], [0.7, 0.35], [0.85, 0.25],
    [0.25, 0.32], [0.6, 0.52]
  ];
  closeStars.forEach(([sx, sy], i) => {
    const twinkle = 0.5 + 0.5 * Math.abs(Math.sin(t * 1.8 + i * 1.7));
    ctx.globalAlpha = twinkle;
    ctx.fillStyle = '#fffde0';
    const sz = i % 3 === 0 ? 2 : 1.2;
    ctx.beginPath();
    ctx.arc(winX + sx * winW + pxOffset, winY + sy * winH, sz, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1.0;

  ctx.restore(); // end window clip
  // Window panes (cross)
  ctx.strokeStyle = '#8a7a60';
  ctx.lineWidth = 3;
  ctx.strokeRect(winX, winY, winW, winH);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(winX + winW / 2, winY);
  ctx.lineTo(winX + winW / 2, winY + winH);
  ctx.moveTo(winX, winY + winH / 2);
  ctx.lineTo(winX + winW, winY + winH / 2);
  ctx.stroke();
  // Window sill
  ctx.fillStyle = '#8a7a60';
  ctx.fillRect(winX - 6, winY + winH, winW + 12, 5);
  // Tiny curtains
  ctx.fillStyle = room.accent;
  ctx.globalAlpha = 0.4;
  ctx.fillRect(winX - 2, winY, 8, winH);
  ctx.fillRect(winX + winW - 6, winY, 8, winH);
  ctx.globalAlpha = 1.0;

  // -- Moonlight cone (light spilling from window onto floor) --
  const floorY = ROOM_Y + ROOM_H - FLOOR_H;
  const lightCenterX = winX + winW / 2;
  const coneSpread = winW * 0.8;
  const moonGrad = ctx.createLinearGradient(0, winY + winH, 0, floorY);
  moonGrad.addColorStop(0, 'rgba(180,200,255,0.06)');
  moonGrad.addColorStop(0.6, 'rgba(180,200,255,0.03)');
  moonGrad.addColorStop(1, 'rgba(180,200,255,0)');
  ctx.fillStyle = moonGrad;
  ctx.beginPath();
  ctx.moveTo(winX, winY + winH);
  ctx.lineTo(lightCenterX - coneSpread, floorY);
  ctx.lineTo(lightCenterX + coneSpread, floorY);
  ctx.lineTo(winX + winW, winY + winH);
  ctx.closePath();
  ctx.fill();
  // Floor light patch
  ctx.fillStyle = 'rgba(180,200,255,0.025)';
  ctx.beginPath();
  ctx.ellipse(lightCenterX, floorY + 4, coneSpread * 0.7, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // -- Wall shelves (per-room positions) --
  const shelves = room.shelves || [
    { x: 20, y: ROOM_Y + ROOM_H - FLOOR_H - 80, w: 80 },
    { x: ROOM_W - 100, y: ROOM_Y + ROOM_H - FLOOR_H - 80, w: 80 }
  ];
  shelves.forEach(shelf => {
    ctx.fillStyle = room.shelfColor;
    ctx.fillRect(shelf.x, shelf.y, shelf.w, 4);
    // Shelf brackets
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(shelf.x + 10, shelf.y + 4, 3, 10);
    ctx.fillRect(shelf.x + shelf.w - 13, shelf.y + 4, 3, 10);
  });

  // -- Warm light glow from above (ambient lamp effect) --
  const lampGrad = ctx.createRadialGradient(GAME_W / 2, ROOM_Y + 4, 10, GAME_W / 2, ROOM_Y + 60, 200);
  lampGrad.addColorStop(0, 'rgba(255, 220, 150, 0.08)');
  lampGrad.addColorStop(1, 'rgba(255, 220, 150, 0)');
  ctx.fillStyle = lampGrad;
  ctx.fillRect(0, ROOM_Y, GAME_W, ROOM_H - FLOOR_H);

  // -- Baseboard --
  ctx.fillStyle = room.baseboard;
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H - 5, ROOM_W, 5);
  // Baseboard shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H - 6, ROOM_W, 1);

  // -- Floor --
  ctx.fillStyle = room.floor;
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H, ROOM_W, FLOOR_H);
  // Floor boards
  ctx.strokeStyle = room.floorAlt;
  ctx.lineWidth = 1;
  for (let fx = 0; fx < ROOM_W; fx += 36) {
    ctx.beginPath();
    ctx.moveTo(fx, ROOM_Y + ROOM_H - FLOOR_H);
    ctx.lineTo(fx, ROOM_Y + ROOM_H);
    ctx.stroke();
  }
  // Floor highlight
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H, ROOM_W, 2);

  // -- Ceiling trim --
  ctx.fillStyle = room.ceiling;
  ctx.fillRect(0, ROOM_Y, ROOM_W, 5);
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(0, ROOM_Y + 5, ROOM_W, 1);

  // -- Dollhouse frame edges (left & right walls) --
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(0, ROOM_Y, 4, ROOM_H);
  ctx.fillRect(ROOM_W - 4, ROOM_Y, 4, ROOM_H);
  // Inner wall shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(4, ROOM_Y, 6, ROOM_H);
  ctx.fillRect(ROOM_W - 10, ROOM_Y, 6, ROOM_H);

  // -- Dust particles --
  drawParticles();

  // -- Platforms & Ramps --
  if (room.platforms) {
    room.platforms.forEach(plat => {
      if (plat.id === 'main-floor') return; // main floor already drawn
      const pw = plat.xMax - plat.xMin;

      // Darkened wall behind platform (alcove depth effect)
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fillRect(plat.xMin, plat.y - 30, pw, 30);

      // Platform shadow
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fillRect(plat.xMin + 2, plat.y + 6, pw, 4);

      // Platform surface (wooden plank)
      const platGrad = ctx.createLinearGradient(0, plat.y, 0, plat.y + 6);
      platGrad.addColorStop(0, room.shelfColor);
      platGrad.addColorStop(1, room.baseboard);
      ctx.fillStyle = platGrad;
      ctx.fillRect(plat.xMin, plat.y, pw, 6);

      // Plank lines
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 0.5;
      for (let px = plat.xMin + 30; px < plat.xMax; px += 30) {
        ctx.beginPath();
        ctx.moveTo(px, plat.y);
        ctx.lineTo(px, plat.y + 6);
        ctx.stroke();
      }

      // Top highlight
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(plat.xMin, plat.y, pw, 1);

      // Bottom edge shadow
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(plat.xMin, plat.y + 5, pw, 1);

      // Support brackets
      const bracketW = 4;
      const bracketH = 14;
      const bracketColor = room.baseboard;
      const bracketPositions = [plat.xMin + 10, plat.xMax - 14];
      if (pw > 150) bracketPositions.push(plat.xMin + Math.floor(pw / 2));
      bracketPositions.forEach(bx => {
        // Vertical bracket
        ctx.fillStyle = bracketColor;
        ctx.fillRect(bx, plat.y + 6, bracketW, bracketH);
        // Diagonal brace
        ctx.strokeStyle = bracketColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bx + bracketW, plat.y + 6);
        ctx.lineTo(bx + bracketW + 8, plat.y + 6 + bracketH);
        ctx.stroke();
      });
    });

    // Draw ramps
    if (room.ramps) {
      room.ramps.forEach(ramp => {
        const fromPlat = room.platforms.find(p => p.id === ramp.from);
        const toPlat = room.platforms.find(p => p.id === ramp.to);
        if (!fromPlat || !toPlat) return;

        const y1 = fromPlat.y;
        const y2 = toPlat.y;
        const rampW = ramp.x2 - ramp.x1;

        if (ramp.style === 'ladder') {
          // Ladder: two rails with rungs
          const railL = ramp.x1 + 2;
          const railR = ramp.x1 + rampW - 2;
          const railColor = '#8a7a60';

          // Rails
          ctx.strokeStyle = railColor;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(railL, y1); ctx.lineTo(railL, y2 + 6);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(railR, y1); ctx.lineTo(railR, y2 + 6);
          ctx.stroke();

          // Rungs
          const numRungs = Math.floor(Math.abs(y1 - y2) / 14);
          ctx.strokeStyle = '#9a8a70';
          ctx.lineWidth = 2;
          for (let i = 1; i <= numRungs; i++) {
            const ry = y2 + 6 + (i / (numRungs + 1)) * (y1 - y2 - 6);
            ctx.beginPath();
            ctx.moveTo(railL + 1, ry);
            ctx.lineTo(railR - 1, ry);
            ctx.stroke();
          }

          // Rail highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(railL + 1, y1); ctx.lineTo(railL + 1, y2 + 6);
          ctx.stroke();
        } else {
          // Ramp: angled plank
          ctx.save();

          // Ramp shadow
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.beginPath();
          ctx.moveTo(ramp.x1 + 2, y1 + 2);
          ctx.lineTo(ramp.x2 + 2, y2 + 8);
          ctx.lineTo(ramp.x2 + 2, y2 + 14);
          ctx.lineTo(ramp.x1 + 2, y1 + 8);
          ctx.closePath();
          ctx.fill();

          // Ramp surface
          const rampGrad = ctx.createLinearGradient(ramp.x1, y1, ramp.x2, y2);
          rampGrad.addColorStop(0, room.shelfColor);
          rampGrad.addColorStop(1, room.baseboard);
          ctx.fillStyle = rampGrad;
          ctx.beginPath();
          ctx.moveTo(ramp.x1, y1);
          ctx.lineTo(ramp.x2, y2 + 6);
          ctx.lineTo(ramp.x2, y2 + 12);
          ctx.lineTo(ramp.x1, y1 + 6);
          ctx.closePath();
          ctx.fill();

          // Cross-grip lines on ramp
          ctx.strokeStyle = 'rgba(0,0,0,0.12)';
          ctx.lineWidth = 1;
          const steps = Math.floor(rampW / 8);
          for (let i = 1; i < steps; i++) {
            const frac = i / steps;
            const rx = ramp.x1 + frac * rampW;
            const ry = y1 + frac * (y2 + 6 - y1);
            ctx.beginPath();
            ctx.moveTo(rx, ry);
            ctx.lineTo(rx, ry + 6);
            ctx.stroke();
          }

          // Top edge highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.12)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(ramp.x1, y1);
          ctx.lineTo(ramp.x2, y2 + 6);
          ctx.stroke();

          ctx.restore();
        }
      });
    }
  }

  // -- Draw placed furniture for this room --
  const roomItems = state.placedItems.filter(p => p.room === roomIndex);
  roomItems.forEach(placed => {
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (!item) return;

    // Furniture shadow (before drawing item)
    const fpos = gridToGame(placed.gridX, placed.gridY);
    const fw = item.w * GRID_SIZE;
    const fh = item.h * GRID_SIZE;
    if (!item.wallMount) {
      // Shadow offset slightly toward window light source
      const shadowOff = (fpos.x < winX + winW / 2) ? 3 : -3;
      ctx.fillStyle = 'rgba(0,0,0,0.07)';
      ctx.beginPath();
      ctx.ellipse(fpos.x + fw / 2 + shadowOff, fpos.y + fh + 1, fw / 2 + 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw the item
    if (item.id === 'exercise-wheel') {
      drawExerciseWheel(placed);
    } else {
      drawFurnitureItem(item, placed.gridX, placed.gridY, placed);
    }

    // Ambient glow for light-emitting furniture
    if (item.id === 'fairy-lights') {
      // Warm twinkling glow along the item width
      for (let li = 0; li < 5; li++) {
        const lx = fpos.x + (li + 0.5) * fw / 5;
        const ly = fpos.y + fh / 2;
        const flicker = 0.4 + 0.6 * Math.abs(Math.sin(t * 3 + li * 1.4));
        const glow = ctx.createRadialGradient(lx, ly, 0, lx, ly, 14);
        glow.addColorStop(0, `rgba(255, 210, 80, ${0.08 * flicker})`);
        glow.addColorStop(1, 'rgba(255, 210, 80, 0)');
        ctx.fillStyle = glow;
        ctx.fillRect(lx - 14, ly - 14, 28, 28);
      }
    } else if (item.id === 'ring-light') {
      const glow = ctx.createRadialGradient(fpos.x + fw / 2, fpos.y + fh / 2, 2, fpos.x + fw / 2, fpos.y + fh / 2, 20);
      glow.addColorStop(0, 'rgba(255, 250, 240, 0.1)');
      glow.addColorStop(1, 'rgba(255, 250, 240, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(fpos.x - 8, fpos.y - 8, fw + 16, fh + 16);
    } else if (item.id === 'eraser-tv') {
      const tvFlicker = 0.5 + 0.5 * Math.sin(t * 8 + Math.sin(t * 3) * 2);
      const glow = ctx.createRadialGradient(fpos.x + fw / 2, fpos.y + fh / 2, 1, fpos.x + fw / 2, fpos.y + fh / 2, 18);
      glow.addColorStop(0, `rgba(100, 180, 255, ${0.06 * tvFlicker})`);
      glow.addColorStop(1, 'rgba(100, 180, 255, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(fpos.x - 8, fpos.y - 8, fw + 16, fh + 16);
    } else if (item.id === 'tiny-laptop') {
      const glow = ctx.createRadialGradient(fpos.x + fw / 2, fpos.y + 2, 1, fpos.x + fw / 2, fpos.y + 2, 14);
      glow.addColorStop(0, 'rgba(120, 200, 255, 0.06)');
      glow.addColorStop(1, 'rgba(120, 200, 255, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(fpos.x - 6, fpos.y - 6, fw + 12, fh + 12);
    } else if (item.id === 'disco-ball') {
      // Rotating sparkle beams
      for (let bi = 0; bi < 4; bi++) {
        const angle = t * 1.5 + bi * Math.PI / 2;
        const bx = fpos.x + fw / 2 + Math.cos(angle) * 20;
        const by = fpos.y + fh / 2 + Math.sin(angle) * 15;
        ctx.fillStyle = `rgba(255,255,255,${0.04 + 0.03 * Math.sin(t * 4 + bi)})`;
        ctx.beginPath();
        ctx.arc(bx, by, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  });

  // -- Grid overlay in placement/drag mode --
  if (state.placementMode || state.removeMode || state.dragState.active) {
    ctx.strokeStyle = 'rgba(245,214,138,0.12)';
    ctx.lineWidth = 0.5;
    for (let r = 0; r < SNAP_ROWS; r++) {
      for (let c = 0; c < SNAP_COLS; c++) {
        const pos = gridToGame(c / 2, r / 2);
        ctx.strokeRect(pos.x, pos.y, SNAP_SIZE, SNAP_SIZE);
      }
    }
  }

  // -- Drag ghost preview --
  if (state.dragState.active) {
    const ds = state.dragState;
    const dragItem = FURNITURE.find(f => f.id === ds.itemId);
    if (dragItem) {
      const gPos = screenToGame(ds.screenX, ds.screenY);
      // Center the item on cursor
      const centerOffX = (dragItem.w * GRID_SIZE) / 2;
      const centerOffY = (dragItem.h * GRID_SIZE) / 2;
      const grid = gameToGrid(gPos.x - centerOffX + SNAP_SIZE / 2, gPos.y - centerOffY + SNAP_SIZE / 2);
      const excludeIdx = ds.fromPlaced ? ds.fromPlacedIdx : undefined;
      const valid = isPlacementValid(ds.itemId, grid.col, grid.row, excludeIdx);
      ctx.save();
      ctx.globalAlpha = 0.5;
      if (!valid) {
        // Red tint for invalid position
        ctx.globalAlpha = 0.4;
      }
      // Draw at snapped grid position
      const snapPos = gridToGame(grid.col, grid.row);
      if (dragItem.id !== 'exercise-wheel') {
        drawFurnitureItem(dragItem, grid.col, grid.row);
      }
      if (!valid) {
        // Red overlay
        ctx.fillStyle = 'rgba(255,50,50,0.3)';
        ctx.fillRect(snapPos.x, snapPos.y, dragItem.w * GRID_SIZE, dragItem.h * GRID_SIZE);
      }
      ctx.restore();
    }
  }

  // -- Room name label --
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  const labelW = ctx.measureText(`${room.icon} ${room.name}`).width + 20;
  ctx.fillRect(GAME_W / 2 - labelW / 2, ROOM_Y + ROOM_H - 20, labelW, 18);
  ctx.fillStyle = '#d0c0a0';
  ctx.font = '11px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`${room.icon} ${room.name}`, GAME_W / 2, ROOM_Y + ROOM_H - 11);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  // -- Bottom bar --
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, ROOM_Y + ROOM_H, GAME_W, GAME_H - ROOM_Y - ROOM_H);
}

// ============================================================
// FURNITURE RENDERING
// ============================================================
function drawFurnitureItem(item, gx, gy, placedRef) {
  const pos = gridToGame(gx, gy);
  const w = item.w * GRID_SIZE;
  const h = item.h * GRID_SIZE;
  const x = pos.x, y = pos.y;
  const t = Date.now() / 1000;

  // Parse item.color into r,g,b for shade derivation
  const _cc = item.color;
  const _pr = parseInt(_cc.slice(1,3),16), _pg = parseInt(_cc.slice(3,5),16), _pb = parseInt(_cc.slice(5,7),16);
  const lighter = `rgb(${Math.min(_pr+40,255)},${Math.min(_pg+40,255)},${Math.min(_pb+40,255)})`;
  const darker  = `rgb(${Math.max(_pr-40,0)},${Math.max(_pg-40,0)},${Math.max(_pb-40,0)})`;
  const darkest = `rgb(${Math.max(_pr-70,0)},${Math.max(_pg-70,0)},${Math.max(_pb-70,0)})`;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.beginPath();
  ctx.roundRect(x + 2, y + 2, w, h, 3);
  ctx.fill();

  switch (item.id) {

  case 'matchbox-bed': { // 2x1 48x24
    // Matchbox body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x, y+4, 48, 20, 2); ctx.fill();
    ctx.fillStyle = darker;
    ctx.fillRect(x+1, y+22, 46, 2); // bottom edge
    // Matchbox inner tray
    ctx.fillStyle = lighter;
    ctx.fillRect(x+3, y+6, 42, 14);
    // Pillow
    ctx.fillStyle = '#f0eee8';
    ctx.beginPath(); ctx.roundRect(x+5, y+8, 10, 8, 2); ctx.fill();
    ctx.fillStyle = '#ddd';
    ctx.fillRect(x+6, y+12, 8, 1);
    // Blanket/quilt
    ctx.fillStyle = '#6ba36b';
    ctx.beginPath(); ctx.roundRect(x+17, y+7, 26, 12, 2); ctx.fill();
    ctx.fillStyle = '#5a8f5a';
    ctx.fillRect(x+17, y+13, 26, 1);
    ctx.fillRect(x+29, y+7, 1, 12);
    // Striker strip on side
    ctx.fillStyle = '#3a2510';
    ctx.fillRect(x+1, y+8, 2, 12);
    break;
  }

  case 'thimble-cup': { // 1x1 24x24
    // Thimble body (tapered)
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+6, y+22); ctx.lineTo(x+4, y+8);
    ctx.quadraticCurveTo(x+12, y+3, x+20, y+8);
    ctx.lineTo(x+18, y+22); ctx.closePath(); ctx.fill();
    // Highlight
    ctx.fillStyle = lighter;
    ctx.fillRect(x+8, y+8, 3, 12);
    // Dimple dots near top
    ctx.fillStyle = darker;
    for (let r = 0; r < 2; r++) for (let c = 0; c < 4; c++) {
      ctx.fillRect(x+7+c*3, y+6+r*3, 1, 1);
    }
    // Rim
    ctx.fillStyle = darkest;
    ctx.fillRect(x+4, y+7, 16, 1);
    // Base
    ctx.fillStyle = darker;
    ctx.fillRect(x+6, y+22, 12, 2);
    // Steam wisps
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 2; i++) {
      const sx = x+10+i*5, sy = y+3;
      const off = Math.sin(t*2+i*2)*2;
      ctx.beginPath(); ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(sx+off, sy-4, sx-off, sy-7);
      ctx.stroke();
    }
    break;
  }

  case 'bottlecap-plate': { // 1x1 24x24
    const cx = x+12, cy = y+14;
    // Crimped edge
    ctx.fillStyle = item.color;
    ctx.beginPath();
    for (let i = 0; i < 16; i++) {
      const a = (i/16)*Math.PI*2, r = i%2===0 ? 10 : 8.5;
      const px = cx+Math.cos(a)*r, py = cy+Math.sin(a)*r;
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill();
    // Inner flat area
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.fill();
    // Food crumbs
    ctx.fillStyle = '#c89040';
    ctx.fillRect(cx-2, cy-1, 2, 2);
    ctx.fillRect(cx+2, cy+1, 1, 1);
    ctx.fillRect(cx-1, cy+3, 2, 1);
    break;
  }

  case 'fairy-lights': { // 3x1 72x24
    // Wire
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+2, y+10);
    for (let i = 0; i < 72; i += 4) {
      ctx.lineTo(x+i, y+10 + Math.sin(i*0.15)*3);
    }
    ctx.stroke();
    // Bulbs
    const colors = ['#ff4444','#44ff44','#4488ff','#ffdd00','#ff88ff','#00ffcc','#ffaa00','#88aaff'];
    for (let i = 0; i < 8; i++) {
      const bx = x+6+i*8.5, by = y+10+Math.sin((6+i*8.5)*0.15)*3;
      const twinkle = 0.5 + 0.5*Math.sin(t*4 + i*1.7);
      ctx.globalAlpha = 0.4 + twinkle*0.6;
      ctx.fillStyle = colors[i];
      ctx.beginPath(); ctx.arc(bx, by+2, 2.5, 0, Math.PI*2); ctx.fill();
      // Glow around bulb
      ctx.globalAlpha = twinkle*0.25;
      ctx.beginPath(); ctx.arc(bx, by+2, 5, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
    // Overall glow
    const glow = ctx.createRadialGradient(x+36, y+12, 4, x+36, y+12, 40);
    glow.addColorStop(0, 'rgba(255,240,180,0.12)');
    glow.addColorStop(1, 'rgba(255,240,180,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-10, y-10, 92, 44);
    break;
  }

  case 'tiny-laptop': { // 1x1 24x24
    // Base/keyboard
    ctx.fillStyle = darker;
    ctx.fillRect(x+3, y+15, 18, 7);
    ctx.fillStyle = darkest;
    ctx.fillRect(x+5, y+17, 14, 3); // keyboard area
    // Tiny key dots
    ctx.fillStyle = '#555';
    for (let r = 0; r < 2; r++) for (let c = 0; c < 5; c++)
      ctx.fillRect(x+6+c*3, y+17+r*2, 2, 1);
    // Screen (tilted back)
    ctx.fillStyle = item.color;
    ctx.fillRect(x+3, y+4, 18, 12);
    // Screen content
    ctx.fillStyle = '#1a2a4a';
    ctx.fillRect(x+5, y+5, 14, 9);
    // Blue glow on screen
    ctx.fillStyle = '#4488cc';
    ctx.fillRect(x+6, y+7, 12, 2);
    ctx.fillStyle = '#335577';
    ctx.fillRect(x+6, y+10, 8, 1);
    ctx.fillRect(x+6, y+12, 10, 1);
    // Hinge
    ctx.fillStyle = darkest;
    ctx.fillRect(x+3, y+15, 18, 1);
    break;
  }

  case 'yoga-mat': { // 2x1 48x24
    // Flat mat
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+2, y+14, 40, 8, 2); ctx.fill();
    // Stripe
    ctx.fillStyle = lighter;
    ctx.fillRect(x+4, y+17, 36, 2);
    // Rolled curl at right end
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.arc(x+43, y+18, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(x+43, y+18, 2.5, 0, Math.PI*2); ctx.fill();
    // Mat thickness shadow
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(x+2, y+21, 40, 2);
    break;
  }

  case 'live-laugh-cheese': { // 2x1 48x24
    // Frame
    ctx.fillStyle = '#a08050';
    ctx.beginPath(); ctx.roundRect(x+2, y+3, 44, 18, 2); ctx.fill();
    // Inner
    ctx.fillStyle = item.color;
    ctx.fillRect(x+4, y+5, 40, 14);
    // Text "LLL"
    ctx.fillStyle = '#8B7355';
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('LLL', x+24, y+12);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    // Small cheese doodle
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(x+37, y+14, 4, 3);
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+38, y+15, 1, 1);
    break;
  }

  case 'sourdough': { // 1x1 24x24
    // Jar
    ctx.fillStyle = '#a09080';
    ctx.fillRect(x+5, y+10, 14, 12);
    ctx.fillStyle = '#8a7a6a';
    ctx.fillRect(x+5, y+10, 14, 2); // rim
    // Dough blob rising out
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+6, y+12);
    ctx.quadraticCurveTo(x+8, y+5, x+12, y+5);
    ctx.quadraticCurveTo(x+16, y+4, x+18, y+12);
    ctx.closePath(); ctx.fill();
    // Bubbles
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(x+10, y+8, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+14, y+7, 1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+12, y+10, 1, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'ring-light': { // 1x1 24x24
    const cx = x+12, cy = y+10;
    // Stand
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cx, cy+6); ctx.lineTo(cx, y+22); ctx.stroke();
    ctx.fillStyle = '#555';
    ctx.fillRect(cx-4, y+21, 8, 2);
    // Ring
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.stroke();
    // Bright white glow
    ctx.strokeStyle = 'rgba(255,255,230,0.5)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.stroke();
    // Overall glow
    const glow = ctx.createRadialGradient(cx, cy, 4, cx, cy, 20);
    glow.addColorStop(0, 'rgba(255,250,220,0.15)');
    glow.addColorStop(1, 'rgba(255,250,220,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-8, y-8, 40, 40);
    break;
  }

  case 'cardboard-couch': { // 2x1 48x24
    // Main body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+2, y+6, 44, 16, 2); ctx.fill();
    // Armrests
    ctx.fillStyle = darker;
    ctx.fillRect(x+2, y+4, 6, 18);
    ctx.fillRect(x+40, y+4, 6, 18);
    // Seat cushion line
    ctx.fillStyle = lighter;
    ctx.fillRect(x+9, y+10, 30, 2);
    // Corrugated cardboard lines
    ctx.strokeStyle = darker;
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 6; i++) {
      const ly = y+8+i*2.5;
      ctx.beginPath(); ctx.moveTo(x+9, ly);
      for (let lx = 0; lx < 30; lx += 3) {
        ctx.lineTo(x+9+lx+1.5, ly + (lx%6===0?1:-1));
      }
      ctx.stroke();
    }
    // Bottom edge
    ctx.fillStyle = darkest;
    ctx.fillRect(x+2, y+21, 44, 2);
    break;
  }

  case 'spool-table': { // 1x1 24x24
    const cx = x+12;
    // Top disc
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.ellipse(cx, y+7, 10, 4, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.ellipse(cx, y+6, 8, 3, 0, 0, Math.PI*2); ctx.fill();
    // Center hole
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(cx, y+6, 2, 0, Math.PI*2); ctx.fill();
    // Narrow body
    ctx.fillStyle = item.color;
    ctx.fillRect(cx-4, y+7, 8, 10);
    // Thread wrapping hints
    ctx.fillStyle = '#dda0dd';
    ctx.fillRect(cx-4, y+9, 8, 2);
    ctx.fillRect(cx-4, y+13, 8, 2);
    // Base disc
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.ellipse(cx, y+18, 10, 4, 0, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'eraser-tv': { // 1x1 24x24
    // Antenna
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+9, y+7); ctx.lineTo(x+6, y+2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+15, y+7); ctx.lineTo(x+18, y+2); ctx.stroke();
    // TV body (eraser shape)
    ctx.fillStyle = '#e8a0a8';
    ctx.beginPath(); ctx.roundRect(x+3, y+7, 18, 14, 2); ctx.fill();
    // Eraser band at bottom
    ctx.fillStyle = '#3050a0';
    ctx.fillRect(x+3, y+17, 18, 4);
    // Screen
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(x+5, y+8, 14, 8);
    // Static lines
    ctx.fillStyle = '#445';
    const staticOff = Math.floor(t * 8) % 4;
    for (let i = 0; i < 4; i++) {
      const sy = y+9+((i*2+staticOff)%8);
      if (sy < y+16) ctx.fillRect(x+5, sy, 14, 1);
    }
    // Screen flicker
    ctx.fillStyle = `rgba(150,180,200,${0.05+0.05*Math.sin(t*10)})`;
    ctx.fillRect(x+5, y+8, 14, 8);
    break;
  }

  case 'ethernet-rope': { // 1x1 24x24
    // Coiled cable
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x+12, y+14, 6, 0.3, Math.PI*1.8); ctx.stroke();
    ctx.beginPath();
    ctx.arc(x+12, y+14, 3.5, 0.8, Math.PI*1.5); ctx.stroke();
    // RJ45 connector end
    ctx.fillStyle = '#ccc';
    ctx.fillRect(x+17, y+8, 4, 6);
    ctx.fillStyle = '#aaa';
    ctx.fillRect(x+18, y+9, 2, 4);
    // Clip on connector
    ctx.fillStyle = '#ddd';
    ctx.fillRect(x+18, y+7, 2, 2);
    // Cable coming off connector
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x+19, y+14); ctx.lineTo(x+18, y+17); ctx.stroke();
    break;
  }

  case 'cork-stool': { // 1x1 24x24
    // Cork body (upright cylinder)
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+6, y+5, 12, 17, 3); ctx.fill();
    // Lighter front face
    ctx.fillStyle = lighter;
    ctx.fillRect(x+8, y+7, 8, 13);
    // Dot texture
    ctx.fillStyle = darker;
    for (let r = 0; r < 4; r++) for (let c = 0; c < 3; c++) {
      ctx.fillRect(x+8+c*3, y+8+r*3.5, 1, 1);
    }
    // Top
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.ellipse(x+12, y+6, 6, 2.5, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = darker;
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.ellipse(x+12, y+6, 6, 2.5, 0, 0, Math.PI*2); ctx.stroke();
    break;
  }

  case 'tiny-plant': { // 1x1 24x24
    // Pot (trapezoid)
    ctx.fillStyle = '#b5651d';
    ctx.beginPath();
    ctx.moveTo(x+6, y+13); ctx.lineTo(x+8, y+22);
    ctx.lineTo(x+16, y+22); ctx.lineTo(x+18, y+13);
    ctx.closePath(); ctx.fill();
    // Pot rim
    ctx.fillStyle = '#c97a3a';
    ctx.fillRect(x+5, y+12, 14, 2);
    // Soil
    ctx.fillStyle = '#4a3520';
    ctx.beginPath(); ctx.ellipse(x+12, y+13, 6, 2, 0, 0, Math.PI*2); ctx.fill();
    // Leaves
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.ellipse(x+10, y+8, 3, 5, -0.3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#1e7a1e';
    ctx.beginPath(); ctx.ellipse(x+14, y+9, 2.5, 4, 0.3, 0, Math.PI*2); ctx.fill();
    // Tiny stem
    ctx.strokeStyle = '#2d5a1e';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+12, y+13); ctx.lineTo(x+12, y+8); ctx.stroke();
    break;
  }

  case 'disco-ball': { // 1x1 24x24
    const cx = x+12, cy = y+12;
    // String at top
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx, y+1); ctx.lineTo(cx, y+5); ctx.stroke();
    // Ball body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.fill();
    // Faceted mirror tiles
    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        const tx = cx + c*3, ty = cy + r*3;
        if ((tx-cx)**2+(ty-cy)**2 < 49) {
          const shimmer = 0.3 + 0.7*Math.sin(t*3 + r*2.1 + c*1.7);
          ctx.fillStyle = `rgba(255,255,255,${shimmer*0.6})`;
          ctx.fillRect(tx-1, ty-1, 2.5, 2.5);
        }
      }
    }
    // Sparkle reflections scattered
    for (let i = 0; i < 4; i++) {
      const sa = t*2 + i*1.57;
      const sr = 10 + Math.sin(t*1.3+i)*2;
      const sx = cx + Math.cos(sa)*sr, sy = cy + Math.sin(sa)*sr;
      if (sx > x && sx < x+24 && sy > y && sy < y+24) {
        ctx.fillStyle = `rgba(255,255,200,${0.4+0.4*Math.sin(t*5+i)})`;
        ctx.fillRect(sx-1, sy-1, 2, 2);
      }
    }
    // Glow
    const glow = ctx.createRadialGradient(cx, cy, 3, cx, cy, 18);
    glow.addColorStop(0, 'rgba(255,240,180,0.12)');
    glow.addColorStop(1, 'rgba(255,240,180,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-8, y-8, 40, 40);
    break;
  }

  case 'among-us-bean': { // 1x1 24x24
    // Body (bean shape)
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+8, y+5);
    ctx.quadraticCurveTo(x+18, y+3, x+18, y+10);
    ctx.lineTo(x+18, y+16);
    ctx.quadraticCurveTo(x+18, y+21, x+15, y+21);
    ctx.lineTo(x+14, y+17);
    ctx.lineTo(x+10, y+17);
    ctx.lineTo(x+9, y+21);
    ctx.quadraticCurveTo(x+6, y+21, x+6, y+16);
    ctx.lineTo(x+6, y+10);
    ctx.quadraticCurveTo(x+6, y+5, x+8, y+5);
    ctx.closePath(); ctx.fill();
    // Visor
    ctx.fillStyle = '#87CEEB';
    ctx.beginPath();
    ctx.moveTo(x+7, y+7);
    ctx.quadraticCurveTo(x+7, y+12, x+12, y+12);
    ctx.quadraticCurveTo(x+17, y+12, x+17, y+9);
    ctx.quadraticCurveTo(x+17, y+6, x+12, y+6);
    ctx.quadraticCurveTo(x+7, y+6, x+7, y+7);
    ctx.closePath(); ctx.fill();
    // Visor shine
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillRect(x+9, y+7, 3, 2);
    // Backpack bump
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.roundRect(x+17, y+10, 4, 7, 1);
    ctx.fill();
    break;
  }

  case 'cheese-wheel': { // 1x1 24x24
    // Wedge shape (3D-ish)
    // Top face
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+4, y+8); ctx.lineTo(x+20, y+8);
    ctx.lineTo(x+20, y+14); ctx.lineTo(x+4, y+14);
    ctx.closePath(); ctx.fill();
    // Front face (darker wedge)
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.moveTo(x+4, y+14); ctx.lineTo(x+20, y+14);
    ctx.lineTo(x+18, y+21); ctx.lineTo(x+6, y+21);
    ctx.closePath(); ctx.fill();
    // Side face
    ctx.fillStyle = darkest;
    ctx.beginPath();
    ctx.moveTo(x+20, y+8); ctx.lineTo(x+22, y+10);
    ctx.lineTo(x+20, y+16); ctx.lineTo(x+20, y+14);
    ctx.closePath(); ctx.fill();
    // Holes
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(x+10, y+11, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+16, y+10, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = darkest;
    ctx.beginPath(); ctx.arc(x+9, y+17, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+15, y+17, 1, 0, Math.PI*2); ctx.fill();
    // Rind edge
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+4, y+7, 16, 1);
    break;
  }

  case 'cheese-wedge': { // 1x1 24x24
    // Servings visual ‚Äî fade/shrink as eaten
    const placed = placedRef;
    const serv = placed && placed.servings !== undefined ? placed.servings : 3;
    const servFrac = serv / 3;
    const sw = Math.max(0.4, servFrac);
    ctx.save();
    ctx.translate(x + 12, y + 20);
    ctx.scale(sw, sw);
    ctx.translate(-(x + 12), -(y + 20));
    // Wedge triangle
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+4, y+20); ctx.lineTo(x+12, y+6); ctx.lineTo(x+20, y+20);
    ctx.closePath(); ctx.fill();
    // Rind
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+4, y+19, 16, 2);
    // Holes
    ctx.fillStyle = '#c89020';
    ctx.beginPath(); ctx.arc(x+10, y+15, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+14, y+12, 1, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    // Serving dots
    if (serv < 3) {
      for (let i = 0; i < serv; i++) {
        ctx.fillStyle = '#f0c040';
        ctx.beginPath(); ctx.arc(x + 8 + i * 4, y + 3, 1.5, 0, Math.PI*2); ctx.fill();
      }
    }
    break;
  }

  case 'blueberry-bowl': { // 1x1 24x24
    const placed = placedRef;
    const serv = placed && placed.servings !== undefined ? placed.servings : 5;
    // Bowl
    ctx.fillStyle = '#8a7a6a';
    ctx.beginPath();
    ctx.moveTo(x+4, y+12); ctx.quadraticCurveTo(x+4, y+22, x+12, y+22);
    ctx.quadraticCurveTo(x+20, y+22, x+20, y+12);
    ctx.lineTo(x+4, y+12);
    ctx.closePath(); ctx.fill();
    // Bowl rim
    ctx.fillStyle = '#9a8a7a';
    ctx.fillRect(x+3, y+11, 18, 2);
    // Berries (show remaining servings)
    const berryPositions = [[8,15],[14,15],[11,13],[7,17],[15,17]];
    for (let i = 0; i < Math.min(serv, 5); i++) {
      const bp = berryPositions[i];
      ctx.fillStyle = item.color;
      ctx.beginPath(); ctx.arc(x+bp[0], y+bp[1], 2.5, 0, Math.PI*2); ctx.fill();
      // Berry highlight
      ctx.fillStyle = '#7a8ad0';
      ctx.beginPath(); ctx.arc(x+bp[0]-0.5, y+bp[1]-0.5, 1, 0, Math.PI*2); ctx.fill();
    }
    break;
  }

  case 'stamp-painting': { // 1x1 24x24
    // Frame
    ctx.fillStyle = '#8B7355';
    ctx.beginPath(); ctx.roundRect(x+2, y+3, 20, 18, 1); ctx.fill();
    // Inner canvas
    ctx.fillStyle = '#faf0e6';
    ctx.fillRect(x+4, y+5, 16, 14);
    // Colorful abstract splotches
    ctx.fillStyle = '#e04060';
    ctx.beginPath(); ctx.arc(x+8, y+10, 3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#4080e0';
    ctx.beginPath(); ctx.arc(x+15, y+13, 2.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#40c060';
    ctx.fillRect(x+11, y+7, 4, 4);
    ctx.fillStyle = '#e0c040';
    ctx.beginPath(); ctx.arc(x+8, y+15, 2, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'tiny-hoodie': { // 1x1 24x24
    // Hook
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+12, y+2); ctx.lineTo(x+12, y+5);
    ctx.arc(x+12, y+4, 2, -Math.PI/2, Math.PI/2);
    ctx.stroke();
    // Body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+5, y+7, 14, 13, 2); ctx.fill();
    // Hood bump
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.arc(x+12, y+7, 5, Math.PI, 0); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(x+12, y+7, 3.5, Math.PI, 0); ctx.fill();
    // Sleeves
    ctx.fillStyle = darker;
    ctx.fillRect(x+3, y+9, 3, 7);
    ctx.fillRect(x+18, y+9, 3, 7);
    // Front pocket
    ctx.fillStyle = darkest;
    ctx.fillRect(x+8, y+15, 8, 3);
    // Drawstrings
    ctx.strokeStyle = lighter;
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(x+10, y+8); ctx.lineTo(x+10, y+11); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+14, y+8); ctx.lineTo(x+14, y+11); ctx.stroke();
    break;
  }

  case 'birthday-cake': { // 1x1 24x24
    // Bottom layer
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+4, y+14, 16, 8, 2); ctx.fill();
    // Frosting drips
    ctx.fillStyle = lighter;
    ctx.fillRect(x+4, y+14, 16, 3);
    ctx.fillRect(x+6, y+17, 2, 2);
    ctx.fillRect(x+14, y+17, 2, 2);
    // Top layer
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.roundRect(x+6, y+10, 12, 5, 1); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.fillRect(x+6, y+10, 12, 2);
    // Candle
    ctx.fillStyle = '#fff';
    ctx.fillRect(x+11, y+4, 2, 6);
    // Flame
    const flicker = Math.sin(t*8)*0.5;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.ellipse(x+12, y+3+flicker, 1.5, 2.5, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#ffdd00';
    ctx.beginPath();
    ctx.ellipse(x+12, y+3+flicker, 0.8, 1.5, 0, 0, Math.PI*2);
    ctx.fill();
    break;
  }

  case 'party-banner': { // 3x1 72x24
    // String
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+2, y+6);
    ctx.quadraticCurveTo(x+36, y+10, x+70, y+6);
    ctx.stroke();
    // Pennant flags
    const flagColors = ['#ff4466','#44bbff','#ffcc00','#66dd66','#ff88dd','#ff8844','#aa88ff','#44ffcc'];
    for (let i = 0; i < 8; i++) {
      const fx = x+6+i*8;
      const fy = y+6 + Math.sin((fx-x)/72*Math.PI)*4;
      ctx.fillStyle = flagColors[i % flagColors.length];
      ctx.beginPath();
      ctx.moveTo(fx-3, fy); ctx.lineTo(fx+3, fy);
      ctx.lineTo(fx, fy+10);
      ctx.closePath(); ctx.fill();
    }
    break;
  }

  default: {
    // Fallback: colored rect + emoji (for unknown items)
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(x+2, y+1, w-4, 3);
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(x+1, y+h-2, w-2, 2);
    const iconSize = Math.min(w, h) - 4;
    ctx.font = `${iconSize}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(item.icon, x + w/2, y + h/2 + 1);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    break;
  }

  } // end switch
}

// ============================================================
// EXERCISE WHEEL SYSTEM
// ============================================================
let wheelState = {
  angle: 0,        // current rotation angle
  speed: 0,        // spin speed (rad/frame)
  miceOn: [],      // keys of mice currently on the wheel ('pip', 'chai')
  flingTimer: 0,   // cooldown before another fling can happen
  flingTarget: null // mouse key being flung
};

function getWheelPlacement() {
  return state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === state.currentRoom);
}

function getWheelCenter(placed) {
  const pos = gridToGame(placed.gridX, placed.gridY);
  const w = 3 * GRID_SIZE; // wheel is 3x3 grid
  const h = 3 * GRID_SIZE;
  return { x: pos.x + w / 2, y: pos.y + h / 2 };
}

function drawExerciseWheel(placed) {
  const center = getWheelCenter(placed);
  const radius = 32;
  const t = Date.now() / 1000;

  // Wheel stand / frame
  ctx.fillStyle = '#5a4a3a';
  ctx.fillRect(center.x - 3, center.y + radius - 4, 6, 12);
  // Base feet
  ctx.fillRect(center.x - 14, center.y + radius + 6, 28, 4);
  ctx.fillStyle = '#4a3a2a';
  ctx.fillRect(center.x - 12, center.y + radius + 8, 24, 3);

  // Axle shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(center.x, center.y + radius + 8, 18, 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Outer wheel ring
  ctx.strokeStyle = '#8a9aaa';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  ctx.stroke();

  // Inner wheel ring (running surface)
  ctx.strokeStyle = '#6a7a8a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius - 5, 0, Math.PI * 2);
  ctx.stroke();

  // Spokes (rotate with wheel)
  ctx.strokeStyle = 'rgba(138,154,170,0.5)';
  ctx.lineWidth = 1.5;
  const numSpokes = 8;
  for (let i = 0; i < numSpokes; i++) {
    const a = wheelState.angle + (i / numSpokes) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(center.x + Math.cos(a) * 6, center.y + Math.sin(a) * 6);
    ctx.lineTo(center.x + Math.cos(a) * (radius - 2), center.y + Math.sin(a) * (radius - 2));
    ctx.stroke();
  }

  // Hub (center axle)
  ctx.fillStyle = '#aabbcc';
  ctx.beginPath();
  ctx.arc(center.x, center.y, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#8a9aaa';
  ctx.beginPath();
  ctx.arc(center.x, center.y, 3, 0, Math.PI * 2);
  ctx.fill();

  // Running treads on inner surface (rotating marks)
  ctx.fillStyle = 'rgba(90,100,110,0.3)';
  for (let i = 0; i < 16; i++) {
    const a = wheelState.angle + (i / 16) * Math.PI * 2;
    const tx = center.x + Math.cos(a) * (radius - 3);
    const ty = center.y + Math.sin(a) * (radius - 3);
    ctx.fillRect(tx - 1, ty - 1, 2, 2);
  }

  // Draw mice on the wheel
  wheelState.miceOn.forEach((mouseKey, idx) => {
    const mouse = state.miceState[mouseKey];
    const cfg = CONFIG.mice[mouseKey];
    if (mouse.action !== 'wheeling') return;

    // Mouse runs at bottom-inside of wheel, offset by wheel rotation
    // The mouse stays at roughly the bottom but the wheel rotates around it
    const mouseAngle = Math.PI / 2 + Math.sin(t * 3) * 0.15; // slight bobbing
    const runRadius = radius - 14;
    const mx = center.x + Math.cos(mouseAngle) * runRadius - 14;
    const my = center.y + Math.sin(mouseAngle) * runRadius - 20;

    // Running legs animation synced to wheel speed
    const runFrame = Math.floor(t * 8 * Math.max(1, wheelState.speed * 8)) % 4;
    drawMouse(mx, my, cfg, 1, runFrame, 'walking');
  });

  // Metallic sheen on wheel (top highlight)
  ctx.strokeStyle = 'rgba(200,220,240,0.2)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius, -Math.PI * 0.7, -Math.PI * 0.3);
  ctx.stroke();
}

function updateExerciseWheel(dt) {
  // Find wheel in exercise room (room 3)
  const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel');
  if (!wheelPlaced) return;

  // Update fling cooldown
  if (wheelState.flingTimer > 0) wheelState.flingTimer -= dt;

  // Check which mice are on the wheel
  const onWheel = [];
  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    if (mouse.action === 'wheeling' && mouse.room === wheelPlaced.room) {
      onWheel.push(key);
    }
  });
  wheelState.miceOn = onWheel;

  // Update wheel speed based on mice running
  if (onWheel.length > 0) {
    const targetSpeed = onWheel.length === 1 ? 0.04 : 0.08; // faster with two mice
    wheelState.speed += (targetSpeed - wheelState.speed) * 0.02;
  } else {
    // Slow down gradually
    wheelState.speed *= 0.98;
    if (wheelState.speed < 0.001) wheelState.speed = 0;
  }

  wheelState.angle += wheelState.speed * dt * 0.06;

  // Two-mouse interaction: one gets flung off!
  if (onWheel.length === 2 && wheelState.flingTimer <= 0 && Math.random() < 0.0008 * dt) {
    const flingKey = Math.random() < 0.5 ? onWheel[0] : onWheel[1];
    const stayKey = flingKey === onWheel[0] ? onWheel[1] : onWheel[0];
    flingMouseOffWheel(flingKey, stayKey, wheelPlaced);
  }

  // Occasional wheel squeak sound
  if (onWheel.length > 0 && Math.random() < 0.001 * dt) {
    sfxWheelSpin();
  }
}

function flingMouseOffWheel(flingKey, stayKey, wheelPlaced) {
  const mouse = state.miceState[flingKey];
  const center = getWheelCenter(wheelPlaced);

  // Fling the mouse!
  mouse.action = 'flung';
  mouse.actionTimer = 2500;
  mouse.flingVX = (Math.random() < 0.5 ? -1 : 1) * (2 + Math.random() * 2);
  mouse.flingVY = -(3 + Math.random() * 2);
  mouse.flingX = center.x - 14;
  mouse.flingY = center.y + 10;
  mouse.flingBounced = false;

  wheelState.flingTimer = 12000; // cooldown before next fling
  wheelState.speed *= 1.5; // wheel speeds up from the fling

  sfxWheelFling();

  // Flung mouse reaction
  const flingQuotes = [
    'YEET üòµ‚Äçüí´', 'I\'m flying!! üí´', 'was not ready', 'AAAA', 
    'parkour??', 'didn\'t sign up for this', '10/10 landing', 'ow',
    'that was on purpose actually', 'wheeeee! ...ow'
  ];
  speechBubbles.push({
    x: mouse.flingX + 14, y: mouse.flingY - 10,
    text: flingQuotes[Math.floor(Math.random() * flingQuotes.length)],
    timer: 3000, maxTimer: 3000, mouseKey: flingKey
  });

  // Staying mouse reaction (delayed)
  setTimeout(() => {
    const stayQuotes = [
      'lmaooo üòÇ', 'skill issue', 'MY wheel now', 'byeee üëã',
      'should\'ve held on', 'couldn\'t be me', 'ratio + flung'
    ];
    speechBubbles.push({
      x: state.miceState[stayKey].x + 14, y: getMouseFloorY(state.miceState[stayKey]) - 10,
      text: stayQuotes[Math.floor(Math.random() * stayQuotes.length)],
      timer: 3000, maxTimer: 3000, mouseKey: stayKey
    });
  }, 800);

  // Floating stars around flung mouse
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      spawnFloatingEffect(
        mouse.flingX + 14 + (Math.random() - 0.5) * 30,
        mouse.flingY + (Math.random() - 0.5) * 20,
        ['‚≠ê', 'üí´', 'üòµ‚Äçüí´', '‚ú®', 'üí•'][i]
      );
    }, i * 100 + 200);
  }
}

function updateFlungMouse(mouse, dt) {
  if (mouse.action !== 'flung') return false;

  const gravity = 0.008 * dt;
  mouse.flingVY += gravity;
  mouse.flingX += mouse.flingVX * dt * 0.06;
  mouse.flingY += mouse.flingVY * dt * 0.06;

  // Bounce off floor (flung mice land on main floor)
  const floorY = getMouseFloorY({ room: mouse.room, level: 'main-floor' });
  if (mouse.flingY >= floorY && !mouse.flingBounced) {
    mouse.flingBounced = true;
    mouse.flingVY = -Math.abs(mouse.flingVY) * 0.4;
    mouse.flingVX *= 0.5;
    // Small bounce sound
    sfxSqueak();
  }

  // Settle on floor
  if (mouse.flingBounced && mouse.flingY >= floorY) {
    mouse.flingY = floorY;
    mouse.x = Math.max(15, Math.min(ROOM_W - 45, mouse.flingX));
    mouse.action = 'idle';
    mouse.level = 'main-floor';
    mouse.actionTimer = 3000 + Math.random() * 2000;
    mouse.dir = Math.random() < 0.5 ? 1 : -1;
    return false;
  }

  // Bounce off walls
  if (mouse.flingX < 15) { mouse.flingX = 15; mouse.flingVX = Math.abs(mouse.flingVX) * 0.5; }
  if (mouse.flingX > ROOM_W - 45) { mouse.flingX = ROOM_W - 45; mouse.flingVX = -Math.abs(mouse.flingVX) * 0.5; }

  return true; // still flying
}

function drawFlungMouse(mouse, cfg) {
  if (mouse.action !== 'flung') return;
  const t = Date.now() / 1000;

  // Tumbling rotation
  const tumble = t * 8;

  ctx.save();
  const cx = mouse.flingX + 14;
  const cy = mouse.flingY + 10;
  ctx.translate(cx, cy);
  ctx.rotate(Math.sin(tumble) * 0.5);
  ctx.translate(-cx, -cy);

  drawMouse(mouse.flingX, mouse.flingY, cfg, 1, 0, 'idle');

  // Dizzy stars orbiting
  if (mouse.flingBounced) {
    const starR = 12;
    for (let i = 0; i < 3; i++) {
      const sa = t * 4 + (i / 3) * Math.PI * 2;
      ctx.font = '8px serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚≠ê', cx + Math.cos(sa) * starR, cy - 12 + Math.sin(sa) * 4);
    }
    ctx.textAlign = 'left';
  }

  ctx.restore();
}

// ============================================================
// EXERCISE ROOM SETUP (auto-place wheel)
// ============================================================
function ensureExerciseRoomSetup() {
  // Auto-place the exercise wheel in the exercise room if not already placed
  const hasWheel = state.placedItems.some(p => p.itemId === 'exercise-wheel');
  if (!hasWheel) {
    if (!state.ownedItems.includes('exercise-wheel')) {
      state.ownedItems.push('exercise-wheel');
    }
    // Place wheel centered in exercise room (room 3)
    state.placedItems.push({
      itemId: 'exercise-wheel', room: 3,
      gridX: Math.floor(GRID_COLS / 2) - 1, gridY: GRID_ROWS - 3
    });
    saveGame();
  }
}

// ============================================================
// FURNITURE PLACEMENT & REMOVAL
// ============================================================
function startPlacement(itemId) {
  state.placementMode = itemId;
  state.removeMode = false;
  highlightTrayItem(itemId);
}

function cancelPlacement() {
  state.placementMode = null;
  state.removeMode = false;
  state.dragState = { active: false, itemId: null, screenX: 0, screenY: 0, fromPlaced: false, fromPlacedIdx: -1 };
  document.getElementById('trash-zone').classList.remove('visible', 'hover');
}

function toggleRemoveMode() {
  // No longer used as a separate mode ‚Äî kept as no-op for compatibility
}

function isPlacementValid(itemId, col, row, excludeIdx) {
  const item = FURNITURE.find(f => f.id === itemId);
  if (!item) return false;
  if (col < 0 || row < 0 || col + item.w > GRID_COLS || row + item.h > GRID_ROWS) return false;
  const overlaps = state.placedItems.some((p, idx) => {
    if (excludeIdx !== undefined && idx === excludeIdx) return false;
    if (p.room !== state.currentRoom) return false;
    const pi = FURNITURE.find(f => f.id === p.itemId);
    if (!pi) return false;
    return !(col + item.w <= p.gridX || p.gridX + pi.w <= col ||
             row + item.h <= p.gridY || p.gridY + pi.h <= row);
  });
  return !overlaps;
}

function handlePlacementClick(gx, gy) {
  const grid = gameToGrid(gx, gy);
  if (grid.col < 0 || grid.col >= GRID_COLS || grid.row < 0 || grid.row >= GRID_ROWS) return;

  if (state.removeMode) {
    const idx = state.placedItems.findIndex(p => {
      if (p.room !== state.currentRoom) return false;
      const it = FURNITURE.find(f => f.id === p.itemId);
      if (!it) return false;
      return grid.col >= p.gridX && grid.col < p.gridX + it.w &&
             grid.row >= p.gridY && grid.row < p.gridY + it.h;
    });
    if (idx >= 0) {
      const removed = state.placedItems[idx];
      const item = FURNITURE.find(f => f.id === removed.itemId);
      if (item?.exerciseRoom) {
        showToast("Can't remove the wheel! üé° The mice would riot.");
        return;
      }
      state.placedItems.splice(idx, 1);
      showToast(`Removed ${item?.name || 'item'} üóë`);
      saveGame();
    }
    return;
  }

  const item = FURNITURE.find(f => f.id === state.placementMode);
  if (!item) return;

  if (!isPlacementValid(item.id, grid.col, grid.row)) {
    showToast("Doesn't fit there! üê≠");
    return;
  }

  const placedEntry = {
    itemId: item.id, room: state.currentRoom,
    gridX: grid.col, gridY: grid.row
  };
  if (item.servings) placedEntry.servings = item.servings;
  state.placedItems.push(placedEntry);

  sfxPlace();
  showToast(`Placed ${item.icon} ${item.name}!`);
  cancelPlacement();
  addHappiness(3);
  saveGame();
  refreshShopFlyout();
  refreshItemTray();
  reactToNewFurniture(item);
}

function reactToNewFurniture(item) {
  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    if (mouse.room !== state.currentRoom) return;
    const placed = state.placedItems[state.placedItems.length - 1];
    const targetPos = gridToGame(placed.gridX, placed.gridY);
    mouse.action = 'walking';
    mouse.targetX = targetPos.x + (key === 'pip' ? -10 : 20);
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 5000;
    setTimeout(() => {
      if (mouse.room === state.currentRoom) {
        const curiosity = ['ooh what\'s this? üëÄ', 'new thing! üéâ', '*sniff sniff*',
          'is this for me?', 'fancy ‚ú®', 'immediately claims this'][Math.floor(Math.random() * 6)];
        speechBubbles.push({
          x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
          text: curiosity, timer: 2500, maxTimer: 2500, mouseKey: key
        });
      }
    }, 1500);
  });
}

// ============================================================
// SHOP FLYOUT PANEL
// ============================================================
let trayOpen = false;

function toggleTray() {
  trayOpen = !trayOpen;
  const tray = document.getElementById('item-tray');
  const btn = document.getElementById('tray-toggle');
  if (trayOpen) {
    refreshItemTray();
    tray.classList.add('open');
    btn.classList.add('open');
    btn.querySelector('span').style.transform = 'rotate(90deg)';
    // On mobile, position toggle above the variable-height tray
    requestAnimationFrame(() => {
      btn.style.bottom = tray.offsetHeight + 'px';
    });
  } else {
    if (!state.shopOpen) tray.classList.remove('open');
    btn.classList.remove('open');
    btn.querySelector('span').style.transform = 'rotate(-90deg)';
    btn.style.bottom = '';
    cancelPlacement();
  }
}

document.getElementById('tray-toggle').addEventListener('click', toggleTray);

function syncTrayToggle() {
  const btn = document.getElementById('tray-toggle');
  const tray = document.getElementById('item-tray');
  const isOpen = tray.classList.contains('open');
  if (isOpen) {
    btn.classList.add('open');
    btn.querySelector('span').style.transform = 'rotate(90deg)';
    requestAnimationFrame(() => { btn.style.bottom = tray.offsetHeight + 'px'; });
  } else {
    btn.classList.remove('open');
    btn.querySelector('span').style.transform = 'rotate(-90deg)';
    btn.style.bottom = '';
  }
}

function showBackdrop() { document.getElementById('flyout-backdrop').classList.add('visible'); }
function hideBackdrop() { document.getElementById('flyout-backdrop').classList.remove('visible'); }
// Light-dismiss: tapping backdrop closes any open flyout
document.getElementById('flyout-backdrop').addEventListener('click', () => {
  if (state.shopOpen) closeShopFlyout();
  if (gamesOpen) closeGamesFlyout();
});

function toggleShopFlyout() {
  state.shopOpen = !state.shopOpen;
  const flyout = document.getElementById('shop-flyout');
  const tray = document.getElementById('item-tray');
  const isMobile = window.innerWidth <= 480;
  if (state.shopOpen) {
    if (gamesOpen) closeGamesFlyout();
    refreshShopFlyout();
    refreshItemTray();
    flyout.classList.add('open');
    // On mobile, shop covers everything ‚Äî don't force tray open
    if (!isMobile) {
      tray.classList.add('open');
      syncTrayToggle();
    }
    showBackdrop();
  } else {
    flyout.classList.remove('open');
    if (!trayOpen) tray.classList.remove('open');
    cancelPlacement();
    syncTrayToggle();
    hideBackdrop();
  }
}

function closeShopFlyout() {
  state.shopOpen = false;
  document.getElementById('shop-flyout').classList.remove('open');
  if (!trayOpen) document.getElementById('item-tray').classList.remove('open');
  cancelPlacement();
  syncTrayToggle();
  if (!gamesOpen) hideBackdrop();
}

function refreshShopFlyout() {
  const owned = new Set(state.ownedItems);
  const container = document.getElementById('flyout-items');
  document.getElementById('flyout-coin-display').textContent = state.coins;
  let html = '';
  FURNITURE.forEach(item => {
    if (item.birthday && !state.birthdayEventSeen) return;
    if (item.exerciseRoom) return;
    const isOwned = owned.has(item.id);
    const isConsumable = !!item.servings;
    const canAfford = state.coins >= item.price;
    const label = isConsumable
      ? (canAfford ? 'üßÄ ' + item.price : 'üßÄ ' + item.price)
      : (isOwned ? '‚úÖ Owned' : (item.price === 0 ? 'üéÅ Free!' : 'üßÄ ' + item.price));
    const cls = isConsumable
      ? (!canAfford ? 'cant-afford' : '')
      : (isOwned ? 'owned' : (!canAfford ? 'cant-afford' : ''));
    html += `<div class="flyout-item ${cls}" data-item-id="${item.id}">
      <div class="fi-icon">${item.icon}</div>
      <div class="fi-name">${item.name}${isConsumable ? ' üîÑ' : ''}</div>
      <div class="fi-price">${label}</div>
    </div>`;
  });
  container.innerHTML = html;
  // Attach click handlers
  container.querySelectorAll('.flyout-item').forEach(el => {
    el.addEventListener('click', () => {
      const id = el.dataset.itemId;
      const item = FURNITURE.find(f => f.id === id);
      const isOwned = state.ownedItems.includes(id);
      const isConsumable = item && !!item.servings;
      if (isConsumable) {
        // Food items: always buy a fresh one (re-purchasable)
        if (item && state.coins >= item.price) {
          buyItem(id);
          startPlacement(id);
        }
      } else if (isOwned) {
        startPlacement(id);
        showToast('Drag from the tray below to place! üëá');
      } else {
        if (item && state.coins >= item.price) {
          buyItem(id);
        }
      }
    });
  });
  // Update loot info
  const lootInfo = document.getElementById('flyout-loot-info');
  lootInfo.textContent = state.lootCrumbsUsed > 0
    ? `Opened ${state.lootCrumbsUsed} times. Totally not addictive.`
    : 'Ironic gacha. Always free. No regrets.';
}

function refreshItemTray() {
  const tray = document.getElementById('item-tray');
  const owned = new Set(state.ownedItems);
  let html = '';
  FURNITURE.forEach(item => {
    if (!owned.has(item.id)) return;
    if (item.exerciseRoom) return;
    if (item.birthday && !state.birthdayEventSeen) return;
    const isActive = state.placementMode === item.id;
    html += `<div class="tray-item ${isActive ? 'active' : ''}" data-item-id="${item.id}">
      <div class="ti-icon">${item.icon}</div>
      <div class="ti-name">${item.name}</div>
    </div>`;
  });
  tray.innerHTML = html;
  // Re-sync chevron position after tray content changes height
  if (tray.classList.contains('open')) {
    requestAnimationFrame(() => {
      const btn = document.getElementById('tray-toggle');
      btn.style.bottom = tray.offsetHeight + 'px';
    });
  }
}

function highlightTrayItem(itemId) {
  document.querySelectorAll('.tray-item').forEach(el => {
    el.classList.toggle('active', el.dataset.itemId === itemId);
  });
  // Scroll tray item into view
  const active = document.querySelector(`.tray-item[data-item-id="${itemId}"]`);
  if (active) active.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
}

// ============================================================
// DRAG & DROP PLACEMENT SYSTEM
// ============================================================
function startDrag(itemId, sx, sy, fromPlaced, fromPlacedIdx) {
  state.dragState = {
    active: true, itemId, screenX: sx, screenY: sy,
    fromPlaced: !!fromPlaced, fromPlacedIdx: fromPlacedIdx ?? -1
  };
  state.placementMode = itemId;
  document.getElementById('trash-zone').classList.add('visible');
}

function updateDrag(sx, sy) {
  if (!state.dragState.active) return;
  state.dragState.screenX = sx;
  state.dragState.screenY = sy;
  // Check trash zone hover
  const trashEl = document.getElementById('trash-zone');
  const trashRect = trashEl.getBoundingClientRect();
  const inTrash = sx >= trashRect.left && sx <= trashRect.right &&
                  sy >= trashRect.top && sy <= trashRect.bottom;
  trashEl.classList.toggle('hover', inTrash);
}

function endDrag(sx, sy) {
  if (!state.dragState.active) return;
  const ds = state.dragState;

  // Check if dropped on trash zone
  const trashEl = document.getElementById('trash-zone');
  const trashRect = trashEl.getBoundingClientRect();
  const inTrash = sx >= trashRect.left && sx <= trashRect.right &&
                  sy >= trashRect.top && sy <= trashRect.bottom;

  if (inTrash && ds.fromPlaced && ds.fromPlacedIdx >= 0) {
    const removed = state.placedItems[ds.fromPlacedIdx];
    const item = FURNITURE.find(f => f.id === removed?.itemId);
    if (item?.exerciseRoom) {
      showToast("Can't remove the wheel! üé° The mice would riot.");
    } else if (removed) {
      state.placedItems.splice(ds.fromPlacedIdx, 1);
      showToast(`Removed ${item?.name || 'item'} üóë`);
      saveGame();
      refreshShopFlyout();
      refreshItemTray();
    }
    cancelPlacement();
    return;
  }

  // Try to place on canvas
  const pos = screenToGame(sx, sy);
  const item = FURNITURE.find(f => f.id === ds.itemId);
  if (!item) { cancelPlacement(); return; }
  // Use same centering as ghost preview
  const centerOffX = (item.w * GRID_SIZE) / 2;
  const centerOffY = (item.h * GRID_SIZE) / 2;
  const grid = gameToGrid(pos.x - centerOffX + SNAP_SIZE / 2, pos.y - centerOffY + SNAP_SIZE / 2);

  const excludeIdx = ds.fromPlaced ? ds.fromPlacedIdx : undefined;
  if (isPlacementValid(ds.itemId, grid.col, grid.row, excludeIdx)) {
    if (ds.fromPlaced && ds.fromPlacedIdx >= 0) {
      // Repositioning ‚Äî update existing entry
      state.placedItems[ds.fromPlacedIdx].gridX = grid.col;
      state.placedItems[ds.fromPlacedIdx].gridY = grid.row;
      sfxPlace();
      showToast(`Moved ${item.icon} ${item.name}!`);
    } else {
      // New placement
      const newEntry = {
        itemId: item.id, room: state.currentRoom,
        gridX: grid.col, gridY: grid.row
      };
      if (item.servings) newEntry.servings = item.servings;
      state.placedItems.push(newEntry);
      sfxPlace();
      showToast(`Placed ${item.icon} ${item.name}!`);
      addHappiness(3);
      reactToNewFurniture(item);
    }
    saveGame();
    refreshShopFlyout();
    refreshItemTray();
  } else {
    if (ds.fromPlaced) {
      // Repositioning failed ‚Äî item stays where it was (already still in array)
      showToast("Can't place there! üê≠");
    }
    // New placement from tray ‚Äî just cancel, item returns to tray
  }
  cancelPlacement();
}

function findPlacedItemAt(gx, gy) {
  const grid = gameToGrid(gx, gy);
  const idx = state.placedItems.findIndex(p => {
    if (p.room !== state.currentRoom) return false;
    const it = FURNITURE.find(f => f.id === p.itemId);
    if (!it) return false;
    return grid.col >= p.gridX && grid.col < p.gridX + it.w &&
           grid.row >= p.gridY && grid.row < p.gridY + it.h;
  });
  return idx;
}

// Wire up flyout buttons
document.getElementById('flyout-close-btn').addEventListener('click', closeShopFlyout);
document.getElementById('games-flyout-close').addEventListener('click', closeGamesFlyout);
document.getElementById('flyout-loot-btn').addEventListener('click', () => {
  lootCrumbs();
});

// Wire up tray drag events (delegated)
(function setupTrayDrag() {
  const tray = document.getElementById('item-tray');

  tray.addEventListener('mousedown', e => {
    const tile = e.target.closest('.tray-item');
    if (!tile) return;
    e.preventDefault();
    startDrag(tile.dataset.itemId, e.clientX, e.clientY, false, -1);
  });
  tray.addEventListener('touchstart', e => {
    const tile = e.target.closest('.tray-item');
    if (!tile) return;
    e.preventDefault();
    const t = e.touches[0];
    startDrag(tile.dataset.itemId, t.clientX, t.clientY, false, -1);
  }, { passive: false });
})();

// Global mouse/touch move & up for drag
document.addEventListener('mousemove', e => {
  if (state.dragState.active) {
    e.preventDefault();
    updateDrag(e.clientX, e.clientY);
  }
});
document.addEventListener('touchmove', e => {
  if (state.dragState.active) {
    e.preventDefault();
    updateDrag(e.touches[0].clientX, e.touches[0].clientY);
  }
}, { passive: false });
document.addEventListener('mouseup', e => {
  if (state.dragState.active) {
    endDrag(e.clientX, e.clientY);
  }
});
document.addEventListener('touchend', e => {
  if (state.dragState.active) {
    const t = e.changedTouches[0];
    endDrag(t.clientX, t.clientY);
  }
});

function openShop() {
  toggleShopFlyout();
}

function buyItem(itemId) {
  const item = FURNITURE.find(f => f.id === itemId);
  if (!item || state.coins < item.price) return;
  state.coins -= item.price;
  state.ownedItems.push(itemId);
  sfxBuy();
  updateCoinDisplay();
  saveGame();
  showToast(`Bought ${item.icon} ${item.name}! ${item.desc}`);
  refreshShopFlyout();
  refreshItemTray();
}

function lootCrumbs() {
  const unowned = FURNITURE.filter(f => !state.ownedItems.includes(f.id) && !f.birthday && !f.exerciseRoom);
  if (unowned.length === 0) {
    showToast('You own everything! Go touch grass. üå±');
    return;
  }
  const item = unowned[Math.floor(Math.random() * unowned.length)];
  state.ownedItems.push(item.id);
  state.lootCrumbsUsed++;
  sfxBuy();
  saveGame();
  showToast(`üéÅ Loot Crumb opened! You got: ${item.icon} ${item.name}!`);
  refreshShopFlyout();
  refreshItemTray();
}

// Wire up HUD buttons
document.getElementById('btn-shop').addEventListener('click', openShop);
document.getElementById('btn-games').addEventListener('click', openMinigames);
document.getElementById('btn-letter').addEventListener('click', openLetter);

// Exit button ‚Äî return to title screen
function exitToTitle() {
  saveGame();
  if (musicPlaying) stopMusic();
  state.gameStarted = false;
  document.getElementById('hud').style.display = 'none';
  document.getElementById('tray-toggle').style.display = 'none';
  document.getElementById('title-screen').style.display = 'flex';
  if (state.shopOpen) closeShopFlyout();
  document.getElementById('games-flyout').classList.remove('open');
  hideBackdrop();
}
document.getElementById('btn-exit').addEventListener('click', exitToTitle);

// ============================================================
// MINI-GAME MENU (flyout)
// ============================================================
let gamesOpen = false;

function toggleGamesFlyout() {
  gamesOpen = !gamesOpen;
  const flyout = document.getElementById('games-flyout');
  if (gamesOpen) {
    if (state.shopOpen) closeShopFlyout();
    flyout.classList.add('open');
    showBackdrop();
  } else {
    flyout.classList.remove('open');
    hideBackdrop();
  }
}

function closeGamesFlyout() {
  gamesOpen = false;
  document.getElementById('games-flyout').classList.remove('open');
  if (!state.shopOpen) hideBackdrop();
}

function openMinigames() {
  toggleGamesFlyout();
}

// ============================================================
// CHEESE CHASE MINI-GAME
// ============================================================
let cheeseChaseActive = false;
let cc = {};
let ccInputY = null;

function startCheeseChase() {
  closeModal();
  closeGamesFlyout();
  cheeseChaseActive = true;
  ccInputY = null;
  stopMusic();
  startChaseMusic();
  cc = {
    mouseY: GAME_H / 2,
    score: 0,
    obstacles: [],
    cheeses: [],
    spawnTimer: 0,
    speed: 1.8,
    distance: 0,
    gameOver: false,
    bgStars: []
  };
  // Background decor
  for (let i = 0; i < 25; i++) {
    cc.bgStars.push({ x: Math.random() * GAME_W, y: Math.random() * GAME_H, s: 1 + Math.random() });
  }
}

function updateCheeseChase(dt) {
  if (!cheeseChaseActive || cc.gameOver) return;

  cc.distance += cc.speed;
  cc.speed = 1.8 + cc.distance / 4000;
  gameMusicIntensity = Math.min(1, cc.distance / 8000);
  cc.spawnTimer -= dt;

  // Spawn obstacles and cheese
  if (cc.spawnTimer <= 0) {
    cc.spawnTimer = 500 + Math.random() * 500 - Math.min(cc.distance / 50, 200);
    cc.spawnTimer = Math.max(cc.spawnTimer, 200);

    if (Math.random() < 0.45) {
      // Cheese collectible
      cc.cheeses.push({
        x: GAME_W + 10,
        y: 30 + Math.random() * (GAME_H - 60),
        size: 14
      });
    } else {
      // Obstacle (mousetrap or cat)
      const isCat = Math.random() < 0.3;
      const h = isCat ? 35 + Math.random() * 25 : 25 + Math.random() * 50;
      cc.obstacles.push({
        x: GAME_W + 10,
        y: Math.random() < 0.5 ? 0 : GAME_H - h,
        w: isCat ? 28 : 18,
        h: h,
        type: isCat ? 'cat' : 'trap'
      });
    }
  }

  // Move everything left
  cc.obstacles.forEach(o => o.x -= cc.speed);
  cc.cheeses.forEach(c => c.x -= cc.speed);
  cc.obstacles = cc.obstacles.filter(o => o.x > -40);
  cc.cheeses = cc.cheeses.filter(c => c.x > -20);

  // Mouse input following
  if (ccInputY !== null) {
    cc.mouseY += (ccInputY - cc.mouseY) * 0.12;
  }
  cc.mouseY = Math.max(12, Math.min(GAME_H - 12, cc.mouseY));

  // Collision detection
  const mBox = { x: 35, y: cc.mouseY - 9, w: 24, h: 18 };

  // Collect cheese
  cc.cheeses = cc.cheeses.filter(c => {
    const cBox = { x: c.x - 7, y: c.y - 7, w: 14, h: 14 };
    if (boxOverlap(mBox, cBox)) {
      cc.score++;
      sfxCheeseCollect();
      // Sparkle effect
      spawnFloatingEffect(c.x, c.y, '‚ú®');
      return false;
    }
    return true;
  });

  // Hit obstacle
  for (const o of cc.obstacles) {
    if (boxOverlap(mBox, o)) {
      cc.gameOver = true;
      sfxCrash();
      break;
    }
  }
}

function boxOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

function drawCheeseChase() {
  if (!cheeseChaseActive) return;
  const t = Date.now() / 1000;

  // Warm dark background
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // Scrolling background dots
  cc.bgStars.forEach(s => {
    const sx = ((s.x - cc.distance * 0.2) % GAME_W + GAME_W) % GAME_W;
    ctx.fillStyle = 'rgba(245,214,138,0.15)';
    ctx.fillRect(sx, s.y, s.s, s.s);
  });

  // Floor and ceiling lines
  ctx.fillStyle = '#3d2b1a';
  ctx.fillRect(0, 0, GAME_W, 5);
  ctx.fillRect(0, GAME_H - 5, GAME_W, 5);

  // Obstacles
  cc.obstacles.forEach(o => {
    if (o.type === 'cat') {
      // Cat silhouette
      ctx.fillStyle = '#5a3020';
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 4);
      ctx.fill();
      // Cat ears
      if (o.y === 0) {
        ctx.fillRect(o.x + 4, o.y + o.h - 2, 6, 8);
        ctx.fillRect(o.x + o.w - 10, o.y + o.h - 2, 6, 8);
      } else {
        ctx.fillRect(o.x + 4, o.y - 6, 6, 8);
        ctx.fillRect(o.x + o.w - 10, o.y - 6, 6, 8);
      }
      // Eyes
      const eyeY = o.y === 0 ? o.y + o.h - 12 : o.y + 10;
      ctx.fillStyle = '#44ee44';
      ctx.beginPath();
      ctx.ellipse(o.x + 8, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(o.x + o.w - 8, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      // Slit pupils
      ctx.fillStyle = '#1a0f05';
      ctx.fillRect(o.x + 7, eyeY - 2, 1.5, 4);
      ctx.fillRect(o.x + o.w - 9, eyeY - 2, 1.5, 4);
    } else {
      // Mousetrap
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(o.x, o.y, o.w, o.h);
      ctx.fillStyle = '#a08030';
      ctx.fillRect(o.x + 2, o.y + 2, o.w - 4, 4);
      // Spring
      ctx.strokeStyle = '#c0a050';
      ctx.lineWidth = 1.5;
      const springBase = o.y === 0 ? o.y + o.h : o.y;
      ctx.beginPath();
      for (let i = 0; i < o.h; i += 6) {
        const sx = o.x + o.w / 2 + (i % 12 === 0 ? -4 : 4);
        ctx.lineTo(sx, springBase + (o.y === 0 ? -i : i));
      }
      ctx.stroke();
      // Danger icon
      ctx.font = '10px serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚ö†Ô∏è', o.x + o.w / 2, o.y + o.h / 2 + 4);
      ctx.textAlign = 'left';
    }
  });

  // Cheese collectibles
  cc.cheeses.forEach(c => {
    // Glow
    ctx.fillStyle = 'rgba(255,215,0,0.15)';
    ctx.beginPath();
    ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
    ctx.fill();
    // Emoji
    ctx.font = '14px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üßÄ', c.x, c.y);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
  });

  // Player mouse
  const mFrame = Math.floor(cc.distance / 15) % 4;
  drawMouse(35, cc.mouseY - 10, CONFIG.mice.pip, 1, mFrame, 'walking');

  // Floating effects (sparkles on cheese collect)
  drawFloatingEffects();

  // HUD
  ctx.fillStyle = 'rgba(26,15,5,0.7)';
  ctx.fillRect(0, 0, GAME_W, 28);
  ctx.fillStyle = '#f5d68a';
  ctx.font = '14px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`üßÄ ${cc.score}`, 10, 19);
  ctx.textAlign = 'right';
  ctx.fillText(`${Math.floor(cc.distance / 10)}m`, GAME_W - 10, 19);
  // Speed indicator
  ctx.fillStyle = '#a89070';
  ctx.font = '10px monospace';
  ctx.fillText(`‚ö°${cc.speed.toFixed(1)}x`, GAME_W - 10, 12);
  ctx.textAlign = 'left';

  // Game over overlay
  if (cc.gameOver) {
    ctx.fillStyle = 'rgba(26,15,5,0.8)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);

    ctx.fillStyle = '#f5d68a';
    ctx.font = '28px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('ü™§ CAUGHT!', GAME_W / 2, GAME_H / 2 - 35);

    ctx.font = '14px monospace';
    ctx.fillStyle = '#e8d5b5';
    ctx.fillText(`Cheese: üßÄ ${cc.score}  |  Distance: ${Math.floor(cc.distance / 10)}m`, GAME_W / 2, GAME_H / 2);

    const earned = cc.score * 2;
    ctx.fillStyle = '#f5d68a';
    ctx.font = '16px monospace';
    ctx.fillText(`Earned: üßÄ ${earned} coins!`, GAME_W / 2, GAME_H / 2 + 25);

    ctx.fillStyle = '#a89070';
    ctx.font = '12px monospace';
    ctx.fillText('tap / click to continue', GAME_W / 2, GAME_H / 2 + 55);
    ctx.textAlign = 'left';
  }
}

function endCheeseChase() {
  stopGameMusic();
  const earned = cc.score * 2;
  state.coins += earned;
  state.totalCoinsEarned += earned;
  addHappiness(5);
  updateCoinDisplay();
  saveGame();
  cheeseChaseActive = false;
  startMusic();
  sfxCoinCollect();
  spawnCoinEffect(earned, GAME_W / 2, GAME_H / 2 - 20);
  showToast(`Cheese Chase: earned üßÄ ${earned} coins!`);
}

// ============================================================
// DOOMSCROLL MINI-GAME
// ============================================================
const DOOMSCROLL_POSTS = [
  // Good posts ‚Äî like these!
  { text: 'mice are literally the best pets no cap üê≠', good: true, user: '@mousewhisperer' },
  { text: 'just found the BIGGEST cheese wheel at Costco', good: true, user: '@cheeseenthusiast' },
  { text: 'my mouse learned to high five today ü•∫', good: true, user: '@tinypaws' },
  { text: 'cheese board appreciation post üßÄ‚ú®', good: true, user: '@cheeseboard_daily' },
  { text: 'reminder: you are loved and valid üíõ', good: true, user: '@wholesomemouse' },
  { text: `${CONFIG.mice.pip.name} and ${CONFIG.mice.chai.name} fan account üê≠üê≠`, good: true, user: '@mouse_stan' },
  { text: 'POV: the mouse found the cheese stash', good: true, user: '@mousemoments' },
  { text: 'tiny mouse in a tiny hat. that\'s it. that\'s the post.', good: true, user: '@tinyhat' },
  { text: 'cozy mouse house tour üè†üê≠ (it\'s perfect)', good: true, user: '@cozymouse' },
  { text: 'petition to make mice the national animal', good: true, user: '@mouseactivist' },
  { text: 'just watched a mouse do yoga and now I believe in god', good: true, user: '@spiritual_mouse' },
  { text: 'normalize napping 14 hours a day (I am a mouse)', good: true, user: '@sleepymouse' },
  { text: 'cheese is just milk that believed in itself üßÄ', good: true, user: '@deepcheese' },
  // Bad posts ‚Äî skip these!
  { text: 'actually, mice are mid', good: false, user: '@wrongopinions' },
  { text: 'hot take: cheese is overrated', good: false, user: '@controversialcarl' },
  { text: 'reply guys assemble ü§ì‚òùÔ∏è', good: false, user: '@replyguy47' },
  { text: 'imagine not having a sigma grindset in 2026', good: false, user: '@sigmagrinder' },
  { text: 'I mass-followed 10,000 accounts for clout', good: false, user: '@followback' },
  { text: 'this u? ü§®üì∏', good: false, user: '@exposed' },
  { text: 'I did my own research (watched 2 youtube videos)', good: false, user: '@truthseeker99' },
  { text: 'brand account trying to be relatable: slay bestie', good: false, user: '@megacorp_official' },
  { text: 'ratio + L + no cheese', good: false, user: '@ratioenjoyer' },
  { text: 'who asked? (I am very lonely)', good: false, user: '@whoasked' },
  { text: 'wake up at 4am or you\'re a failure (I am unwell)', good: false, user: '@hustleculture' },
  { text: 'my toxic trait is thinking I\'m the main character', good: false, user: '@toxicmain' },
  { text: 'vibe check: you failed. rip bozo.', good: false, user: '@vibechecker' },
];

let dsActive = false;
let ds = {};

function startDoomscroll() {
  closeModal();
  closeGamesFlyout();
  dsActive = true;
  stopMusic();
  startLofiMusic();
  const shuffled = [...DOOMSCROLL_POSTS].sort(() => Math.random() - 0.5);
  ds = {
    posts: shuffled.slice(0, 10),
    current: 0,
    score: 0,
    strikes: 0,
    maxStrikes: 3,
    finished: false,
    feedback: null
  };
  renderDoomscroll();
}

function renderDoomscroll() {
  if (!dsActive) return;
  const container = document.getElementById('modal-container');

  if (ds.finished) {
    const earned = ds.score * 3;
    state.coins += earned;
    state.totalCoinsEarned += earned;
    addHappiness(4);
    updateCoinDisplay();
    spawnCoinEffect(earned);
    sfxCoinCollect();
    saveGame();

    container.innerHTML = `<div class="modal-overlay">
      <div class="modal-content" style="min-width:300px;max-width:420px;">
        <h2>üì± Doomscroll Complete!</h2>
        <p style="text-align:center;font-size:15px;color:#f5d68a;margin:14px 0;">
          Good posts liked: ${ds.score} ‚úÖ<br>
          Cringe posts liked: ${ds.strikes} üò¨<br><br>
          <span style="font-size:18px;">Earned: üßÄ ${earned} cheese coins!</span>
        </p>
        <p style="text-align:center;color:#a89070;font-size:11px;">
          ${ds.strikes === 0 ? 'Perfect feed! Your algorithm is immaculate.' :
            ds.strikes >= 3 ? 'Touch grass immediately. üå±' :
            'Not bad, but maybe log off for a bit.'}
        </p>
        <button class="close-btn" onclick="dsActive=false;stopGameMusic();startMusic();closeModal()">Nice</button>
      </div>
    </div>`;
    return;
  }

  const post = ds.posts[ds.current];
  const strikeDisplay = '‚ùå'.repeat(ds.strikes) + '‚¨ú'.repeat(ds.maxStrikes - ds.strikes);

  container.innerHTML = `<div class="modal-overlay">
    <div class="modal-content" style="min-width:300px;max-width:440px;">
      <h2>üì± Doomscroll</h2>
      <p style="text-align:center;color:#a89070;font-size:11px;margin-bottom:6px;">
        Post ${ds.current + 1} of ${ds.posts.length} &nbsp;|&nbsp; üßÄ ${ds.score * 3} earned &nbsp;|&nbsp; ${strikeDisplay}
      </p>
      ${ds.feedback ? `<p style="text-align:center;font-size:13px;margin:6px 0;color:${ds.feedback.color};">${ds.feedback.text}</p>` : ''}
      <div class="doomscroll-post" style="margin:14px 0;">
        <div class="post-user">${post.user}</div>
        <div class="post-text" style="font-size:14px;margin-top:6px;">${post.text}</div>
      </div>
      <div style="display:flex;gap:10px;justify-content:center;margin-top:10px;">
        <button class="minigame-btn" onclick="doomscrollAction(true)" style="width:42%;">
          ‚ù§Ô∏è Like
        </button>
        <button class="minigame-btn" onclick="doomscrollAction(false)" style="width:42%;">
          ‚è≠ Skip
        </button>
      </div>
      <p style="text-align:center;color:#6b5030;font-size:10px;margin-top:8px;">
        Like the good posts. Skip the cringe. 3 strikes = game over.
      </p>
    </div>
  </div>`;
}

function doomscrollAction(liked) {
  const post = ds.posts[ds.current];

  if (liked && post.good) {
    ds.score++;
    ds.feedback = { text: '‚úÖ Based! +3 üßÄ', color: '#7bc67e' };
    sfxGoodLike();
  } else if (liked && !post.good) {
    ds.strikes++;
    ds.feedback = { text: 'üò¨ Yikes, you liked cringe!', color: '#e06050' };
    sfxBadLike();
  } else if (!liked && post.good) {
    ds.feedback = { text: 'üò¢ You skipped a good one!', color: '#e8a040' };
    sfxUIClick();
  } else {
    ds.feedback = { text: 'üëç Good skip, that was cringe', color: '#7bc67e' };
    sfxGoodLike();
  }

  ds.current++;
  gameMusicIntensity = Math.min(1, ds.strikes / ds.maxStrikes);
  if (ds.current >= ds.posts.length || ds.strikes >= ds.maxStrikes) {
    ds.finished = true;
    stopGameMusic();
    startMusic();
  }
  renderDoomscroll();
}

// ============================================================
// MOUSE MAZE MINI-GAME
// ============================================================
let mouseMazeActive = false;
let mz = {};

function generateMaze(cols, rows) {
  // Recursive backtracker algorithm
  const grid = [];
  for (let r = 0; r < rows; r++) {
    grid[r] = [];
    for (let c = 0; c < cols; c++) {
      grid[r][c] = { top: true, right: true, bottom: true, left: true, visited: false };
    }
  }
  const stack = [];
  let cur = { r: 0, c: 0 };
  grid[0][0].visited = true;
  const dirs = [
    { dr: -1, dc: 0, wall: 'top', opp: 'bottom' },
    { dr: 1, dc: 0, wall: 'bottom', opp: 'top' },
    { dr: 0, dc: -1, wall: 'left', opp: 'right' },
    { dr: 0, dc: 1, wall: 'right', opp: 'left' }
  ];
  function neighbors(r, c) {
    return dirs.filter(d => {
      const nr = r + d.dr, nc = c + d.dc;
      return nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].visited;
    });
  }
  let totalVisited = 1;
  const totalCells = rows * cols;
  while (totalVisited < totalCells) {
    const nb = neighbors(cur.r, cur.c);
    if (nb.length > 0) {
      const pick = nb[Math.floor(Math.random() * nb.length)];
      stack.push(cur);
      grid[cur.r][cur.c][pick.wall] = false;
      cur = { r: cur.r + pick.dr, c: cur.c + pick.dc };
      grid[cur.r][cur.c][pick.opp] = false;
      grid[cur.r][cur.c].visited = true;
      totalVisited++;
    } else {
      cur = stack.pop();
    }
  }
  return grid;
}

function startMouseMaze() {
  closeModal();
  closeGamesFlyout();
  mouseMazeActive = true;
  stopMusic();
  startMazeMusic();
  mz = {
    level: 1,
    totalScore: 0,
    totalCheese: 0
  };
  initMazeLevel(mz.level);
}

function initMazeLevel(level) {
  gameMusicIntensity = (level - 1) / 2; // 0, 0.5, 1.0 for levels 1-3
  const cols = 6 + level * 2;  // 8, 10, 12
  const rows = 5 + level;      // 6, 7, 8
  const grid = generateMaze(cols, rows);
  const cellW = Math.floor((GAME_W - 20) / cols);
  const cellH = Math.floor((GAME_H - 50) / rows);
  const cellSize = Math.min(cellW, cellH, 36);
  const mazeW = cols * cellSize;
  const mazeH = rows * cellSize;
  const ox = Math.floor((GAME_W - mazeW) / 2);
  const oy = Math.floor((GAME_H - 30 - mazeH) / 2) + 28;

  // Place cheese in random dead-end or interior cells
  const cheeses = [];
  const numCheese = 3 + level * 2;
  const candidates = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (r === 0 && c === 0) continue;
      if (r === rows - 1 && c === cols - 1) continue;
      candidates.push({ r, c });
    }
  }
  candidates.sort(() => Math.random() - 0.5);
  for (let i = 0; i < Math.min(numCheese, candidates.length); i++) {
    cheeses.push({ r: candidates[i].r, c: candidates[i].c, collected: false });
  }

  Object.assign(mz, {
    grid, cols, rows, cellSize, ox, oy,
    playerR: 0, playerC: 0,
    exitR: rows - 1, exitC: cols - 1,
    cheeses,
    moves: 0,
    startTime: Date.now(),
    elapsed: 0,
    levelComplete: false,
    gameOver: false,
    animX: 0, animY: 0, // smooth animation offset
    moveQueue: [],
    inputCooldown: 0
  });
  mz.animX = 0;
  mz.animY = 0;
}

function updateMouseMaze(dt) {
  if (!mouseMazeActive || mz.gameOver || mz.levelComplete) return;
  mz.elapsed = Date.now() - mz.startTime;

  // Smooth animation toward current cell
  mz.animX += (0 - mz.animX) * 0.2;
  mz.animY += (0 - mz.animY) * 0.2;

  // Process move queue
  if (mz.inputCooldown > 0) mz.inputCooldown -= dt;
  if (mz.moveQueue.length > 0 && mz.inputCooldown <= 0) {
    const dir = mz.moveQueue.shift();
    tryMazeMove(dir);
    mz.inputCooldown = 80;
  }
}

function tryMazeMove(dir) {
  if (mz.levelComplete || mz.gameOver) return;
  const cell = mz.grid[mz.playerR][mz.playerC];
  let dr = 0, dc = 0;
  if (dir === 'up' && !cell.top) dr = -1;
  else if (dir === 'down' && !cell.bottom) dr = 1;
  else if (dir === 'left' && !cell.left) dc = -1;
  else if (dir === 'right' && !cell.right) dc = 1;
  else return;

  mz.animX = -dc * mz.cellSize;
  mz.animY = -dr * mz.cellSize;
  mz.playerR += dr;
  mz.playerC += dc;
  mz.moves++;

  // Check cheese collection
  mz.cheeses.forEach(ch => {
    if (!ch.collected && ch.r === mz.playerR && ch.c === mz.playerC) {
      ch.collected = true;
      mz.totalCheese++;
      sfxCheeseCollect();
      const px = mz.ox + mz.playerC * mz.cellSize + mz.cellSize / 2;
      const py = mz.oy + mz.playerR * mz.cellSize + mz.cellSize / 2;
      spawnFloatingEffect(px, py, '‚ú®');
    }
  });

  // Check exit
  if (mz.playerR === mz.exitR && mz.playerC === mz.exitC) {
    mz.levelComplete = true;
    const timeBonus = Math.max(0, 30 - Math.floor(mz.elapsed / 1000));
    mz.totalScore += mz.cheeses.filter(c => c.collected).length * 3 + timeBonus;
    sfxGoalComplete();
  }
}

function drawMouseMaze() {
  if (!mouseMazeActive) return;
  const t = Date.now() / 1000;

  // Background
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // HUD bar
  ctx.fillStyle = 'rgba(26,15,5,0.85)';
  ctx.fillRect(0, 0, GAME_W, 26);
  ctx.fillStyle = '#f5d68a';
  ctx.font = '12px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`üßÄ ${mz.totalCheese}`, 10, 17);
  ctx.textAlign = 'center';
  ctx.fillText(`Level ${mz.level}/3`, GAME_W / 2, 17);
  ctx.textAlign = 'right';
  const secs = Math.floor((mz.elapsed || 0) / 1000);
  ctx.fillText(`‚è± ${secs}s  |  ${mz.moves} moves`, GAME_W - 10, 17);
  ctx.textAlign = 'left';

  const { grid, cols, rows, cellSize, ox, oy } = mz;

  // Maze floor
  ctx.fillStyle = '#2b1d0e';
  ctx.fillRect(ox - 2, oy - 2, cols * cellSize + 4, rows * cellSize + 4);

  // Draw cells
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cx = ox + c * cellSize;
      const cy = oy + r * cellSize;
      const cell = grid[r][c];

      // Cell floor
      ctx.fillStyle = (r + c) % 2 === 0 ? '#3d2b1a' : '#362618';
      ctx.fillRect(cx, cy, cellSize, cellSize);

      // Walls
      ctx.strokeStyle = '#a07040';
      ctx.lineWidth = 2;
      if (cell.top) {
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + cellSize, cy); ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy + cellSize); ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath(); ctx.moveTo(cx, cy + cellSize); ctx.lineTo(cx + cellSize, cy + cellSize); ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath(); ctx.moveTo(cx + cellSize, cy); ctx.lineTo(cx + cellSize, cy + cellSize); ctx.stroke();
      }
    }
  }

  // Outer border
  ctx.strokeStyle = '#c89050';
  ctx.lineWidth = 3;
  ctx.strokeRect(ox, oy, cols * cellSize, rows * cellSize);

  // Exit marker (glowing)
  const exX = ox + mz.exitC * cellSize;
  const exY = oy + mz.exitR * cellSize;
  const glow = 0.4 + 0.3 * Math.sin(t * 3);
  ctx.fillStyle = `rgba(100, 220, 100, ${glow})`;
  ctx.fillRect(exX + 2, exY + 2, cellSize - 4, cellSize - 4);
  ctx.font = `${Math.min(cellSize - 6, 16)}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('üö™', exX + cellSize / 2, exY + cellSize / 2);

  // Cheese items
  mz.cheeses.forEach(ch => {
    if (ch.collected) return;
    const chX = ox + ch.c * cellSize + cellSize / 2;
    const chY = oy + ch.r * cellSize + cellSize / 2;
    const bob = Math.sin(t * 2 + ch.r + ch.c) * 2;
    ctx.font = `${Math.min(cellSize - 8, 14)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üßÄ', chX, chY + bob);
  });

  // Player mouse (Chai) with smooth animation
  const pxBase = ox + mz.playerC * cellSize;
  const pyBase = oy + mz.playerR * cellSize;
  const px = pxBase + mz.animX;
  const py = pyBase + mz.animY;
  // Scale mouse to fit cell
  const mouseDrawSize = Math.min(cellSize - 4, 28);
  const mScale = mouseDrawSize / 28;
  ctx.save();
  const mcx = px + cellSize / 2;
  const mcy = py + cellSize / 2;
  ctx.translate(mcx, mcy);
  ctx.scale(mScale, mScale);
  ctx.translate(-mcx, -mcy);
  drawMouse(px + (cellSize - 28) / 2, py + (cellSize - 20) / 2 - 2, CONFIG.mice.chai, 1, Math.floor(t * 4) % 4, 'walking');
  ctx.restore();

  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  // Floating effects
  drawFloatingEffects();

  // Level complete overlay
  if (mz.levelComplete) {
    ctx.fillStyle = 'rgba(26,15,5,0.75)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.fillStyle = '#f5d68a';
    ctx.font = '24px monospace';
    ctx.textAlign = 'center';
    if (mz.level >= 3) {
      ctx.fillText('üéâ Maze Complete!', GAME_W / 2, GAME_H / 2 - 40);
      const timeBonus = Math.max(0, 30 - Math.floor(mz.elapsed / 1000));
      ctx.font = '13px monospace';
      ctx.fillStyle = '#e8d5b5';
      ctx.fillText(`Cheese: üßÄ ${mz.totalCheese}  |  Time bonus: +${timeBonus}`, GAME_W / 2, GAME_H / 2 - 5);
      const earned = mz.totalScore;
      ctx.fillStyle = '#f5d68a';
      ctx.font = '16px monospace';
      ctx.fillText(`Earned: üßÄ ${earned} coins!`, GAME_W / 2, GAME_H / 2 + 25);
      ctx.fillStyle = '#a89070';
      ctx.font = '12px monospace';
      ctx.fillText('tap / click to continue', GAME_W / 2, GAME_H / 2 + 55);
    } else {
      ctx.fillText(`‚úÖ Level ${mz.level} Clear!`, GAME_W / 2, GAME_H / 2 - 20);
      ctx.font = '13px monospace';
      ctx.fillStyle = '#e8d5b5';
      ctx.fillText(`Cheese collected: üßÄ ${mz.totalCheese}`, GAME_W / 2, GAME_H / 2 + 10);
      ctx.fillStyle = '#a89070';
      ctx.font = '12px monospace';
      ctx.fillText('tap / click for next level', GAME_W / 2, GAME_H / 2 + 40);
    }
    ctx.textAlign = 'left';
  }
}

function endMouseMaze() {
  stopGameMusic();
  const earned = mz.totalScore;
  state.coins += earned;
  state.totalCoinsEarned += earned;
  addHappiness(6);
  updateCoinDisplay();
  saveGame();
  mouseMazeActive = false;
  startMusic();
  sfxCoinCollect();
  spawnCoinEffect(earned, GAME_W / 2, GAME_H / 2 - 20);
  showToast(`Mouse Maze: earned üßÄ ${earned} coins!`);
}

function handleMazeInput(sx, sy) {
  if (mz.levelComplete) {
    if (mz.level >= 3) {
      endMouseMaze();
    } else {
      mz.level++;
      initMazeLevel(mz.level);
    }
    return;
  }
}

// Maze swipe/drag support
let mazeSwipeStart = null;

function mazeSwipeBegin(sx, sy) {
  mazeSwipeStart = { x: sx, y: sy };
}

function mazeSwipeEnd(sx, sy) {
  if (!mazeSwipeStart) return;
  const dx = sx - mazeSwipeStart.x;
  const dy = sy - mazeSwipeStart.y;
  mazeSwipeStart = null;
  const minDist = 15;
  if (Math.abs(dx) < minDist && Math.abs(dy) < minDist) return;
  if (Math.abs(dx) > Math.abs(dy)) {
    mz.moveQueue.push(dx > 0 ? 'right' : 'left');
  } else {
    mz.moveQueue.push(dy > 0 ? 'down' : 'up');
  }
}

// ============================================================
// BIRTHDAY EVENT
// ============================================================
function triggerBirthdayEvent() {
  if (state.birthdayEventSeen) return;
  state.birthdayEventSeen = true;

  // Give birthday items
  if (!state.ownedItems.includes('birthday-cake')) state.ownedItems.push('birthday-cake');
  if (!state.ownedItems.includes('party-banner')) state.ownedItems.push('party-banner');

  // Place them in the living room
  state.placedItems.push({ itemId: 'party-banner', room: 2, gridX: 3, gridY: 0 });
  state.placedItems.push({ itemId: 'birthday-cake', room: 2, gridX: 8, gridY: GRID_ROWS - 1 });

  // Bonus coins
  state.coins += 100;
  state.totalCoinsEarned += 100;
  updateCoinDisplay();

  // Both mice to living room for the party
  state.miceState.pip.room = 2;
  state.miceState.pip.x = 150;
  state.miceState.pip.action = 'idle';
  state.miceState.pip.actionTimer = 6000;
  state.miceState.chai.room = 2;
  state.miceState.chai.x = 280;
  state.miceState.chai.action = 'idle';
  state.miceState.chai.actionTimer = 6000;

  // Switch to living room
  state.currentRoom = 2;
  buildRoomTabs();

  addHappiness(20);
  saveGame();

  // Celebration sequence
  setTimeout(() => {
    sfxFanfare();
    showToast(`üéÇ Happy Birthday ${CONFIG.twins.name1} & ${CONFIG.twins.name2}! üéâ`);
    // Confetti burst
    for (let i = 0; i < 20; i++) {
      setTimeout(() => {
        spawnFloatingEffect(
          80 + Math.random() * (GAME_W - 160),
          ROOM_Y + 50 + Math.random() * 100,
          ['üéâ','üéä','üéÇ','üßÄ','üíõ','‚≠ê','üéà','‚ú®'][Math.floor(Math.random() * 8)]
        );
      }, i * 80);
    }
  }, 500);

  setTimeout(() => {
    showToast('üßÄ +100 bonus coins! The mice threw a party!');
  }, 4000);

  setTimeout(() => {
    showToast('üíå Check the letter button for a special message!');
  }, 7500);
}

// ============================================================
// BIRTHDAY LETTER
// ============================================================
function openLetter() {
  state.letterRead = true;
  saveGame();
  const container = document.getElementById('modal-container');
  const msgHtml = CONFIG.birthdayMessage.replace(/\n/g, '<br>');
  container.innerHTML = `<div class="modal-overlay" onclick="if(event.target===this)closeModal()">
    <div class="modal-content" style="max-width:480px;">
      <h2>üíå A Letter for You</h2>
      <div class="letter-content">
        <h3>üê≠ Special Delivery üê≠</h3>
        ${msgHtml}
      </div>
      <button class="close-btn" onclick="closeModal()">üíõ</button>
    </div>
  </div>`;
}

// ============================================================
// PARTY HATS (drawn on mice during birthday)
// ============================================================
function drawPartyHat(x, y, action, dir, cfg) {
  if (!state.birthdayEventSeen) return;
  const mouseScale = (cfg && cfg.scale) || 1.0;
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  const t = Date.now() / 1000;
  const bob = action === 'sleeping' ? 0 : Math.sin(t * 3) * 0.6;

  ctx.save();

  // Apply same scale transform as drawMouse so hat aligns
  if (mouseScale !== 1.0) {
    const pivotX = cx + 14;
    const pivotY = cy + 20;
    ctx.translate(pivotX, pivotY);
    ctx.scale(mouseScale, mouseScale);
    ctx.translate(-pivotX, -pivotY);
  }
  // Apply same flip as drawMouse so hat stays on top of head
  if (dir < 0) {
    ctx.translate(cx + 14, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(cx + 14), 0);
  }

  let hatX, hatY;
  if (action === 'sleeping') {
    hatX = cx + 17; hatY = cy + 1;
  } else {
    hatX = cx + 19; hatY = cy - 6 + bob;
  }

  // Hat body (cone)
  ctx.fillStyle = '#FF1493';
  ctx.beginPath();
  ctx.moveTo(hatX, hatY - 10);
  ctx.lineTo(hatX - 5, hatY + 2);
  ctx.lineTo(hatX + 5, hatY + 2);
  ctx.closePath();
  ctx.fill();

  // Stripe
  ctx.fillStyle = '#FFD700';
  ctx.fillRect(hatX - 4, hatY - 2, 8, 2);

  // Pom pom on top
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.arc(hatX, hatY - 10, 2.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// ============================================================
// COIN FLOATING ANIMATION
// ============================================================
function spawnCoinEffect(amount, x, y) {
  if (x === undefined) x = GAME_W / 2;
  if (y === undefined) y = 30;
  for (let i = 0; i < Math.min(amount / 2, 8); i++) {
    setTimeout(() => {
      spawnFloatingEffect(
        x + (Math.random() - 0.5) * 40,
        y + Math.random() * 20,
        'üßÄ'
      );
    }, i * 120);
  }
}

// ============================================================
// HAPPINESS SYSTEM
// ============================================================
const HAPPINESS_DECAY_RATE = 0.0002; // ~1 point per 5 seconds ‚Üí hungry after ~5.4 min

function getAverageHappiness() {
  return Math.round((state.miceState.pip.happiness + state.miceState.chai.happiness) / 2);
}

function addHappiness(amount) {
  state.miceState.pip.happiness = Math.min(100, state.miceState.pip.happiness + amount);
  state.miceState.chai.happiness = Math.min(100, state.miceState.chai.happiness + amount);
  updateHappinessDisplay();
}

let _lastHungerState = false;
function updateHappiness(dt) {
  state.miceState.pip.happiness = Math.max(10, state.miceState.pip.happiness - HAPPINESS_DECAY_RATE * dt);
  state.miceState.chai.happiness = Math.max(10, state.miceState.chai.happiness - HAPPINESS_DECAY_RATE * dt);
  updateHappinessDisplay();
  // Update goal display when hunger state changes
  const anyHungry = state.miceState.pip.happiness < 35 || state.miceState.chai.happiness < 35;
  if (anyHungry !== _lastHungerState) {
    _lastHungerState = anyHungry;
    updateGoalDisplay();
  }
}

function updateHappinessDisplay() {
  const avg = getAverageHappiness();
  const el = document.getElementById('happiness-value');
  if (el) el.textContent = avg;
  const color = avg >= 70 ? '#f5d68a' : avg >= 40 ? '#e8a040' : '#e06050';
  const hd = document.getElementById('happiness-display');
  if (hd) hd.style.color = color;
}

// ============================================================
// GOALS / WISHES SYSTEM
// ============================================================
const GOAL_TEMPLATES = [
  { text: '{mouse} wants a cozy bed üõè', itemId: 'matchbox-bed' },
  { text: '{mouse} is craving cheese üßÄ', itemId: 'cheese-wheel' },
  { text: '{mouse} wants a coffee ‚òï', itemId: 'thimble-cup' },
  { text: '{mouse} wants to doomscroll üíª', itemId: 'tiny-laptop' },
  { text: '{mouse} needs a yoga session üßò', itemId: 'yoga-mat' },
  { text: '{mouse} wants to watch TV üì∫', itemId: 'eraser-tv' },
  { text: '{mouse} wants aesthetic lights ‚ú®', itemId: 'fairy-lights' },
  { text: '{mouse} wants a plant friend ü™¥', itemId: 'tiny-plant' },
  { text: '{mouse} needs a disco ball ü™©', itemId: 'disco-ball' },
  { text: '{mouse} wants to sit somewhere üõã', itemId: 'cardboard-couch' },
  { text: '{mouse} craves sourdough üçû', itemId: 'sourdough' },
  { text: '{mouse} wants the vibes sign üìú', itemId: 'live-laugh-cheese' },
];

let goalCooldown = 20000 + Math.random() * 15000;

function updateGoals(dt) {
  // Check if current goal is fulfilled
  if (state.activeGoal) {
    // Auto-expire stale goals after 2 minutes
    const age = Date.now() - (state.activeGoal.created || 0);
    if (age > 120000) {
      state.activeGoal = null;
      updateGoalDisplay();
      saveGame();
      goalCooldown = 15000 + Math.random() * 10000;
      return;
    }
    const isPlaced = state.placedItems.some(p => p.itemId === state.activeGoal.itemId);
    if (isPlaced) {
      // Goal completed!
      const bonus = 15;
      state.coins += bonus;
      state.totalCoinsEarned += bonus;
      addHappiness(10);
      updateCoinDisplay();
      spawnCoinEffect(bonus);
      sfxGoalComplete();
      showToast(`‚úÖ Goal complete! ${state.activeGoal.text} ‚Äî +üßÄ${bonus} +‚ù§Ô∏è!`);
      state.activeGoal = null;
      updateGoalDisplay();
      saveGame();
      goalCooldown = 25000 + Math.random() * 20000;
      return;
    }
  }

  // Generate new goal if none active
  if (!state.activeGoal) {
    goalCooldown -= dt;
    if (goalCooldown <= 0) {
      generateNewGoal();
      goalCooldown = 30000 + Math.random() * 20000;
    }
  }
}

function generateNewGoal() {
  // Pick a goal for an item not yet placed
  const unplaced = GOAL_TEMPLATES.filter(g =>
    !state.placedItems.some(p => p.itemId === g.itemId)
  );
  if (unplaced.length === 0) return;

  const template = unplaced[Math.floor(Math.random() * unplaced.length)];
  const mouseKey = Math.random() < 0.5 ? 'pip' : 'chai';
  const mouseName = CONFIG.mice[mouseKey].name;
  const text = template.text.replace('{mouse}', mouseName);

  state.activeGoal = { text, itemId: template.itemId, mouseKey, created: Date.now() };
  updateGoalDisplay();
  saveGame();

  // Mouse says the wish
  const mouse = state.miceState[mouseKey];
  speechBubbles.push({
    x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
    text: text, timer: 4000, maxTimer: 4000, mouseKey
  });
}

function updateGoalDisplay() {
  const el = document.getElementById('goal-display');
  const row2 = document.getElementById('hud-row2');
  if (!el || !row2) return;

  // Hunger warnings take priority over goals
  const pipHungry = (state.miceState.pip.happiness ?? 80) < 35;
  const chaiHungry = (state.miceState.chai.happiness ?? 80) < 35;
  const hasFood = state.placedItems.some(p => {
    const item = FURNITURE.find(f => f.id === p.itemId);
    return item && item.servings && (p.servings === undefined || p.servings > 0);
  });

  if (pipHungry || chaiHungry) {
    const names = [pipHungry && 'Pip', chaiHungry && 'Chai'].filter(Boolean).join(' & ');
    el.textContent = hasFood ? `üçΩ ${names} ${pipHungry && chaiHungry ? 'are' : 'is'} hungry! Food is available.`
                             : `‚ö†Ô∏è ${names} ${pipHungry && chaiHungry ? 'are' : 'is'} hungry! Buy food from aMouseZon!`;
    el.style.color = '#e06050';
    row2.classList.add('visible');
    return;
  }

  el.style.color = '';
  if (state.activeGoal) {
    el.textContent = `üéØ ${state.activeGoal.text}`;
    el.title = `Place ${FURNITURE.find(f => f.id === state.activeGoal.itemId)?.name || 'the item'} to complete!`;
    row2.classList.add('visible');
  } else {
    el.textContent = '';
    el.title = '';
    row2.classList.remove('visible');
  }
}

// ============================================================
// MOUSE SPRITE DRAWING
// ============================================================
const MOUSE_FLOOR_Y = ROOM_Y + ROOM_H - FLOOR_H - 20;

function getMouseFloorY(mouse) {
  const room = ROOMS[mouse.room];
  if (!room || !room.platforms) return MOUSE_FLOOR_Y;
  // During climbing, interpolate Y along the ramp
  if (mouse.action === 'climbing' && mouse.climbRamp) {
    return getRampY(mouse.climbRamp, mouse.x, mouse.room) - 20;
  }
  const plat = room.platforms.find(p => p.id === mouse.level);
  if (!plat) return MOUSE_FLOOR_Y;
  // main-floor y already has the -20 offset baked in; other platforms need it
  return plat.id === 'main-floor' ? plat.y : plat.y - 20;
}

function getMousePlatform(mouse) {
  const room = ROOMS[mouse.room];
  if (!room || !room.platforms) return null;
  return room.platforms.find(p => p.id === mouse.level) || room.platforms[0];
}

function getRampAtX(roomIndex, x, fromLevel, toLevel) {
  const room = ROOMS[roomIndex];
  if (!room || !room.ramps) return null;
  return room.ramps.find(r =>
    ((r.from === fromLevel && r.to === toLevel) || (r.from === toLevel && r.to === fromLevel)) &&
    x >= r.x1 - 5 && x <= r.x2 + 5
  ) || null;
}

function getRampY(ramp, x, roomIndex) {
  const room = ROOMS[roomIndex];
  const fromPlat = room.platforms.find(p => p.id === ramp.from);
  const toPlat = room.platforms.find(p => p.id === ramp.to);
  if (!fromPlat || !toPlat) return MOUSE_FLOOR_Y;
  const t = Math.max(0, Math.min(1, (x - ramp.x1) / (ramp.x2 - ramp.x1)));
  return fromPlat.y + (toPlat.y - fromPlat.y) * t;
}

function drawMouse(x, y, cfg, dir, frame, action, startled) {
  const mouseScale = cfg.scale || 1.0;
  const cx = Math.floor(x);
  // Startled: slight vertical jump
  const startleJump = startled ? -3 : 0;
  const cy = Math.floor(y) + startleJump;
  const t = Date.now() / 1000;

  ctx.save();
  // Apply mouse-specific scale (Pip is larger)
  if (mouseScale !== 1.0) {
    const pivotX = cx + 14;
    const pivotY = cy + 20; // scale from feet so they stay on ground
    ctx.translate(pivotX, pivotY);
    ctx.scale(mouseScale, mouseScale);
    ctx.translate(-pivotX, -pivotY);
  }
  if (dir < 0) {
    ctx.translate(cx + 14, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(cx + 14), 0);
  }

  if (action === 'sleeping') {
    // Breathing cycle ‚Äî gentle body scale pulse
    const sleepBreath = Math.sin(t * 1.8) * 0.03;
    ctx.translate(cx + 10, cy + 14);
    ctx.scale(1 + sleepBreath, 1 - sleepBreath * 0.5);
    ctx.translate(-(cx + 10), -(cy + 14));

    // Body
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 12, 11, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    // Belly highlight
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 13, 7, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    // Head tucked in
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy + 8, 6, 5, 0.3, 0, Math.PI * 2);
    ctx.fill();
    // Ear with occasional twitch
    const earTwitch = (Math.sin(t * 0.7) > 0.92) ? Math.sin(t * 12) * 0.3 : 0;
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 3, 4, 5, 0.4 + earTwitch, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 3, 2.5, 3, 0.4 + earTwitch, 0, Math.PI * 2);
    ctx.fill();
    // Tail curled
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy + 12);
    ctx.quadraticCurveTo(cx - 8, cy + 6, cx - 4, cy + 2);
    ctx.stroke();
    // Zzz (slower float)
    const zOff = Math.sin(t * 1.2) * 3;
    ctx.fillStyle = 'rgba(200,200,255,0.6)';
    ctx.font = '8px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('z', cx + 22, cy - 1 + zOff);
    ctx.font = '11px monospace';
    ctx.fillText('z', cx + 27, cy - 7 + zOff * 1.3);
    ctx.font = '13px monospace';
    ctx.fillText('Z', cx + 32, cy - 14 + zOff * 1.6);
    ctx.textAlign = 'left';
  } else if (action === 'zoomies') {
    // Fast running mouse with motion blur!
    const zBob = Math.sin(t * 14) * 2;
    const zFrame = Math.floor(t * 12) % 2;

    // Motion lines behind
    ctx.strokeStyle = 'rgba(200,180,140,0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(cx - 4 - i * 6, cy + 6 + i * 3 + zBob);
      ctx.lineTo(cx - 12 - i * 6, cy + 6 + i * 3 + zBob);
      ctx.stroke();
    }

    // Shadow (stretched)
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(cx + 14, cy + 20, 16, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tail streaming
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(cx, cy + 10 + zBob);
    ctx.quadraticCurveTo(cx - 12, cy + 4 + zBob, cx - 16, cy + 8 + zBob);
    ctx.stroke();
    ctx.lineCap = 'butt';

    // Legs (alternating fast)
    ctx.fillStyle = cfg.bodyColor;
    const legOff = zFrame * 4;
    ctx.fillRect(cx + 4 + legOff, cy + 15 + zBob, 3, 6);
    ctx.fillRect(cx + 14 - legOff, cy + 15 + zBob, 3, 6);
    ctx.fillStyle = cfg.bellyColor;
    ctx.fillRect(cx + 3 + legOff, cy + 20 + zBob, 5, 2);
    ctx.fillRect(cx + 13 - legOff, cy + 20 + zBob, 5, 2);

    // Body (stretched)
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 12, cy + 10 + zBob, 12, 7, -0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 12, cy + 12 + zBob, 7, 4, -0.1, 0, Math.PI * 2);
    ctx.fill();

    // Head (forward-leaning)
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 22, cy + 4 + zBob, 7, 5.5, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Ears (windswept)
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy - 3 + zBob, 4, 5, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy - 3 + zBob, 2.5, 3, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 24, cy - 2 + zBob, 4, 5, -0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 24, cy - 2 + zBob, 2.5, 3, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // Wide excited eyes
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.ellipse(cx + 20, cy + 2 + zBob, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 25, cy + 2 + zBob, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(cx + 20.5, cy + 1 + zBob, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + 25.5, cy + 1 + zBob, 1, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = cfg.noseColor;
    ctx.beginPath();
    ctx.ellipse(cx + 29, cy + 4 + zBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Open mouth (excitement!)
    ctx.fillStyle = '#2a1a1a';
    ctx.beginPath();
    ctx.ellipse(cx + 27, cy + 6 + zBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

  } else {
    // Standing / walking / idle / furniture-interaction mouse
    const isFurnitureAction = ['doomscrolling','watching','yoga','eating','playing','grooming','stretching','mischief'].includes(action);

    // Breathing: visible body pulse
    const breathe = Math.sin(t * 3) * 0.8;
    // Walk cycle: head bobs with slight offset from body
    const walkCycle = action === 'walking' ? Math.sin(t * 10) : 0;
    const bob = action === 'walking' ? walkCycle * 1.8 : breathe;
    const headBob = action === 'walking' ? Math.sin(t * 10 + 0.5) * 1.2 : breathe * 0.6;
    const lean = action === 'walking' ? Math.sin(t * 10) * 0.04 :
                 action === 'yoga' ? Math.sin(t * 2) * 0.06 : 0;

    // Blink timer: eyes close briefly every 3-6 seconds
    const blinkPhase = t % (3 + (cx % 3)); // vary per mouse position
    const isBlinking = blinkPhase < 0.12;

    // Ear twitch: random brief twitch when idle
    const earTwitchL = (Math.sin(t * 0.6 + cx) > 0.9) ? Math.sin(t * 14) * 0.25 : 0;
    const earTwitchR = (Math.sin(t * 0.8 + cx * 0.7) > 0.92) ? Math.sin(t * 16) * 0.2 : 0;

    ctx.translate(cx + 14, cy + 18);
    ctx.rotate(lean);
    ctx.translate(-(cx + 14), -(cy + 18));

    // Shadow on floor
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(cx + 14, cy + 20, 12, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tail ‚Äî expressive based on action
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    let tailWag, tailCurveY, tailEndY;
    if (action === 'eating') {
      // Happy fast wag
      tailWag = Math.sin(t * 8) * 6;
      tailCurveY = cy + 2; tailEndY = cy + tailWag;
    } else if (action === 'zoomies') {
      tailWag = Math.sin(t * 6) * 5;
      tailCurveY = cy + 1; tailEndY = cy + 5 + tailWag;
    } else if (action === 'walking') {
      // Bouncing tail synced to walk
      tailWag = Math.sin(t * 5) * 4;
      tailCurveY = cy + 4 + walkCycle; tailEndY = cy + 8 + tailWag;
    } else if (isFurnitureAction) {
      // Gentle slow sway
      tailWag = Math.sin(t * 2) * 3;
      tailCurveY = cy + 5; tailEndY = cy + 9 + tailWag;
    } else {
      // Idle ‚Äî occasional lazy swish
      tailWag = Math.sin(t * 2.5) * 3;
      tailCurveY = cy + 4; tailEndY = cy + 8 + tailWag;
    }
    ctx.beginPath();
    ctx.moveTo(cx + 2, cy + 12 + bob);
    ctx.quadraticCurveTo(cx - 8, tailCurveY + bob, cx - 12, tailEndY + bob);
    ctx.stroke();
    ctx.lineCap = 'butt';

    // Back legs ‚Äî better walk stride
    const legAnim = action === 'walking' ? Math.sin(t * 10) * 4 : 0;
    const legLift = action === 'walking' ? Math.max(0, Math.sin(t * 10)) * 2 : 0;
    const legLift2 = action === 'walking' ? Math.max(0, -Math.sin(t * 10)) * 2 : 0;
    ctx.fillStyle = cfg.bodyColor;
    ctx.fillRect(cx + 4 - legAnim, cy + 16 + bob - legLift, 4, 5 + legLift);
    ctx.fillRect(cx + 12 + legAnim, cy + 16 + bob - legLift2, 4, 5 + legLift2);
    // Tiny feet
    ctx.fillStyle = cfg.bellyColor;
    ctx.fillRect(cx + 3 - legAnim, cy + 20 + bob, 5, 2);
    ctx.fillRect(cx + 11 + legAnim, cy + 20 + bob, 5, 2);

    // Body (rounded) ‚Äî breathing scale
    const bodyBreath = 1 + Math.sin(t * 3) * 0.015;
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 11 + bob, 10 * bodyBreath, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 13 + bob, 6, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head ‚Äî offset bob for walking liveliness
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 5 + headBob, 7, 6, 0.15, 0, Math.PI * 2);
    ctx.fill();

    // Ears (big & round!) with twitching
    // Left ear
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 15, cy - 4 + headBob, 5, 6, -0.3 + earTwitchL, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 15, cy - 4 + headBob, 3, 4, -0.3 + earTwitchL, 0, Math.PI * 2);
    ctx.fill();
    // Right ear
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 23, cy - 4 + headBob, 5, 6, 0.3 + earTwitchR, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 23, cy - 4 + headBob, 3, 4, 0.3 + earTwitchR, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (big & cute) ‚Äî with blinking
    if (isBlinking) {
      // Blink ‚Äî thin horizontal lines
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx + 15, cy + 3 + headBob);
      ctx.lineTo(cx + 19, cy + 3 + headBob);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + 20, cy + 3 + headBob);
      ctx.lineTo(cx + 24, cy + 3 + headBob);
      ctx.stroke();
    } else if (action === 'doomscrolling' || action === 'watching') {
      // Screen-glow eyes
      ctx.fillStyle = '#66ccff';
      ctx.beginPath();
      ctx.ellipse(cx + 17, cy + 3 + headBob, 2.2, 2.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22, cy + 3 + headBob, 2.2, 2.8, 0, 0, Math.PI * 2);
      ctx.fill();
    } else if (action === 'yoga') {
      // Closed peaceful eyes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx + 17, cy + 3 + headBob, 2, 0.3, Math.PI - 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx + 22, cy + 3 + headBob, 2, 0.3, Math.PI - 0.3);
      ctx.stroke();
    } else if (action === 'eating' || action === 'grooming') {
      // Happy squinty eyes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx + 17, cy + 4 + headBob, 2, Math.PI + 0.3, -0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx + 22, cy + 4 + headBob, 2, Math.PI + 0.3, -0.3);
      ctx.stroke();
    } else if (startled) {
      // Startled ‚Äî wide round eyes!
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(cx + 17, cy + 3 + headBob, 3, 3.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22, cy + 3 + headBob, 3, 3.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(cx + 17, cy + 3 + headBob, 1.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 22, cy + 3 + headBob, 1.8, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.ellipse(cx + 17, cy + 3 + headBob, 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22, cy + 3 + headBob, 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx + 17.5, cy + 2 + headBob, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 22.5, cy + 2 + headBob, 0.8, 0, Math.PI * 2);
      ctx.fill();
    }

    // Nose (tiny pink)
    ctx.fillStyle = cfg.noseColor;
    ctx.beginPath();
    ctx.ellipse(cx + 26, cy + 5 + headBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Whiskers
    ctx.strokeStyle = 'rgba(180,160,140,0.5)';
    ctx.lineWidth = 0.7;
    ctx.beginPath();
    ctx.moveTo(cx + 25, cy + 5 + headBob);
    ctx.lineTo(cx + 32, cy + 2 + headBob);
    ctx.moveTo(cx + 25, cy + 6 + headBob);
    ctx.lineTo(cx + 32, cy + 7 + headBob);
    ctx.moveTo(cx + 25, cy + 5.5 + headBob);
    ctx.lineTo(cx + 33, cy + 4.5 + headBob);
    ctx.stroke();

    // Tiny smile
    ctx.strokeStyle = 'rgba(100,60,60,0.3)';
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(cx + 23, cy + 6 + headBob, 3, 0.2, 1.2);
    ctx.stroke();

    // Grooming: paw raised to face, licking motion
    if (action === 'grooming') {
      const lickCycle = Math.sin(t * 6) * 2;
      ctx.fillStyle = cfg.bellyColor;
      ctx.beginPath();
      ctx.ellipse(cx + 22, cy + 8 + headBob + lickCycle, 3, 2, 0.3, 0, Math.PI * 2);
      ctx.fill();
      // Tiny tongue
      ctx.fillStyle = '#ff9999';
      ctx.beginPath();
      ctx.ellipse(cx + 24, cy + 7 + headBob + lickCycle * 0.5, 1.5, 1, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Mischief: sly look ‚Äî one eyebrow raised (draw after eyes)
    if (action === 'mischief') {
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx + 20, cy - 1 + headBob);
      ctx.lineTo(cx + 24, cy - 2 + headBob);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ============================================================
// MOUSE AI
// ============================================================
function updateMouse(mouse, dt, personality) {
  // Handle flung state separately
  if (mouse.action === 'flung') {
    updateFlungMouse(mouse, dt);
    return;
  }

  // Wheeling mice don't move normally ‚Äî they're on the wheel
  if (mouse.action === 'wheeling') {
    mouse.actionTimer -= dt;
    if (mouse.actionTimer <= 0) {
      mouse.action = 'idle';
      mouse.level = 'main-floor';
      mouse.actionTimer = 2000 + Math.random() * 2000;
      // Step off the wheel ‚Äî reposition to nearby floor
      const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === mouse.room);
      if (wheelPlaced) {
        const center = getWheelCenter(wheelPlaced);
        mouse.x = center.x + (Math.random() < 0.5 ? -40 : 40);
      }
    }
    return;
  }

  // Climbing ramp animation
  if (mouse.action === 'climbing' && mouse.climbRamp) {
    const ramp = mouse.climbRamp;
    const speed = 0.035 * dt;
    const targetX = mouse.climbGoingUp ? ramp.x2 : ramp.x1;
    const dist = targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.x = targetX;
      mouse.level = mouse.climbTargetLevel;
      mouse.climbRamp = null;
      mouse.climbTargetLevel = null;
      mouse.climbGoingUp = null;
      mouse.action = 'idle';
      mouse.actionTimer = 1000 + Math.random() * 1500;
    }
    // Animate frame during climb
    mouse.animTimer += dt;
    if (mouse.animTimer > 180) { mouse.frame = (mouse.frame + 1) % 4; mouse.animTimer = 0; }
    clampMouseToPlatform(mouse);
    return;
  }

  // Animation timer
  mouse.animTimer += dt;
  if (mouse.animTimer > 180) {
    mouse.frame = (mouse.frame + 1) % 4;
    mouse.animTimer = 0;
  }

  // Action timer countdown ‚Äî skip if walking to a pending transition or walking to food
  // Safety valve: if timer is very negative (stuck > 5s), allow pickNewAction to unstick
  mouse.actionTimer -= dt;
  const walkingToFood = mouse.action === 'eating' && mouse.targetX !== undefined;
  // Critical hunger interrupt: bypass timer when starving
  const criticallyHungry = (mouse.happiness ?? 80) <= 15;
  const canInterrupt = mouse.action !== 'climbing' && mouse.action !== 'flung' && mouse.action !== 'wheeling' && !mouse.pendingRoomChange && !mouse.pendingClimb;
  if (criticallyHungry && canInterrupt && mouse.action !== 'eating') {
    pickNewAction(mouse, personality);
  } else if (mouse.actionTimer <= 0 && !mouse.pendingRoomChange && !mouse.pendingClimb && (!walkingToFood || mouse.actionTimer < -5000)) {
    pickNewAction(mouse, personality);
  }

  // Movement
  if (mouse.action === 'walking' && mouse.targetX !== undefined) {
    const speed = 0.065 * dt;
    const dist = mouse.targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.x = mouse.targetX;
      mouse.targetX = undefined;
      // Check if we have a pending climb to start
      if (mouse.pendingClimb) {
        const pc = mouse.pendingClimb;
        mouse.action = 'climbing';
        mouse.climbRamp = pc.ramp;
        mouse.climbTargetLevel = pc.targetLevel;
        mouse.climbGoingUp = pc.goingUp;
        mouse.pendingClimb = null;
        return;
      }
      // Check if we have a pending room change (mouse reached the exit edge)
      if (mouse.pendingRoomChange) {
        const prc = mouse.pendingRoomChange;
        mouse.pendingRoomChange = null;
        mouse.room = prc.newRoom;
        mouse.level = 'main-floor';
        const plat = ROOMS[prc.newRoom].platforms ? ROOMS[prc.newRoom].platforms[0] : null;
        const xMin = plat ? plat.xMin + 10 : 30;
        const xMax = plat ? plat.xMax - 40 : ROOM_W - 60;
        // Enter from the opposite edge (exit right ‚Üí enter left, and vice versa)
        mouse.x = prc.exitDir > 0 ? xMin : xMax;
        mouse.dir = prc.exitDir;
        // Walk inward from the entrance
        mouse.action = 'walking';
        mouse.targetX = xMin + Math.random() * (xMax - xMin);
        mouse.actionTimer = 4000;
        return;
      }
      mouse.action = 'idle';
      mouse.actionTimer = 1000 + Math.random() * 1500;
    }
  } else if (mouse.action === 'zoomies') {
    const plat = getMousePlatform(mouse);
    const xMin = plat ? plat.xMin + 10 : 20;
    const xMax = plat ? plat.xMax - 40 : ROOM_W - 50;
    const speed = 0.15 * dt;
    mouse.x += mouse.dir * speed;
    if (mouse.x > xMax) { mouse.dir = -1; }
    if (mouse.x < xMin) { mouse.dir = 1; }
  } else if (mouse.targetX !== undefined) {
    // Walk toward furniture target for any behavior
    const speed = 0.055 * dt;
    const dist = mouse.targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.targetX = undefined;
    }
  }

  // Food consumption: when eating near a food item with servings
  if (mouse.action === 'eating' && mouse.targetX === undefined) {
    if (!mouse._eatCooldown || mouse._eatCooldown <= 0) {
      const nearbyFood = state.placedItems.find(p => {
        if (p.room !== mouse.room) return false;
        const item = FURNITURE.find(f => f.id === p.itemId);
        if (!item || item.mouseBehavior !== 'eating' || !item.servings) return false;
        const pos = gridToGame(p.gridX, p.gridY);
        return Math.abs(mouse.x - pos.x) < 30;
      });
      if (nearbyFood) {
        if (nearbyFood.servings === undefined) nearbyFood.servings = FURNITURE.find(f => f.id === nearbyFood.itemId).servings;
        nearbyFood.servings--;
        const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
        // Happiness boost per bite
        mouse.happiness = Math.min(100, (mouse.happiness ?? 80) + 15);
        updateHappinessDisplay();
        if (mouse.room === state.currentRoom) {
          const eatQuotes = ['*nom nom*', 'yum! üòã', 'so good', 'more pls', '*crunch*', 'delish ‚ú®'];
          speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
          speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
            text: eatQuotes[Math.floor(Math.random() * eatQuotes.length)],
            timer: 1500, maxTimer: 1500, mouseKey });
        }
        if (nearbyFood.servings <= 0) {
          // Food consumed ‚Äî remove from placed items
          state.placedItems = state.placedItems.filter(p => p !== nearbyFood);
          if (mouse.room === state.currentRoom) {
            const pos = gridToGame(nearbyFood.gridX, nearbyFood.gridY);
            spawnFloatingEffect(pos.x + 12, pos.y + 12, '‚ú®');
          }
          mouse.action = 'idle';
          mouse.actionTimer = 1000;
        }
        mouse._eatCooldown = 800; // 0.8 seconds between bites
        saveGame();
      } else {
        // No food nearby ‚Äî recover from stuck eating state
        mouse.action = 'idle';
        mouse.actionTimer = 500;
      }
    } else {
      mouse._eatCooldown -= dt;
    }
  }

  // Clamp to current platform bounds
  clampMouseToPlatform(mouse);
}

function clampMouseToPlatform(mouse) {
  // Don't clamp when walking to the room edge for a room transition
  if (mouse.pendingRoomChange) return;
  const plat = getMousePlatform(mouse);
  if (plat) {
    mouse.x = Math.max(plat.xMin + 5, Math.min(plat.xMax - 35, mouse.x));
  } else {
    mouse.x = Math.max(15, Math.min(ROOM_W - 45, mouse.x));
  }
}

function pickNewAction(mouse, personality) {
  // Clear any pending transitions from a previous action
  mouse.pendingClimb = null;
  mouse.pendingRoomChange = null;
  const roll = Math.random();
  const room = ROOMS[mouse.room];

  // Hunger-driven food seeking ‚Äî checked FIRST so hungry mice always prioritize food
  const isHungry = (mouse.happiness ?? 80) < 35;
  if (isHungry) {
    // Check all rooms for food with servings remaining
    const allFood = state.placedItems.filter(p => {
      const item = FURNITURE.find(f => f.id === p.itemId);
      return item && item.servings && (p.servings === undefined || p.servings > 0);
    });
    const foodInRoom = allFood.filter(p => p.room === mouse.room);

    if (foodInRoom.length > 0) {
      // Rush to nearest food in this room ‚Äî drop to main-floor first
      const target = foodInRoom[Math.floor(Math.random() * foodInRoom.length)];
      const pos = gridToGame(target.gridX, target.gridY);
      mouse.level = 'main-floor';
      mouse.action = 'eating';
      mouse.targetX = pos.x + Math.random() * 10;
      mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
      mouse.actionTimer = 8000;
      return;
    }
    // No food in this room ‚Äî walk to exit edge, then step one room toward food
    const foodElsewhere = allFood.filter(p => p.room !== mouse.room);
    if (foodElsewhere.length > 0) {
      const target = foodElsewhere[Math.floor(Math.random() * foodElsewhere.length)];
      const nextRoom = ringStepToward(mouse.room, target.room);
      const exitDir = nextRoom === roomRight(mouse.room) ? 1 : -1;
      const exitX = exitDir > 0 ? ROOM_W - 5 : 5;
      mouse.level = 'main-floor';
      mouse.action = 'walking';
      mouse.targetX = exitX;
      mouse.dir = exitDir;
      mouse.actionTimer = 12000;
      mouse.pendingRoomChange = { newRoom: nextRoom, exitDir };
      return;
    }
    // Truly no food anywhere ‚Äî complain
    if (mouse.room === state.currentRoom && Math.random() < 0.3) {
      const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
      const noFoodQuotes = ['where\'s the food?! üò∞', '*stomach growls*', 'buy us food! üò©', 'empty bowl era üò¢'];
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
      speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: noFoodQuotes[Math.floor(Math.random() * noFoodQuotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey });
    }
  }

  // Chance to switch rooms ‚Äî 18%, moves to adjacent room on the ring
  // Mouse walks to the exit edge, then transitions to the new room
  if (roll < 0.18) {
    const otherMouse = mouse === state.miceState.pip ? state.miceState.chai : state.miceState.pip;
    let newRoom;
    if (otherMouse.room !== mouse.room && Math.random() < 0.7) {
      newRoom = ringStepToward(mouse.room, otherMouse.room);
    } else {
      newRoom = Math.random() < 0.5 ? roomLeft(mouse.room) : roomRight(mouse.room);
    }
    if (newRoom !== mouse.room) {
      // Determine exit direction: left neighbor = walk left, right neighbor = walk right
      const exitDir = newRoom === roomRight(mouse.room) ? 1 : -1;
      // Target the actual room wall edge (beyond platform clamp)
      const exitX = exitDir > 0 ? ROOM_W - 5 : 5;
      // Walk to the exit edge, then room switch happens on arrival
      mouse.level = 'main-floor';
      mouse.action = 'walking';
      mouse.targetX = exitX;
      mouse.dir = exitDir;
      mouse.actionTimer = 12000;
      mouse.pendingRoomChange = { newRoom, exitDir };
      return;
    }
    mouse.action = 'idle';
    mouse.actionTimer = 800 + Math.random() * 1200;
    return;
  }

  // Chance to switch levels (climb ramp) ‚Äî 30% if room has ramps
  if (room.ramps && room.ramps.length > 0 && roll < 0.48) {
    // Find a ramp accessible from current level
    const availableRamps = room.ramps.filter(r => r.from === mouse.level || r.to === mouse.level);
    if (availableRamps.length > 0) {
      const ramp = availableRamps[Math.floor(Math.random() * availableRamps.length)];
      const goingUp = ramp.from === mouse.level;
      const targetLevel = goingUp ? ramp.to : ramp.from;

      // First walk to the ramp entrance, then climb
      const rampEntryX = goingUp ? ramp.x1 : ramp.x2;
      mouse.action = 'walking';
      mouse.targetX = rampEntryX;
      mouse.dir = rampEntryX > mouse.x ? 1 : -1;
      mouse.actionTimer = 6000;

      // Set up climb state ‚Äî will activate when mouse reaches ramp
      mouse.pendingClimb = { ramp, targetLevel, goingUp };
      return;
    }
  }

  // Check what furniture behaviors are available in this room
  const roomItems = state.placedItems.filter(p => p.room === mouse.room);
  const furnitureBehaviors = [];
  roomItems.forEach(placed => {
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (item && item.mouseBehavior && !furnitureBehaviors.includes(item.mouseBehavior)) {
      furnitureBehaviors.push({ behavior: item.mouseBehavior, placed });
    }
  });

  // 40% chance to interact with furniture if any is available
  if (furnitureBehaviors.length > 0 && Math.random() < 0.4) {
    let pick;
    // Pip is hungrier ‚Äî strongly prefers food items
    const foodBehaviors = furnitureBehaviors.filter(fb => fb.behavior === 'eating');
    if (personality === 'chaotic' && foodBehaviors.length > 0 && Math.random() < 0.6) {
      pick = foodBehaviors[Math.floor(Math.random() * foodBehaviors.length)];
    } else {
      // Both mice love the exercise wheel ‚Äî high preference
      const wheelBehaviors = furnitureBehaviors.filter(fb => fb.behavior === 'wheeling');
      if (wheelBehaviors.length > 0 && Math.random() < 0.5) {
        pick = wheelBehaviors[0];
      } else {
        pick = furnitureBehaviors[Math.floor(Math.random() * furnitureBehaviors.length)];
      }
    }
    mouse.action = pick.behavior;
    const targetPos = gridToGame(pick.placed.gridX, pick.placed.gridY);
    mouse.targetX = targetPos.x + Math.random() * 10;
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 3000 + Math.random() * 4000;
    if (pick.behavior === 'sleeping') mouse.actionTimer = 3000 + Math.random() * 3000;
    if (pick.behavior === 'zoomies') mouse.actionTimer = 2000 + Math.random() * 2000;
    if (pick.behavior === 'wheeling') mouse.actionTimer = 4000 + Math.random() * 5000;
    return;
  }

  // Personality-weighted action selection ‚Äî both mice are hyper
  let weights;
  if (personality === 'chaotic') {
    // Pip: very active, lots of zoomies and mischief
    weights = [
      { action: 'idle', w: 8 },
      { action: 'walking', w: 32 },
      { action: 'sleeping', w: 6 },
      { action: 'zoomies', w: 22 },
      { action: 'grooming', w: 8 },
      { action: 'mischief', w: 14 }
    ];
  } else {
    // Chai: still hyper but slightly more balanced
    weights = [
      { action: 'idle', w: 12 },
      { action: 'walking', w: 28 },
      { action: 'sleeping', w: 12 },
      { action: 'zoomies', w: 14 },
      { action: 'grooming', w: 12 },
      { action: 'mischief', w: 10 }
    ];
  }

  const totalW = weights.reduce((s, w) => s + w.w, 0);
  let pick = Math.random() * totalW;
  let chosen = 'idle';
  for (const w of weights) {
    pick -= w.w;
    if (pick <= 0) { chosen = w.action; break; }
  }

  mouse.action = chosen;

  if (chosen === 'walking') {
    const plat = getMousePlatform(mouse);
    const xMin = plat ? plat.xMin + 10 : 20;
    const xMax = plat ? plat.xMax - 40 : ROOM_W - 70;
    mouse.targetX = xMin + Math.random() * (xMax - xMin);
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 5000;
  } else if (chosen === 'sleeping') {
    // Transition through stretching if waking from a previous sleep
    mouse.actionTimer = 3000 + Math.random() * 4000;
  } else if (chosen === 'zoomies') {
    mouse.actionTimer = 2500 + Math.random() * 2000;
    mouse.dir = Math.random() < 0.5 ? 1 : -1;
    if (mouse.room === state.currentRoom) sfxZoomies();
  } else if (chosen === 'grooming') {
    mouse.actionTimer = 2500 + Math.random() * 2500;
    if (mouse.room === state.currentRoom) {
      const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
      const groomQuotes = ['*lick lick*', 'gotta stay clean', 'spa day üíÖ', 'self-care era', '*grooming intensifies*'];
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
      speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: groomQuotes[Math.floor(Math.random() * groomQuotes.length)],
        timer: 2000, maxTimer: 2000, mouseKey });
    }
  } else if (chosen === 'mischief') {
    mouse.actionTimer = 3000 + Math.random() * 3000;
    const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
    // Walk to a random furniture item or shelf
    const roomItems = state.placedItems.filter(p => p.room === mouse.room);
    if (roomItems.length > 0) {
      const target = roomItems[Math.floor(Math.random() * roomItems.length)];
      const tPos = gridToGame(target.gridX, target.gridY);
      mouse.targetX = tPos.x + Math.random() * 10;
      mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    }
    if (mouse.room === state.currentRoom) {
      const pipMischief = [
        '*knocks thing off shelf*', 'oops üòà', 'wasn\'t me', 'chaos is a ladder',
        '*pushes to edge*', 'no thoughts just crimes', '*yeets item*',
        'watch this‚Äî', 'what does this button do', '*chews on wire*',
        'gravity test! üìâ', 'for science üî¨', 'the shelf had it coming'
      ];
      const chaiMischief = [
        '*claims this spot*', 'this is mine now', '*hides*', 'you can\'t see me üëÄ',
        '*box acquired*', 'stealth mode', '*reorganizes everything*',
        'I live here now', '*tunnels into blanket*', 'invisible mouse activated',
        'if I fits I sits', '*rearranges furniture*', 'feng shui üéã'
      ];
      const quotes = personality === 'chaotic' ? pipMischief : chaiMischief;
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
      speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: quotes[Math.floor(Math.random() * quotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey });
      // Visual mischief effect
      if (roomItems.length > 0 && Math.random() < 0.4) {
        const effectItem = roomItems[Math.floor(Math.random() * roomItems.length)];
        const ePos = gridToGame(effectItem.gridX, effectItem.gridY);
        const effects = ['üí•', '‚≠ê', '‚ùó', 'üí´', 'üåÄ'];
        spawnFloatingEffect(ePos.x + 12, ePos.y + 6, effects[Math.floor(Math.random() * effects.length)]);
      }
    }
  } else {
    mouse.actionTimer = 1500 + Math.random() * 2000;
  }
}

// Draw status bar at the bottom showing mouse names + actions
function drawMouseStatus() {
  const pip = state.miceState.pip;
  const chai = state.miceState.chai;
  const y = GAME_H - 8;

  ctx.save();
  ctx.font = '10px monospace';
  ctx.textBaseline = 'alphabetic';

  const actionIcons = { sleeping: 'üí§', walking: 'üêæ', zoomies: 'üí®', eating: 'üòã',
    doomscrolling: 'üì±', watching: 'üì∫', yoga: 'üßò', playing: 'üèÉ',
    wheeling: 'üé°', flung: 'üòµ‚Äçüí´', climbing: 'ü™ú', grooming: 'üíÖ', mischief: 'üòà', stretching: 'üôÜ' };

  // Pip status (left)
  const sIcon = actionIcons[pip.action] || '‚ú®';
  let pipText = `${sIcon} ${CONFIG.mice.pip.name}: ${pip.action}`;
  const pipHappy = pip.happiness ?? 80;
  if (pipHappy < 35) pipText += ' üçΩ';
  if (pip.room !== state.currentRoom) {
    pipText += ` (${ROOMS[pip.room].icon})`;
  }
  ctx.fillStyle = pipHappy < 35 ? '#e06050' : '#888';
  ctx.textAlign = 'left';
  ctx.fillText(pipText, 8, y);

  // Chai status (right)
  const cIcon = actionIcons[chai.action] || '‚ú®';
  let chaiText = `${cIcon} ${CONFIG.mice.chai.name}: ${chai.action}`;
  const chaiHappy = chai.happiness ?? 80;
  if (chaiHappy < 35) chaiText += ' üçΩ';
  if (chai.room !== state.currentRoom) {
    chaiText += ` (${ROOMS[chai.room].icon})`;
  }
  ctx.fillStyle = chaiHappy < 35 ? '#e06050' : '#888';
  ctx.textAlign = 'right';
  ctx.fillText(chaiText, GAME_W - 8, y);

  ctx.restore();
}

// ============================================================
// SPEECH BUBBLES & FLOATING EFFECTS
// ============================================================
const PIP_QUOTES = [
  'no thoughts head empty', 'chaos mode activated', 'catch me if you can üí®',
  'it\'s giving... gremlin', 'slay', 'built different tbh', 'caught in 4k üì∏',
  'living my best cheese life', 'zero chill, full send', 'main character energy',
  'this is fine üî•', 'unhinged and unbothered', 'speed run any%', 'yeet',
  'bet', 'say less', 'lowkey feral rn', 'bestie wake up', 'ZOOM', 'not sorry üòà',
  'is there more cheese??', 'snack break? snack break.', 'I smell food üëÉ',
  'built different (and hungry)', 'cheese is a personality trait',
  'what if I just... *pushes thing*', 'crime time üê≠', 'no rules just vibes',
  '*stares at you*', 'u watching me? üëÄ', 'plot twist: I\'m the main character',
  'brb causing problems', '*knocks over cup*', 'the intrusive thoughts won',
  'alexa play despacito', 'I did NOT eat that', 'it was like that when I got here',
  'actually this is MY shelf', 'smol but mighty', 'touch grass? I AM grass',
  'certified hood classic', 'ratio', 'skill issue tbh', 'L + no cheese',
  'just vibing (chaotically)', '*exists aggressively*'
];
const CHAI_QUOTES = [
  'this is giving cozy', 'soft hours only üåô', 'no thoughts, just vibes',
  'not me napping again', 'it\'s giving... mouse', 'sleepy but slay',
  'wholesome content only', 'living slow üêå', 'comfort is key', 'gentle chaos',
  'self care is sleeping', 'cozy era', 'manifesting cheese ‚ú®', 'just existing üí´',
  'zzz is a lifestyle', 'pls don\'t wake me', 'warm thoughts only', 'soft launch üßÄ',
  'cottagecore mouse', 'peace was always an option üïä',
  '*contemplates existence*', 'this room has good energy', 'what a time to be alive',
  'dreaming of cheese rn', 'noted üìù', 'very demure, very mindful',
  'literally just standing here', 'quiet luxury üê≠', 'idk I just live here',
  '*stares into distance*', 'the floor is warm here', 'healing arc üåø',
  'today I choose peace', 'Pip is being chaotic again', '*judges silently*',
  'this is my emotional support room', 'I\'m baby ü•∫', 'nap first, think later',
  'the vibe is immaculate', '*blinks slowly*', 'it me'
];

const WHEEL_QUOTES = [
  'CARDIO üí™', 'fitness era', 'running from my problems',
  'marathon training arc', 'can\'t stop won\'t stop', 'legs go brrr',
  'gym rat? no. gym MOUSE', 'my fitbit is shaking',
  'hot mouse summer prep', 'this counts as a marathon right',
  'i am speed üèÉ', 'wheeeeel!', 'spinning into my best self'
];

let speechBubbles = [];  // { x, y, text, timer, maxTimer, mouseKey }
let floatingEffects = []; // { x, y, text, timer, vy }

let speechCooldown = 5000 + Math.random() * 5000; // 5-10 sec

function triggerSpeech(mouseKey) {
  const mouse = state.miceState[mouseKey];
  if (mouse.room !== state.currentRoom) return;
  let quotes;
  if (mouse.action === 'wheeling') {
    quotes = WHEEL_QUOTES;
  } else {
    // Mix personality quotes with context-sensitive ones
    const base = mouseKey === 'pip' ? PIP_QUOTES : CHAI_QUOTES;
    const contextual = [];
    // Room-specific
    const roomIdx = mouse.room;
    if (roomIdx === 0) contextual.push('bedroom vibes üõè', 'cozy in here', 'nap room best room');
    if (roomIdx === 1) contextual.push('kitchen raid üç≥', 'anything to eat?', 'chef mode');
    if (roomIdx === 2) contextual.push('living room energy', 'tv time?', 'prime hangout spot');
    if (roomIdx === 3) contextual.push('leg day üí™', 'gym arc', 'do I look buff?');
    // Action-specific
    if (mouse.action === 'sleeping') contextual.push('five more minutes...', 'zzz...', 'don\'t wake me');
    if (mouse.action === 'zoomies') contextual.push('CAN\'T STOP üí®', 'SPEEED', 'I\'m fast as heck boi');
    if (mouse.action === 'grooming') contextual.push('glow up era ‚ú®', 'self care sunday', 'mirror mirror');
    // Happiness-dependent
    if ((mouse.happiness ?? 80) > 80) contextual.push('life is good üòä', 'peak happiness', '10/10 no notes');
    if ((mouse.happiness ?? 80) < 25) contextual.push('feed me pls üò©', 'fading...', 'hello? food?');
    // 30% chance of contextual quote if available
    if (contextual.length > 0 && Math.random() < 0.3) {
      quotes = contextual;
    } else {
      quotes = base;
    }
  }
  const text = quotes[Math.floor(Math.random() * quotes.length)];
  speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
  speechBubbles.push({
    x: mouse.x + 14,
    y: getMouseFloorY(mouse) - 10,
    text, timer: 3000, maxTimer: 3000, mouseKey
  });
  sfxSpeechBubble();
}

function updateSpeechBubbles(dt) {
  speechCooldown -= dt;
  if (speechCooldown <= 0) {
    speechCooldown = 5000 + Math.random() * 5000;
    // Pick a random mouse to speak
    const mouseKey = Math.random() < 0.5 ? 'pip' : 'chai';
    triggerSpeech(mouseKey);
  }
  speechBubbles.forEach(b => {
    b.timer -= dt;
    // Track mouse position (handle wheel and flung states)
    const mouse = state.miceState[b.mouseKey];
    if (mouse.action === 'flung' && mouse.flingX !== undefined) {
      b.x = mouse.flingX + 14;
      b.y = mouse.flingY - 10;
    } else if (mouse.action === 'wheeling') {
      const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === mouse.room);
      if (wheelPlaced) {
        const center = getWheelCenter(wheelPlaced);
        b.x = center.x;
        b.y = center.y - 40;
      }
    } else {
      b.x = mouse.x + 14;
      b.y = getMouseFloorY(mouse) - 10;
    }
  });
  speechBubbles = speechBubbles.filter(b => b.timer > 0);
}

function drawSpeechBubbles() {
  speechBubbles.forEach(b => {
    // Only draw bubbles for mice in the currently viewed room
    const mouse = state.miceState[b.mouseKey];
    if (mouse && mouse.room !== state.currentRoom) return;

    const alpha = Math.min(1, b.timer / 500); // fade out last 500ms
    ctx.globalAlpha = alpha;
    ctx.font = '9px monospace';
    const tw = ctx.measureText(b.text).width;
    const pw = tw + 12;
    const ph = 18;
    const px = Math.max(4, Math.min(GAME_W - pw - 4, b.x - pw / 2));
    const py = b.y - ph - 8;

    // Bubble bg
    ctx.fillStyle = 'rgba(255,250,240,0.92)';
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, 6);
    ctx.fill();
    // Bubble border
    ctx.strokeStyle = 'rgba(180,150,100,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, 6);
    ctx.stroke();
    // Tail triangle
    ctx.fillStyle = 'rgba(255,250,240,0.92)';
    ctx.beginPath();
    ctx.moveTo(b.x - 4, py + ph);
    ctx.lineTo(b.x, py + ph + 6);
    ctx.lineTo(b.x + 4, py + ph);
    ctx.fill();
    // Text
    ctx.fillStyle = '#3a2a1a';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.text, px + pw / 2, py + ph / 2);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.globalAlpha = 1.0;
  });
}

function spawnFloatingEffect(x, y, text) {
  floatingEffects.push({ x, y, text, timer: 1200, vy: -0.04 });
}

function updateFloatingEffects(dt) {
  floatingEffects.forEach(e => {
    e.timer -= dt;
    e.y += e.vy * dt;
    e.x += Math.sin(Date.now() / 200 + e.y) * 0.15;
  });
  floatingEffects = floatingEffects.filter(e => e.timer > 0);
}

function drawFloatingEffects() {
  floatingEffects.forEach(e => {
    const alpha = Math.min(1, e.timer / 400);
    ctx.globalAlpha = alpha;
    ctx.font = '14px serif';
    ctx.textAlign = 'center';
    ctx.fillText(e.text, e.x, e.y);
    ctx.textAlign = 'left';
    ctx.globalAlpha = 1.0;
  });
}

// ============================================================
// CLICK-TO-PET
// ============================================================
function tryPetMouse(gx, gy) {
  const mice = [
    { key: 'pip', state: state.miceState.pip, cfg: CONFIG.mice.pip },
    { key: 'chai', state: state.miceState.chai, cfg: CONFIG.mice.chai }
  ];
  for (const m of mice) {
    if (m.state.room !== state.currentRoom) continue;
    const mx = m.state.x;
    const my = getMouseFloorY(m.state);
    if (gx > mx - 5 && gx < mx + 30 && gy > my - 10 && gy < my + 25) {
      // Pet this mouse!
      sfxPet();
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          spawnFloatingEffect(
            mx + 10 + (Math.random() - 0.5) * 20,
            my - 5 - Math.random() * 15,
            ['‚ù§Ô∏è', 'üíï', 'üíñ', 'üíó', 'ü•∞'][Math.floor(Math.random() * 5)]
          );
        }, i * 100);
      }
      // Mouse reacts
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== m.key);
      const petQuotes = m.key === 'pip'
        ? ['okay that\'s nice', 'more pls ü•∫', '*purrs in mouse*', 'acceptable', 'don\'t stop üëÄ', 'feed me tho']
        : ['ü•∞ü•∞ü•∞', 'best day ever', '*happy squeak*', 'i love you', 'this is everything'];
      speechBubbles.push({
        x: mx + 14, y: my - 10,
        text: petQuotes[Math.floor(Math.random() * petQuotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey: m.key
      });
      // Briefly pause their action (they enjoy it)
      m.state.action = 'idle';
      m.state.actionTimer = 2500;
      m.state.happiness = Math.min(100, (m.state.happiness ?? 80) + 5);
      return true;
    }
  }
  return false;
}

// ============================================================
// MOUSE INTERACTIONS (when both in same room)
// ============================================================
let interactionCooldown = 4000 + Math.random() * 4000;

function updateMouseInteractions(dt) {
  const s = state.miceState.pip;
  const c = state.miceState.chai;
  if (s.room !== c.room) { interactionCooldown = 2000 + Math.random() * 2000; return; }

  // Startled reaction: if one mouse zooms past the other
  if (s.action === 'zoomies' && c.action !== 'zoomies' && c.action !== 'sleeping' && c.action !== 'flung') {
    if (Math.abs(s.x - c.x) < 25 && !c._startled) {
      c._startled = true;
      c._startleTimer = 600;
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'chai');
      speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
        text: ['‚ùó', 'AH!', 'omg', 'üò±', 'WHAT', 'excuse me?!', 'RUDE'][Math.floor(Math.random() * 7)],
        timer: 1200, maxTimer: 1200, mouseKey: 'chai' });
    }
  }
  if (c.action === 'zoomies' && s.action !== 'zoomies' && s.action !== 'sleeping' && s.action !== 'flung') {
    if (Math.abs(c.x - s.x) < 25 && !s._startled) {
      s._startled = true;
      s._startleTimer = 600;
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip');
      speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
        text: ['‚ùó', 'AH!', 'bruh', 'üò±', 'HEY', 'personal space!', 'watch it!'][Math.floor(Math.random() * 7)],
        timer: 1200, maxTimer: 1200, mouseKey: 'pip' });
    }
  }
  // Decay startle
  if (s._startled) { s._startleTimer -= dt; if (s._startleTimer <= 0) s._startled = false; }
  if (c._startled) { c._startleTimer -= dt; if (c._startleTimer <= 0) c._startled = false; }

  // Copy-cat behavior: if one starts an action, other might copy
  if (!s._copyCooldown) s._copyCooldown = 0;
  if (!c._copyCooldown) c._copyCooldown = 0;
  s._copyCooldown = Math.max(0, s._copyCooldown - dt);
  c._copyCooldown = Math.max(0, c._copyCooldown - dt);
  const copyActions = ['zoomies', 'grooming', 'sleeping'];
  if (copyActions.includes(s.action) && c.action === 'idle' && c._copyCooldown <= 0 && Math.random() < 0.002) {
    c.action = s.action;
    c.actionTimer = s.actionTimer;
    c.dir = s.dir;
    c._copyCooldown = 10000;
    if (c.room === state.currentRoom) {
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'chai');
      speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
        text: ['me too!', '*copies*', 'monkey see monkey do', 'same tbh', 'mood'][Math.floor(Math.random() * 5)],
        timer: 2000, maxTimer: 2000, mouseKey: 'chai' });
    }
  }
  if (copyActions.includes(c.action) && s.action === 'idle' && s._copyCooldown <= 0 && Math.random() < 0.002) {
    s.action = c.action;
    s.actionTimer = c.actionTimer;
    s.dir = c.dir;
    s._copyCooldown = 10000;
    if (s.room === state.currentRoom) {
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip');
      speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
        text: ['wait me too', '*copies*', 'same energy', 'I also choose this', 'vibe check passed'][Math.floor(Math.random() * 5)],
        timer: 2000, maxTimer: 2000, mouseKey: 'pip' });
    }
  }

  interactionCooldown -= dt;
  if (interactionCooldown > 0) return;
  interactionCooldown = 5000 + Math.random() * 5000;

  const interaction = Math.random();

  if (interaction < 0.18) {
    // Nuzzle/nose-boop: move toward each other, then heart burst
    const midX = (s.x + c.x) / 2;
    s.action = 'walking'; s.targetX = midX - 12; s.dir = 1;
    c.action = 'walking'; c.targetX = midX + 12; c.dir = -1;
    s.actionTimer = 4000; c.actionTimer = 4000;
    setTimeout(() => {
      if (s.room === c.room && s.room === state.currentRoom) {
        const boopX = (s.x + c.x) / 2 + 14;
        const boopY = getMouseFloorY(s) - 5;
        for (let i = 0; i < 4; i++) {
          setTimeout(() => {
            spawnFloatingEffect(boopX + (Math.random() - 0.5) * 20, boopY - Math.random() * 10,
              ['üíï', 'üíñ', '‚ú®', 'ü•∞'][i % 4]);
          }, i * 100);
        }
        triggerSpeech(Math.random() < 0.5 ? 'pip' : 'chai');
      }
    }, 2000);
  } else if (interaction < 0.32) {
    // Play-chase: Pip chases Chai (or vice versa)
    const chaser = Math.random() < 0.6 ? s : c;
    const runner = chaser === s ? c : s;
    const chaserKey = chaser === s ? 'pip' : 'chai';
    const runnerKey = chaser === s ? 'chai' : 'pip';
    runner.action = 'walking';
    runner.targetX = Math.random() < 0.5 ? 40 : ROOM_W - 60;
    runner.dir = runner.targetX > runner.x ? 1 : -1;
    runner.actionTimer = 4000;
    chaser.action = 'walking';
    chaser.dir = runner.dir;
    chaser.actionTimer = 4000;
    setTimeout(() => {
      chaser.targetX = runner.targetX + (Math.random() < 0.5 ? -20 : 20);
    }, 400);
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== chaserKey);
    speechBubbles.push({
      x: chaser.x + 14, y: getMouseFloorY(chaser) - 10,
      text: chaserKey === 'pip' ? 'get back here! üí®' : 'wheee! üèÉ',
      timer: 2000, maxTimer: 2000, mouseKey: chaserKey
    });
    // Runner reacts
    setTimeout(() => {
      if (runner.room === state.currentRoom) {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== runnerKey);
        speechBubbles.push({ x: runner.x + 14, y: getMouseFloorY(runner) - 10,
          text: ['you\'ll never catch me!', 'NOT AGAIN', '*screeee*', 'help! üòÇ', 'faster! üí®'][Math.floor(Math.random() * 5)],
          timer: 2000, maxTimer: 2000, mouseKey: runnerKey });
      }
    }, 800);
  } else if (interaction < 0.42) {
    // Synchronized sleeping: both curl up nearby
    if (s.action !== 'wheeling' && c.action !== 'wheeling') {
      const napX = 100 + Math.random() * (ROOM_W - 200);
      s.action = 'walking'; s.targetX = napX - 20; s.dir = 1; s.actionTimer = 3000;
      c.action = 'walking'; c.targetX = napX + 10; c.dir = -1; c.actionTimer = 3000;
      setTimeout(() => {
        if (s.room === c.room) {
          s.action = 'sleeping'; s.actionTimer = 4000 + Math.random() * 2000;
          c.action = 'sleeping'; c.actionTimer = 4000 + Math.random() * 2000;
          if (s.room === state.currentRoom) {
            spawnFloatingEffect((s.x + c.x) / 2 + 14, getMouseFloorY(s) - 15, 'üò¥');
          }
        }
      }, 2500);
    }
  } else if (interaction < 0.52) {
    // Play-grooming: one grooms the other
    const groomer = Math.random() < 0.5 ? s : c;
    const groomee = groomer === s ? c : s;
    const groomerKey = groomer === s ? 'pip' : 'chai';
    const groomeeKey = groomer === s ? 'chai' : 'pip';
    groomer.action = 'walking';
    groomer.targetX = groomee.x + (groomer.x > groomee.x ? 15 : -15);
    groomer.dir = groomee.x > groomer.x ? 1 : -1;
    groomer.actionTimer = 5000;
    setTimeout(() => {
      if (groomer.room === groomee.room) {
        groomer.action = 'grooming';
        groomer.actionTimer = 3000;
        groomer.dir = groomee.x > groomer.x ? 1 : -1;
        groomee.action = 'idle';
        groomee.actionTimer = 3000;
        if (groomer.room === state.currentRoom) {
          speechBubbles = speechBubbles.filter(b => b.mouseKey !== groomeeKey);
          speechBubbles.push({ x: groomee.x + 14, y: getMouseFloorY(groomee) - 10,
            text: ['thx bestie ü•∫', 'aww', 'don\'t stop', 'ü•∞', 'this is nice'][Math.floor(Math.random() * 5)],
            timer: 2500, maxTimer: 2500, mouseKey: groomeeKey });
        }
      }
    }, 1500);
  } else if (interaction < 0.62) {
    // Synchronized zoomies ‚Äî both go wild
    if (s.action !== 'wheeling' && c.action !== 'wheeling') {
      s.action = 'zoomies'; s.actionTimer = 2500 + Math.random() * 1500;
      c.action = 'zoomies'; c.actionTimer = 2500 + Math.random() * 1500;
      s.dir = 1; c.dir = -1;
      if (s.room === state.currentRoom) {
        sfxZoomies();
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip' && b.mouseKey !== 'chai');
        speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
          text: ['ZOOMIES!!! üí®', 'RACE!! üèÅ', 'CAN\'T STOP'][Math.floor(Math.random() * 3)],
          timer: 2000, maxTimer: 2000, mouseKey: 'pip' });
        speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
          text: ['WHEEE!', 'SO FAST!', 'NYOOOM üí®'][Math.floor(Math.random() * 3)],
          timer: 2000, maxTimer: 2000, mouseKey: 'chai' });
      }
    }
  } else if (interaction < 0.72) {
    // Stolen food drama ‚Äî one mouse walks to the other and they have a "moment"
    const thief = Math.random() < 0.6 ? s : c;
    const victim = thief === s ? c : s;
    const thiefKey = thief === s ? 'pip' : 'chai';
    const victimKey = thief === s ? 'chai' : 'pip';
    thief.action = 'walking';
    thief.targetX = victim.x + (thief.x > victim.x ? 15 : -15);
    thief.dir = victim.x > thief.x ? 1 : -1;
    thief.actionTimer = 4000;
    setTimeout(() => {
      if (thief.room === victim.room && thief.room === state.currentRoom) {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== thiefKey);
        speechBubbles.push({ x: thief.x + 14, y: getMouseFloorY(thief) - 10,
          text: thiefKey === 'pip'
            ? ['gimme your cheese üßÄ', '*steals snack*', 'what\'s yours is mine', 'sharing is caring (for me)'][Math.floor(Math.random() * 4)]
            : ['that\'s MY spot', '*claims territory*', 'excuse me this is taken', 'mine now üò§'][Math.floor(Math.random() * 4)],
          timer: 2500, maxTimer: 2500, mouseKey: thiefKey });
        setTimeout(() => {
          if (victim.room === state.currentRoom) {
            speechBubbles = speechBubbles.filter(b => b.mouseKey !== victimKey);
            speechBubbles.push({ x: victim.x + 14, y: getMouseFloorY(victim) - 10,
              text: ['hey! üò†', 'not cool', 'RUDE', 'I\'m telling', '...wow'][Math.floor(Math.random() * 5)],
              timer: 2500, maxTimer: 2500, mouseKey: victimKey });
          }
        }, 1000);
      }
    }, 1500);
  } else if (interaction < 0.82) {
    // Staring contest ‚Äî both face each other and just... stare
    const midX = (s.x + c.x) / 2;
    s.dir = c.x > s.x ? 1 : -1;
    c.dir = s.x > c.x ? 1 : -1;
    s.action = 'idle'; s.actionTimer = 4000;
    c.action = 'idle'; c.actionTimer = 4000;
    if (s.room === state.currentRoom) {
      setTimeout(() => {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip');
        speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
          text: ['üëÅüëÅ', '...', 'don\'t blink', '*stares*', 'ü§®'][Math.floor(Math.random() * 5)],
          timer: 3000, maxTimer: 3000, mouseKey: 'pip' });
      }, 500);
      setTimeout(() => {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'chai');
        speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
          text: ['...what', 'stop it', 'üòê', '*blinks*', 'I win'][Math.floor(Math.random() * 5)],
          timer: 3000, maxTimer: 3000, mouseKey: 'chai' });
      }, 1500);
    }
  } else if (interaction < 0.92) {
    // Judging: one mouse stares at the other
    const judger = Math.random() < 0.6 ? s : c;
    const judgerKey = judger === s ? 'pip' : 'chai';
    judger.action = 'idle';
    judger.actionTimer = 4000;
    judger.dir = (judger === s ? c.x : s.x) > judger.x ? 1 : -1;
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== judgerKey);
    speechBubbles.push({
      x: judger.x + 14, y: getMouseFloorY(judger) - 10,
      text: judgerKey === 'pip'
        ? ['sus ü§®', 'cringe', 'who asked?', 'bruh', 'oof'][Math.floor(Math.random() * 5)]
        : ['rude', 'don\'t look at me', 'why tho', 'üòê', 'I saw that'][Math.floor(Math.random() * 5)],
      timer: 3000, maxTimer: 3000, mouseKey: judgerKey
    });
  } else {
    // 4th wall break ‚Äî mouse looks at the player
    const breaker = Math.random() < 0.5 ? s : c;
    const breakerKey = breaker === s ? 'pip' : 'chai';
    breaker.action = 'idle';
    breaker.actionTimer = 3000;
    if (breaker.room === state.currentRoom) {
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== breakerKey);
      speechBubbles.push({
        x: breaker.x + 14, y: getMouseFloorY(breaker) - 10,
        text: breakerKey === 'pip'
          ? ['are you watching me? üëÄ', 'hi human!', '*waves*', 'buy me cheese pls', 'why are you just standing there'][Math.floor(Math.random() * 5)]
          : ['oh hi ü•∫', 'don\'t mind me', '*acknowledges your existence*', 'are we the game?', 'we see you'][Math.floor(Math.random() * 5)],
        timer: 3000, maxTimer: 3000, mouseKey: breakerKey
      });
    }
  }
}
// ============================================================
// EDGE NAVIGATION ‚Äî hover arrows + swipe
// ============================================================
const EDGE_ZONE = 40; // px in game coords
let edgeHover = 0; // -1 = left edge, 0 = none, 1 = right edge
let roomSwipeStart = null;

function drawEdgeArrows() {
  if (roomTransition.active || cheeseChaseActive || mouseMazeActive) return;
  if (edgeHover === 0) return;
  const arrowX = edgeHover > 0 ? GAME_W - 22 : 22;
  const arrowY = ROOM_Y + ROOM_H / 2;
  const arrowChar = edgeHover > 0 ? '‚ñ∂' : '‚óÄ';
  // Translucent pill background
  ctx.save();
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = 'rgba(30,20,10,0.7)';
  ctx.beginPath();
  ctx.roundRect(arrowX - 14, arrowY - 18, 28, 36, 8);
  ctx.fill();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = '#f5d68a';
  ctx.font = 'bold 20px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(arrowChar, arrowX, arrowY);
  ctx.restore();
}

canvas.addEventListener('mousedown', e => handleCanvasInput(e.clientX, e.clientY, e));
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  const pos = screenToGame(t.clientX, t.clientY);
  // Start swipe tracking (only in main game, not mini-games)
  if (!cheeseChaseActive && !mouseMazeActive) {
    roomSwipeStart = { x: pos.x, y: pos.y, time: Date.now() };
  }
  handleCanvasInput(t.clientX, t.clientY, e);
}, { passive: false });

function handleCanvasInput(sx, sy, originalEvent) {
  const pos = screenToGame(sx, sy);

  // Cheese Chase input
  if (cheeseChaseActive) {
    if (cc.gameOver) {
      endCheeseChase();
      return;
    }
    ccInputY = pos.y;
    return;
  }

  // Mouse Maze input
  if (mouseMazeActive) {
    handleMazeInput(sx, sy);
    mazeSwipeBegin(pos.x, pos.y);
    return;
  }

  // Edge arrow click ‚Äî navigate to adjacent room
  if (!roomTransition.active && pos.y >= ROOM_Y && pos.y <= ROOM_Y + ROOM_H) {
    if (pos.x < EDGE_ZONE) { switchRoom(roomLeft(state.currentRoom)); return; }
    if (pos.x > GAME_W - EDGE_ZONE) { switchRoom(roomRight(state.currentRoom)); return; }
  }

  // Check if clicking/touching a placed item to pick it up for repositioning
  const placedIdx = findPlacedItemAt(pos.x, pos.y);
  if (placedIdx >= 0) {
    const placed = state.placedItems[placedIdx];
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (item && !item.exerciseRoom) {
      startDrag(placed.itemId, sx, sy, true, placedIdx);
      return;
    }
  }

  // Try petting a mouse
  if (tryPetMouse(pos.x, pos.y)) return;

  // Light dismiss: clicking empty canvas area closes shop flyout
  if (state.shopOpen && !state.placementMode && !state.dragState.active) {
    closeShopFlyout();
    return;
  }
}

// Double-click on placed furniture to reposition (opens shop if needed)
// Double-click on status bar room icon to jump to that mouse's room
canvas.addEventListener('dblclick', e => {
  if (cheeseChaseActive || mouseMazeActive) return;
  const pos = screenToGame(e.clientX, e.clientY);

  // Check status bar area (bottom 20px) ‚Äî double-click room icon to jump
  if (pos.y > GAME_H - 20) {
    const pip = state.miceState.pip;
    const chai = state.miceState.chai;
    if (pos.x < GAME_W / 2 && pip.room !== state.currentRoom) {
      switchRoom(pip.room);
      showToast(`Jumped to ${CONFIG.mice.pip.name} in ${ROOMS[pip.room].icon} ${ROOMS[pip.room].name}`);
      return;
    }
    if (pos.x >= GAME_W / 2 && chai.room !== state.currentRoom) {
      switchRoom(chai.room);
      showToast(`Jumped to ${CONFIG.mice.chai.name} in ${ROOMS[chai.room].icon} ${ROOMS[chai.room].name}`);
      return;
    }
    return;
  }

  // Furniture reposition
  const placedIdx = findPlacedItemAt(pos.x, pos.y);
  if (placedIdx < 0) return;
  const placed = state.placedItems[placedIdx];
  const item = FURNITURE.find(f => f.id === placed.itemId);
  if (!item || item.exerciseRoom) return;
  if (!state.shopOpen) {
    state.shopOpen = true;
    refreshShopFlyout();
    refreshItemTray();
    document.getElementById('shop-flyout').classList.add('open');
    document.getElementById('item-tray').classList.add('open');
    if (gamesOpen) closeGamesFlyout();
  }
  startDrag(placed.itemId, e.clientX, e.clientY, true, placedIdx);
});

canvas.addEventListener('mousemove', e => {
  if (cheeseChaseActive && !cc.gameOver) ccInputY = screenToGame(e.clientX, e.clientY).y;
  if (state.dragState.active) updateDrag(e.clientX, e.clientY);
  // Track edge hover for navigation arrows
  if (!cheeseChaseActive && !mouseMazeActive && !roomTransition.active) {
    const pos = screenToGame(e.clientX, e.clientY);
    if (pos.y >= ROOM_Y && pos.y <= ROOM_Y + ROOM_H) {
      if (pos.x < EDGE_ZONE) edgeHover = -1;
      else if (pos.x > GAME_W - EDGE_ZONE) edgeHover = 1;
      else edgeHover = 0;
    } else {
      edgeHover = 0;
    }
  }
});
canvas.addEventListener('mouseleave', () => { edgeHover = 0; });
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (cheeseChaseActive && !cc.gameOver) ccInputY = screenToGame(e.touches[0].clientX, e.touches[0].clientY).y;
  if (state.dragState.active) updateDrag(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

canvas.addEventListener('mouseup', e => {
  if (mouseMazeActive && mazeSwipeStart) {
    const pos = screenToGame(e.clientX, e.clientY);
    mazeSwipeEnd(pos.x, pos.y);
  }
});
canvas.addEventListener('touchend', e => {
  if (mouseMazeActive && mazeSwipeStart) {
    const t = e.changedTouches[0];
    const pos = screenToGame(t.clientX, t.clientY);
    mazeSwipeEnd(pos.x, pos.y);
  }
  // Room swipe detection
  if (roomSwipeStart && !cheeseChaseActive && !mouseMazeActive && !roomTransition.active) {
    const t = e.changedTouches[0];
    const pos = screenToGame(t.clientX, t.clientY);
    const dx = pos.x - roomSwipeStart.x;
    const elapsed = Date.now() - roomSwipeStart.time;
    // Require minimum 50px swipe within 500ms
    if (Math.abs(dx) > 50 && elapsed < 500) {
      if (dx < 0) switchRoom(roomRight(state.currentRoom)); // swipe left ‚Üí next room
      else switchRoom(roomLeft(state.currentRoom));          // swipe right ‚Üí prev room
    }
  }
  roomSwipeStart = null;
});

document.addEventListener('keydown', e => {
  if (cheeseChaseActive && !cc.gameOver) {
    if (e.key === 'ArrowUp' || e.key === 'w') cc.mouseY -= 10;
    if (e.key === 'ArrowDown' || e.key === 's') cc.mouseY += 10;
  }
  if (mouseMazeActive && !mz.levelComplete && !mz.gameOver) {
    if (e.key === 'ArrowUp' || e.key === 'w') { e.preventDefault(); mz.moveQueue.push('up'); }
    if (e.key === 'ArrowDown' || e.key === 's') { e.preventDefault(); mz.moveQueue.push('down'); }
    if (e.key === 'ArrowLeft' || e.key === 'a') { e.preventDefault(); mz.moveQueue.push('left'); }
    if (e.key === 'ArrowRight' || e.key === 'd') { e.preventDefault(); mz.moveQueue.push('right'); }
  }
});

// ============================================================
// TITLE SCREEN ‚Äî draw mice and spawn floating particles
// ============================================================
(function initTitleScreen() {
  // Animate title mice using the same drawMouse() as the game
  const pipCanvas = document.getElementById('title-pip');
  const chaiCanvas = document.getElementById('title-chai');
  if (!pipCanvas || !chaiCanvas) return;
  const pipCtx = pipCanvas.getContext('2d');
  const chaiCtx = chaiCanvas.getContext('2d');
  const savedCtx = ctx;
  let titleAnimId = null;

  function animateTitleMice() {
    const t = Date.now() / 1000;
    const frame = Math.floor(t * 3) % 4;

    // Pip ‚Äî walking, facing right
    const pipAction = Math.sin(t * 0.4) > 0.3 ? 'zoomies' : (Math.sin(t * 0.7) > 0.6 ? 'grooming' : 'walking');
    pipCtx.save();
    pipCtx.setTransform(1, 0, 0, 1, 0, 0);
    pipCtx.clearRect(0, 0, 200, 160);
    pipCtx.translate(100, 85);
    pipCtx.scale(3, 3);
    pipCtx.translate(-14, -12);
    ctx = pipCtx;
    drawMouse(0, 0, CONFIG.mice.pip, 1, frame, pipAction, false);
    ctx = savedCtx;
    pipCtx.restore();

    // Chai ‚Äî idle/grooming, facing left
    const chaiAction = Math.sin(t * 0.3 + 1) > 0.4 ? 'idle' : (Math.sin(t * 0.5 + 2) > 0.5 ? 'grooming' : 'walking');
    chaiCtx.save();
    chaiCtx.setTransform(1, 0, 0, 1, 0, 0);
    chaiCtx.clearRect(0, 0, 200, 160);
    chaiCtx.translate(100, 85);
    chaiCtx.scale(3, 3);
    chaiCtx.translate(-14, -12);
    ctx = chaiCtx;
    drawMouse(0, 0, CONFIG.mice.chai, -1, frame, chaiAction, false);
    ctx = savedCtx;
    chaiCtx.restore();

    if (!state.gameStarted) {
      titleAnimId = requestAnimationFrame(animateTitleMice);
    }
  }
  animateTitleMice();

  // Spawn floating particles
  const titleEl = document.getElementById('title-screen');
  const emojis = ['üßÄ','‚ú®','üíï','üê≠','üåô','‚≠ê','üß∂','üçû','‚òï'];
  for (let i = 0; i < 12; i++) {
    const span = document.createElement('span');
    span.className = 'title-particle';
    span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    span.style.left = (5 + Math.random() * 90) + '%';
    span.style.bottom = (-10 - Math.random() * 20) + '%';
    span.style.animationDelay = (Math.random() * 6) + 's';
    span.style.animationDuration = (5 + Math.random() * 4) + 's';
    span.style.fontSize = (14 + Math.random() * 10) + 'px';
    titleEl.appendChild(span);
  }
})();

// Title screen ambient sound
let titleAudioCtx = null;
let titleMusicPlaying = false;
let titleMusicTimeout = null;
let titleMuted = false;

function initTitleAudio() {
  if (titleAudioCtx) return;
  titleAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

const TITLE_MELODY = [
  [392, 600], [330, 400], [294, 400], [262, 800], [0, 300],
  [294, 400], [330, 400], [392, 600], [330, 800], [0, 400],
  [262, 400], [294, 400], [330, 600], [392, 400], [330, 800], [0, 600],
];
let titleNoteIdx = 0;

function startTitleMusic() {
  if (!titleAudioCtx || titleMusicPlaying) return;
  titleMusicPlaying = true;
  titleNoteIdx = 0;
  playTitleNote();
}

function stopTitleMusic() {
  titleMusicPlaying = false;
  if (titleMusicTimeout) clearTimeout(titleMusicTimeout);
}

function playTitleNote() {
  if (!titleMusicPlaying || titleMuted) { titleMusicPlaying = false; return; }
  const [freq, dur] = TITLE_MELODY[titleNoteIdx % TITLE_MELODY.length];
  titleNoteIdx++;
  if (freq > 0) {
    const osc = titleAudioCtx.createOscillator();
    const g = titleAudioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0, titleAudioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.05, titleAudioCtx.currentTime + 0.05);
    g.gain.setTargetAtTime(0, titleAudioCtx.currentTime + (dur / 1000) * 0.5, (dur / 1000) * 0.2);
    osc.connect(g); g.connect(titleAudioCtx.destination);
    osc.start(titleAudioCtx.currentTime);
    osc.stop(titleAudioCtx.currentTime + dur / 1000 + 0.15);
  }
  titleMusicTimeout = setTimeout(playTitleNote, dur);
}

function toggleTitleMute() {
  titleMuted = !titleMuted;
  const btn = document.getElementById('title-mute-btn');
  btn.textContent = titleMuted ? 'üîá Sound' : 'üîä Sound';
  if (titleMuted) {
    stopTitleMusic();
  } else {
    initTitleAudio();
    startTitleMusic();
  }
}

function toggleTitleAbout() {
  const overlay = document.getElementById('title-about-overlay');
  overlay.classList.toggle('visible');
}
function closeTitleAbout() {
  document.getElementById('title-about-overlay').classList.remove('visible');
}

// Start title music on first interaction (to satisfy autoplay policy)
let titleAudioStarted = false;
document.getElementById('title-screen').addEventListener('mousedown', () => {
  if (!titleAudioStarted) {
    titleAudioStarted = true;
    if (!titleMuted) { initTitleAudio(); startTitleMusic(); }
  }
}, { once: false });
document.getElementById('title-screen').addEventListener('touchstart', () => {
  if (!titleAudioStarted) {
    titleAudioStarted = true;
    if (!titleMuted) { initTitleAudio(); startTitleMusic(); }
  }
}, { passive: true });

document.getElementById('title-screen').addEventListener('click', e => {
  // Don't start game if about overlay is showing or clicking buttons
  if (document.getElementById('title-about-overlay').classList.contains('visible')) return;
  startGame();
});
document.getElementById('title-screen').addEventListener('touchstart', e => {
  if (document.getElementById('title-about-overlay').classList.contains('visible')) return;
  if (e.target.closest('.title-buttons')) return;
  e.preventDefault();
  // Start title audio on first touch
  if (!titleAudioStarted) {
    titleAudioStarted = true;
    if (!titleMuted) { initTitleAudio(); startTitleMusic(); }
  }
  startGame();
}, { passive: false });

// ============================================================
// GAME START
// ============================================================
function startGame() {
  if (state.gameStarted) return;
  state.gameStarted = true;
  stopTitleMusic();
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('title-about-overlay').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('tray-toggle').style.display = 'flex';
  loadGame();
  loadAudioPrefs();
  initAudio();
  updateCoinDisplay();
  updateHappinessDisplay();
  updateGoalDisplay();
  buildRoomTabs();
  // Re-fit canvas now that HUD is visible (mobile needs HUD height)
  resizeCanvas();
  initParticles();
  ensureExerciseRoomSetup();
  triggerBirthdayEvent();
  if (!audioMuted) startMusic();
}

// ============================================================
// MAIN LOOP
// ============================================================
let lastTime = performance.now();

function gameLoop(now) {
  const dt = Math.min(now - lastTime, 50);
  lastTime = now;

  if (state.gameStarted) {
    if (cheeseChaseActive) {
      updateCheeseChase(dt);
      updateFloatingEffects(dt);
      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawCheeseChase();
    } else if (mouseMazeActive) {
      updateMouseMaze(dt);
      updateFloatingEffects(dt);
      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawMouseMaze();
    } else {
      updateParticles(dt);
      updateMouse(state.miceState.pip, dt, CONFIG.mice.pip.personality);
      updateMouse(state.miceState.chai, dt, CONFIG.mice.chai.personality);
      updateSpeechBubbles(dt);
      updateFloatingEffects(dt);
      updateMouseInteractions(dt);
      updateHappiness(dt);
      updateGoals(dt);
      updateExerciseWheel(dt);

      ctx.clearRect(0, 0, GAME_W, GAME_H);

      // Room slide transition
      if (roomTransition.active) {
        roomTransition.progress += dt;
        const t = Math.min(1, roomTransition.progress / roomTransition.duration);
        // Ease-out cubic for smooth deceleration
        const ease = 1 - Math.pow(1 - t, 3);
        // dir: +1 = moving right on ring ‚Üí rooms slide LEFT
        const slideOffset = ease * GAME_W * roomTransition.dir;
        drawRoomScene(roomTransition.from, -slideOffset);
        drawRoomScene(roomTransition.to, GAME_W * roomTransition.dir - slideOffset);
        if (t >= 1) roomTransition.active = false;
      } else {
        drawRoom(state.currentRoom);

        // Draw mice in current room (skip mice on the wheel or flung ‚Äî drawn separately)
        const pip = state.miceState.pip;
        const chai = state.miceState.chai;
        const pipFloorY = getMouseFloorY(pip);
        const chaiFloorY = getMouseFloorY(chai);
        if (pip.room === state.currentRoom && pip.action !== 'wheeling') {
          if (pip.action === 'flung') {
            drawFlungMouse(pip, CONFIG.mice.pip);
          } else {
            drawMouse(pip.x, pipFloorY, CONFIG.mice.pip, pip.dir, pip.frame, pip.action, pip._startled);
          }
          drawPartyHat(pip.action === 'flung' ? pip.flingX : pip.x,
                       pip.action === 'flung' ? pip.flingY : pipFloorY, pip.action, pip.dir, CONFIG.mice.pip);
        }
        if (chai.room === state.currentRoom && chai.action !== 'wheeling') {
          if (chai.action === 'flung') {
            drawFlungMouse(chai, CONFIG.mice.chai);
          } else {
            drawMouse(chai.x, chaiFloorY, CONFIG.mice.chai, chai.dir, chai.frame, chai.action, chai._startled);
          }
          drawPartyHat(chai.action === 'flung' ? chai.flingX : chai.x,
                       chai.action === 'flung' ? chai.flingY : chaiFloorY, chai.action, chai.dir, CONFIG.mice.chai);
        }
      }

      drawSpeechBubbles();
      drawFloatingEffects();
      drawEdgeArrows();
      drawMouseStatus();
    }
  }

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
