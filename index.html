<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>üê≠ Mouse House</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%; overflow: hidden;
  background: #2b1d0e;
  font-family: 'Courier New', monospace;
}
#gameCanvas {
  display: block; margin: 0 auto;
  image-rendering: pixelated; image-rendering: crisp-edges;
  cursor: pointer;
}

/* ---- HUD ---- */
#hud {
  position: absolute; top: 0; left: 0; width: 100%;
  display: none; flex-direction: column;
  background: rgba(30,20,10,0.85);
  color: #f5d68a; font-size: 16px; z-index: 10;
  border-bottom: 2px solid #a07040;
}
#hud-row1 {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 12px;
}
#hud-row2 {
  display: none; text-align: center; padding: 3px 12px 5px;
  border-top: 1px solid rgba(160,112,64,0.3);
}
#hud-row2.visible { display: block; }
#goal-display {
  font-size: 13px; color: #e8d5b5; white-space: normal;
  line-height: 1.3;
}
#hud button {
  background: #3d2b1a; color: #f5d68a; border: 2px solid #a07040;
  padding: 5px 12px; font-family: 'Courier New', monospace; font-size: 13px;
  cursor: pointer; border-radius: 4px; margin-left: 5px;
  transition: background 0.15s;
}
#hud button:hover { background: #5a3d24; }
#hud button.active { background: #f5d68a; color: #2b1d0e; }
.room-tabs { display: flex; gap: 3px; }
.room-tabs button { font-size: 12px; padding: 4px 10px; }
.hud-right { display: flex; align-items: center; gap: 2px; }

/* ---- Modals ---- */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.8); display: flex; justify-content: center;
  align-items: center; z-index: 100;
}
.modal-content {
  background: #3d2b1a; border: 3px solid #f5d68a; border-radius: 12px;
  padding: 20px; max-width: 90vw; max-height: 85vh; overflow-y: auto;
  color: #e8d5b5; font-family: 'Courier New', monospace;
}
.modal-content h2 { color: #f5d68a; text-align: center; margin-bottom: 12px; }
.modal-content .close-btn {
  display: block; margin: 12px auto 0; background: #f5d68a; color: #2b1d0e;
  border: none; padding: 8px 24px; font-size: 16px; cursor: pointer;
  border-radius: 4px; font-family: 'Courier New', monospace; font-weight: bold;
}
.modal-content .close-btn:hover { background: #ffe4a0; }

/* ---- Shop grid ---- */
.shop-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px; margin: 10px 0;
}
.shop-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 10px; text-align: center; cursor: pointer; transition: border-color 0.2s;
}
.shop-item:hover { border-color: #f5d68a; }
.shop-item.owned { border-color: #7bc67e; opacity: 0.7; }
.shop-item .item-icon { font-size: 28px; margin-bottom: 4px; }
.shop-item .item-name { color: #f5d68a; font-size: 12px; font-weight: bold; }
.shop-item .item-desc { color: #a89070; font-size: 10px; margin: 4px 0; }
.shop-item .item-price { color: #f5d68a; font-size: 14px; font-weight: bold; }

/* ---- Minigame buttons ---- */
.minigame-btn {
  display: block; width: 80%; margin: 8px auto; padding: 12px;
  background: #2b1d0e; border: 2px solid #f5d68a; color: #f5d68a;
  font-family: 'Courier New', monospace; font-size: 14px; cursor: pointer;
  border-radius: 6px; text-align: center;
}
.minigame-btn:hover { background: #5a3d24; }

/* ---- Toast ---- */
#toast {
  position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
  background: rgba(30,20,10,0.92); color: #f5d68a; padding: 10px 22px;
  border-radius: 8px; font-size: 14px; pointer-events: none;
  opacity: 0; transition: opacity 0.3s; z-index: 50; text-align: center;
  border: 1px solid #a07040; max-width: 90vw;
  font-family: 'Courier New', monospace;
}
#toast.show { opacity: 1; }

/* ---- Placement bar (legacy, hidden) ---- */
#placement-bar { display: none !important; }

/* ---- Shop Flyout Panel ---- */
#shop-flyout, #games-flyout {
  position: fixed; top: 0; right: 0; width: 280px; height: 100%;
  background: rgba(30,20,10,0.95); border-left: 2px solid #a07040;
  z-index: 30; transform: translateX(100%); transition: transform 0.3s ease;
  display: flex; flex-direction: column; font-family: 'Courier New', monospace;
  overflow: hidden;
}
#shop-flyout.open, #games-flyout.open { transform: translateX(0); }
#shop-flyout .flyout-header {
  padding: 10px 14px; border-bottom: 2px solid #a07040;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0;
}
#shop-flyout .flyout-header h2 { color: #f5d68a; font-size: 16px; margin: 0; }
#shop-flyout .flyout-close {
  background: none; border: none; color: #f5d68a; font-size: 20px;
  cursor: pointer; padding: 2px 6px; line-height: 1;
}
#shop-flyout .flyout-coins {
  text-align: center; color: #a89070; font-size: 12px; padding: 6px 14px;
  border-bottom: 1px solid rgba(160,112,64,0.3); flex-shrink: 0;
}
#shop-flyout .flyout-coins strong { color: #f5d68a; }
#shop-flyout .flyout-items {
  flex: 1; overflow-y: auto; padding: 8px;
  display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
  align-content: start;
}
#shop-flyout .flyout-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 6px;
  padding: 8px 4px; text-align: center; cursor: pointer;
  transition: border-color 0.15s, background 0.15s;
}
#shop-flyout .flyout-item:hover { border-color: #f5d68a; }
#shop-flyout .flyout-item.owned { border-color: #7bc67e; }
#shop-flyout .flyout-item.cant-afford { opacity: 0.35; cursor: not-allowed; }
#shop-flyout .flyout-item .fi-icon { font-size: 22px; }
#shop-flyout .flyout-item .fi-name { color: #f5d68a; font-size: 10px; font-weight: bold; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#shop-flyout .flyout-item .fi-price { color: #a89070; font-size: 10px; margin-top: 2px; }
#shop-flyout .flyout-item.owned .fi-price { color: #7bc67e; }
#shop-flyout .flyout-footer {
  padding: 8px 14px; border-top: 2px solid #a07040; flex-shrink: 0;
  text-align: center;
}
#shop-flyout .flyout-footer button {
  background: #3d2b1a; color: #f5d68a; border: 2px solid #a07040;
  padding: 6px 14px; cursor: pointer; border-radius: 4px;
  font-family: 'Courier New', monospace; font-size: 12px; width: 100%;
  margin-bottom: 4px;
}
#shop-flyout .flyout-footer button:hover { background: #5a3d24; }
#shop-flyout .flyout-footer .loot-info { color: #a89070; font-size: 9px; margin-top: 2px; }

/* ---- Games Flyout ---- */
#games-flyout .flyout-header {
  padding: 10px 14px; border-bottom: 2px solid #a07040;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0;
}
#games-flyout .flyout-header h2 { color: #f5d68a; font-size: 16px; margin: 0; }
#games-flyout .flyout-close {
  background: none; border: none; color: #f5d68a; font-size: 20px;
  cursor: pointer; padding: 2px 6px; line-height: 1;
}
#games-flyout .flyout-subtitle {
  text-align: center; color: #a89070; font-size: 11px; padding: 6px 14px;
  border-bottom: 1px solid rgba(160,112,64,0.3); flex-shrink: 0;
}
#games-flyout .game-list {
  flex: 1; overflow-y: auto; padding: 10px 14px;
  display: flex; flex-direction: column; gap: 8px;
}
#games-flyout .game-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 12px; cursor: pointer; transition: border-color 0.15s, background 0.15s;
}
#games-flyout .game-item:hover { border-color: #f5d68a; background: #3d2b1a; }
#games-flyout .game-item .gi-title { color: #f5d68a; font-size: 14px; font-weight: bold; }
#games-flyout .game-item .gi-desc { color: #a89070; font-size: 10px; margin-top: 4px; }

/* ---- Item Tray (bottom palette) ---- */
#item-tray {
  position: fixed; bottom: 0; left: 0; width: 100%; height: 72px;
  background: rgba(30,20,10,0.92); border-top: 2px solid #a07040;
  z-index: 30; display: none; overflow-x: auto; overflow-y: hidden;
  white-space: nowrap; padding: 6px 10px;
  -webkit-overflow-scrolling: touch;
}
#item-tray.open { display: flex; align-items: center; gap: 6px; }
.tray-item {
  display: inline-flex; flex-direction: column; align-items: center;
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 6px;
  padding: 4px 8px; cursor: grab; user-select: none; -webkit-user-select: none;
  flex-shrink: 0; min-width: 56px; transition: border-color 0.15s;
}
.tray-item:hover { border-color: #f5d68a; }
.tray-item.active { border-color: #f5d68a; background: #3d2b1a; }
.tray-item .ti-icon { font-size: 20px; pointer-events: none; }
.tray-item .ti-name { font-size: 8px; color: #a89070; pointer-events: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 50px; }

/* ---- Trash Zone ---- */
#trash-zone {
  position: fixed; bottom: 0; left: 50%; transform: translateX(-50%);
  width: 120px; height: 50px; background: rgba(200,50,50,0.7);
  border: 2px dashed #ff6666; border-radius: 10px 10px 0 0;
  z-index: 31; display: none; justify-content: center; align-items: center;
  color: #fff; font-size: 24px; font-family: 'Courier New', monospace;
  pointer-events: none;
}
#trash-zone.visible { display: flex; }
#trash-zone.hover { background: rgba(200,50,50,0.95); border-color: #ff4444; }

/* ---- Birthday letter ---- */
.letter-content {
  background: #f5f0dc; color: #333; padding: 20px; border-radius: 8px;
  font-family: Georgia, serif; font-size: 15px; line-height: 1.6;
  max-width: 400px; margin: 0 auto;
}
.letter-content h3 { text-align: center; margin-bottom: 10px; color: #8b4513; }

/* ---- Title screen ---- */
#title-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: #2b1d0e; display: flex; flex-direction: column;
  justify-content: center; align-items: center; z-index: 200;
  cursor: pointer;
}
#title-screen h1 {
  color: #f5d68a; font-size: 38px; margin-bottom: 6px;
  text-shadow: 2px 2px 0 #1a0f05, 0 0 20px rgba(245,214,138,0.3);
}
#title-screen .subtitle { color: #a89070; font-size: 15px; margin-bottom: 30px; }
#title-screen .start-text {
  color: #f5d68a; font-size: 16px;
  animation: pulse 1.5s ease-in-out infinite;
  margin-top: 20px;
}
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

/* ---- Doomscroll posts ---- */
.doomscroll-post {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 12px; margin: 8px 0; cursor: pointer; transition: all 0.2s;
}
.doomscroll-post:hover { border-color: #f5d68a; }
.doomscroll-post .post-user { color: #a89070; font-size: 11px; margin-bottom: 4px; }
.doomscroll-post .post-text { color: #e8d5b5; font-size: 13px; }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  <div id="hud-row1">
    <div style="display:flex;align-items:center;gap:10px;">
      <span>üßÄ <span id="coin-display">0</span></span>
      <span id="happiness-display" title="Mouse Happiness">‚ù§Ô∏è <span id="happiness-value">80</span>%</span>
    </div>
    <div class="hud-right">
      <div class="room-tabs" id="room-tabs"></div>
      <button id="btn-shop">üõí Moustazon</button>
      <button id="btn-games">üéÆ Games</button>
      <button id="btn-letter">üíå</button>
      <button id="btn-sound" title="Sound">üîá</button>
    </div>
  </div>
  <div id="hud-row2">
    <div id="goal-display"></div>
  </div>
</div>

<div id="volume-popup" style="display:none;position:fixed;z-index:15;background:rgba(30,20,10,0.95);border:2px solid #a07040;border-radius:8px;padding:10px 14px;font-family:'Courier New',monospace;">
  <label style="color:#f5d68a;font-size:12px;">Volume</label><br>
  <input type="range" id="volume-slider" min="0" max="100" value="50" style="width:100px;margin-top:4px;accent-color:#f5d68a;">
</div>

<div id="toast"></div>

<div id="placement-bar">
  <div class="info" id="placement-info">Click/tap a spot to place the item</div>
  <button id="btn-cancel-place">‚úñ Cancel</button>
  <button id="btn-remove-mode">üóë Remove</button>
</div>

<div id="shop-flyout">
  <div class="flyout-header">
    <h2>üõí Moustazon</h2>
    <button class="flyout-close" id="flyout-close-btn">‚úñ</button>
  </div>
  <div class="flyout-coins">Free 2-day delivery | üßÄ <strong id="flyout-coin-display">0</strong> coins</div>
  <div class="flyout-items" id="flyout-items"></div>
  <div class="flyout-footer">
    <button id="flyout-loot-btn">üéÅ Loot Crumbs ‚Äî Free Mystery Item!</button>
    <div class="loot-info" id="flyout-loot-info"></div>
  </div>
</div>

<div id="games-flyout">
  <div class="flyout-header">
    <h2>üéÆ Arcade</h2>
    <button class="flyout-close" id="games-flyout-close">‚úñ</button>
  </div>
  <div class="flyout-subtitle">Earn cheese coins to shop at Moustazon!</div>
  <div class="game-list">
    <div class="game-item" onclick="startCheeseChase()">
      <div class="gi-title">üßÄ Cheese Chase</div>
      <div class="gi-desc">Dodge traps, collect cheese!</div>
    </div>
    <div class="game-item" onclick="startDoomscroll()">
      <div class="gi-title">üì± Doomscroll</div>
      <div class="gi-desc">Touch grass? Never heard of it.</div>
    </div>
    <div class="game-item" onclick="startMouseMaze()">
      <div class="gi-title">üèÅ Mouse Maze</div>
      <div class="gi-desc">Navigate the maze, collect cheese!</div>
    </div>
  </div>
</div>

<div id="item-tray"></div>

<div id="trash-zone">üóë</div>

<div id="title-screen">
  <h1>üê≠ Mouse House üê≠</h1>
  <div class="subtitle">A cozy home for Pip & Chai</div>
  <div class="start-text">~ tap or click to start ~</div>
</div>

<div id="modal-container"></div>

<script>
// ============================================================
// CONFIG ‚Äî Easy to change names, colors, messages
// ============================================================
const CONFIG = {
  mice: {
    pip: {
      name: 'Pip', bodyColor: '#4a4a4a', earColor: '#3a3a3a',
      bellyColor: '#5e5e5e', eyeColor: '#111', noseColor: '#ffaaaa',
      personality: 'chaotic', // more zoomies, sarcastic quotes
      scale: 1.15 // Pip is slightly larger than Chai
    },
    chai: {
      name: 'Chai', bodyColor: '#b8b8b8', earColor: '#a5a5a5',
      bellyColor: '#d0d0d0', eyeColor: '#222', noseColor: '#ffbbbb',
      personality: 'chill', // more sleeping, wholesome quotes
      scale: 1.0
    }
  },
  twins: { name1: 'Nico', name2: 'Rose', age: 20, birthday: 'February 21' },
  startingCoins: 50,
  birthdayMessage: `Dear Nico & Rose,

Happy 20th birthday! üéÇ

Twenty years of watching you two grow into the amazing, hilarious, kind humans you are. From tiny babies to tiny-mouse enthusiasts, you've filled every day with joy (and chaos, but mostly joy).

Pip and Chai are lucky to have you ‚Äî and so am I.

Here's a little mouse house for you to make your own. Decorate it, play some games, and know that every pixel was placed with love.

To the moon and back,
Dad üê≠üíõ`
};

// ============================================================
// AUDIO ENGINE (Web Audio API ‚Äî all synthesized)
// ============================================================
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let audioMuted = true;
let audioVolume = 0.5;
let musicPlaying = false;
let musicTimeout = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);
  masterGain.gain.value = audioMuted ? 0 : audioVolume;

  musicGain = audioCtx.createGain();
  musicGain.connect(masterGain);
  musicGain.gain.value = 0.3;

  sfxGain = audioCtx.createGain();
  sfxGain.connect(masterGain);
  sfxGain.gain.value = 0.7;
}

function toggleMute() {
  initAudio();
  audioMuted = !audioMuted;
  masterGain.gain.setTargetAtTime(audioMuted ? 0 : audioVolume, audioCtx.currentTime, 0.05);
  document.getElementById('btn-sound').textContent = audioMuted ? 'üîá' : 'üîä';
  try { localStorage.setItem('mouseHouseAudio', JSON.stringify({ muted: audioMuted, volume: audioVolume })); } catch(e) {}
  if (!audioMuted && !musicPlaying) startMusic();
}

function setVolume(v) {
  audioVolume = v;
  if (masterGain && !audioMuted) {
    masterGain.gain.setTargetAtTime(audioVolume, audioCtx.currentTime, 0.05);
  }
  try { localStorage.setItem('mouseHouseAudio', JSON.stringify({ muted: audioMuted, volume: audioVolume })); } catch(e) {}
}

function loadAudioPrefs() {
  try {
    const d = JSON.parse(localStorage.getItem('mouseHouseAudio'));
    if (d) {
      audioMuted = d.muted ?? true;
      audioVolume = d.volume ?? 0.5;
      document.getElementById('btn-sound').textContent = audioMuted ? 'üîá' : 'üîä';
      document.getElementById('volume-slider').value = Math.round(audioVolume * 100);
    }
  } catch(e) {}
}

// --- Synth helpers ---
function playTone(freq, duration, type, gainVal, dest) {
  if (!audioCtx || audioMuted) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type || 'sine';
  osc.frequency.value = freq;
  g.gain.value = gainVal || 0.3;
  g.gain.setTargetAtTime(0, audioCtx.currentTime + duration * 0.7, duration * 0.15);
  osc.connect(g);
  g.connect(dest || sfxGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + duration);
}

function playNoise(duration, gainVal) {
  if (!audioCtx || audioMuted) return;
  const bufSize = audioCtx.sampleRate * duration;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.value = gainVal || 0.1;
  g.gain.setTargetAtTime(0, audioCtx.currentTime + duration * 0.5, duration * 0.2);
  src.connect(g);
  g.connect(sfxGain);
  src.start();
}

// --- Sound effects ---
function sfxSqueak() {
  if (!audioCtx) return;
  const baseFreq = 1800 + Math.random() * 600;
  playTone(baseFreq, 0.08, 'sine', 0.2);
  setTimeout(() => playTone(baseFreq * 1.2, 0.06, 'sine', 0.15), 50);
}

function sfxCoinCollect() {
  if (!audioCtx) return;
  playTone(880, 0.08, 'square', 0.12);
  setTimeout(() => playTone(1100, 0.08, 'square', 0.12), 60);
  setTimeout(() => playTone(1320, 0.1, 'square', 0.1), 120);
}

function sfxBuy() {
  if (!audioCtx) return;
  playTone(523, 0.06, 'square', 0.12);
  setTimeout(() => playTone(659, 0.06, 'square', 0.12), 50);
  setTimeout(() => playTone(784, 0.06, 'square', 0.12), 100);
  setTimeout(() => playTone(1047, 0.12, 'square', 0.1), 150);
}

function sfxPlace() {
  if (!audioCtx) return;
  playNoise(0.06, 0.15);
  setTimeout(() => playTone(600, 0.1, 'triangle', 0.1), 40);
  setTimeout(() => playTone(900, 0.08, 'sine', 0.06), 100);
}

function sfxPet() {
  if (!audioCtx) return;
  const f = 1400 + Math.random() * 400;
  playTone(f, 0.06, 'sine', 0.15);
  setTimeout(() => playTone(f * 1.15, 0.06, 'sine', 0.12), 60);
  setTimeout(() => playTone(f * 1.3, 0.08, 'sine', 0.1), 120);
}

function sfxZoomies() {
  if (!audioCtx) return;
  for (let i = 0; i < 4; i++) {
    setTimeout(() => playTone(400 + i * 150, 0.05, 'sawtooth', 0.06), i * 40);
  }
}

function sfxCheeseCollect() {
  if (!audioCtx) return;
  playTone(1200, 0.05, 'sine', 0.15);
  setTimeout(() => playTone(1600, 0.07, 'sine', 0.1), 40);
}

function sfxCrash() {
  if (!audioCtx) return;
  playNoise(0.15, 0.2);
  playTone(200, 0.2, 'sawtooth', 0.12);
  setTimeout(() => playTone(120, 0.25, 'sawtooth', 0.08), 80);
}

function sfxGoodLike() {
  if (!audioCtx) return;
  playTone(523, 0.08, 'triangle', 0.12);
  setTimeout(() => playTone(659, 0.08, 'triangle', 0.12), 70);
  setTimeout(() => playTone(784, 0.12, 'triangle', 0.1), 140);
}

function sfxBadLike() {
  if (!audioCtx) return;
  playTone(300, 0.15, 'sawtooth', 0.1);
  setTimeout(() => playTone(250, 0.15, 'sawtooth', 0.1), 150);
  setTimeout(() => playTone(200, 0.25, 'sawtooth', 0.08), 300);
}

function sfxFanfare() {
  if (!audioCtx) return;
  const notes = [523, 659, 784, 1047, 784, 1047, 1319];
  notes.forEach((n, i) => {
    setTimeout(() => playTone(n, 0.12, 'square', 0.1), i * 100);
  });
}

function sfxGoalComplete() {
  if (!audioCtx) return;
  const notes = [659, 784, 1047, 1319];
  notes.forEach((n, i) => {
    setTimeout(() => playTone(n, 0.1, 'triangle', 0.12), i * 80);
  });
}

function sfxSpeechBubble() {
  if (!audioCtx) return;
  const f = 1000 + Math.random() * 800;
  playTone(f, 0.03, 'sine', 0.06);
}

function sfxWheelSpin() {
  if (!audioCtx) return;
  playTone(300, 0.05, 'triangle', 0.04);
  setTimeout(() => playTone(350, 0.05, 'triangle', 0.04), 60);
}

function sfxWheelFling() {
  if (!audioCtx) return;
  playTone(600, 0.06, 'sawtooth', 0.1);
  setTimeout(() => playTone(400, 0.08, 'sawtooth', 0.08), 50);
  setTimeout(() => playTone(250, 0.12, 'triangle', 0.06), 120);
  setTimeout(() => playNoise(0.08, 0.1), 200);
}

function sfxUIClick() {
  if (!audioCtx) return;
  playTone(800, 0.03, 'square', 0.06);
}

// --- Background music (gentle pentatonic loop) ---
const MUSIC_NOTES = [
  // 4-bar loop in C pentatonic, cozy and gentle
  // [note freq, duration in ms]
  [262, 300], [330, 300], [392, 300], [330, 300],
  [440, 300], [392, 300], [330, 600],
  [294, 300], [330, 300], [392, 300], [440, 300],
  [392, 300], [330, 300], [262, 600],
  [330, 300], [392, 300], [440, 300], [392, 300],
  [330, 300], [294, 300], [262, 600],
  [392, 300], [330, 300], [294, 300], [330, 300],
  [262, 300], [294, 300], [262, 600],
];

let musicNoteIndex = 0;

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;
  playMusicNote();
}

function stopMusic() {
  musicPlaying = false;
  if (musicTimeout) clearTimeout(musicTimeout);
}

function playMusicNote() {
  if (!musicPlaying || audioMuted) { musicPlaying = false; return; }
  const [freq, dur] = MUSIC_NOTES[musicNoteIndex % MUSIC_NOTES.length];
  musicNoteIndex++;

  // Soft triangle wave melody
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'triangle';
  osc.frequency.value = freq;
  g.gain.value = 0.08;
  // Gentle attack and release
  g.gain.setValueAtTime(0, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 0.03);
  g.gain.setTargetAtTime(0, audioCtx.currentTime + (dur / 1000) * 0.6, (dur / 1000) * 0.15);
  osc.connect(g);
  g.connect(musicGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + dur / 1000 + 0.1);

  // Subtle harmony (fifth below, very quiet)
  if (musicNoteIndex % 4 === 0) {
    const osc2 = audioCtx.createOscillator();
    const g2 = audioCtx.createGain();
    osc2.type = 'sine';
    osc2.frequency.value = freq * 0.667;
    g2.gain.value = 0.03;
    g2.gain.setTargetAtTime(0, audioCtx.currentTime + (dur / 1000) * 0.5, (dur / 1000) * 0.2);
    osc2.connect(g2);
    g2.connect(musicGain);
    osc2.start(audioCtx.currentTime);
    osc2.stop(audioCtx.currentTime + dur / 1000 + 0.15);
  }

  musicTimeout = setTimeout(playMusicNote, dur);
}

// Wire up sound button and volume slider
document.getElementById('btn-sound').addEventListener('click', (e) => {
  toggleMute();
  e.stopPropagation();
  // Position volume popup near the button
  const btn = document.getElementById('btn-sound');
  const popup = document.getElementById('volume-popup');
  if (!audioMuted) {
    const rect = btn.getBoundingClientRect();
    popup.style.top = (rect.bottom + 4) + 'px';
    popup.style.right = (window.innerWidth - rect.right) + 'px';
    popup.style.display = 'block';
    setTimeout(() => { popup.style.display = 'none'; }, 3000);
  } else {
    popup.style.display = 'none';
  }
});

document.getElementById('volume-slider').addEventListener('input', (e) => {
  setVolume(parseInt(e.target.value) / 100);
});

// ============================================================
// GAME STATE
// ============================================================
let state = {
  coins: CONFIG.startingCoins,
  currentRoom: 0,
  ownedItems: [],
  placedItems: [],
  miceState: {
    pip: { x: 120, y: 0, room: 0, action: 'idle', actionTimer: 0, dir: 1, frame: 0, animTimer: 0, happiness: 80 },
    chai:  { x: 250, y: 0, room: 1, action: 'idle', actionTimer: 0, dir: -1, frame: 0, animTimer: 0, happiness: 80 }
  },
  birthdayEventSeen: false,
  letterRead: false,
  lootCrumbsUsed: 0,
  totalCoinsEarned: 0,
  placementMode: null,
  removeMode: false,
  dragState: { active: false, itemId: null, screenX: 0, screenY: 0, fromPlaced: false, fromPlacedIdx: -1 },
  shopOpen: false,
  gameStarted: false,
  activeGoal: null
};

// ============================================================
// FURNITURE CATALOG
// ============================================================
const FURNITURE = [
  { id: 'matchbox-bed', name: 'Matchbox Bed', icon: 'üõè', price: 10,
    desc: 'A cozy matchbox. Smells like sulfur and dreams.', w: 2, h: 1,
    color: '#8B4513', mouseBehavior: 'sleeping' },
  { id: 'thimble-cup', name: 'Thimble Cup', icon: '‚òï', price: 5,
    desc: "One thimble of coffee. It's a latte, actually.", w: 1, h: 1,
    color: '#C0C0C0', mouseBehavior: 'eating' },
  { id: 'bottlecap-plate', name: 'Bottle Cap Plate', icon: 'üçΩ', price: 5,
    desc: 'Fine dining. Michelin star pending.', w: 1, h: 1,
    color: '#FF6347', mouseBehavior: 'eating' },
  { id: 'fairy-lights', name: 'Fairy Lights', icon: '‚ú®', price: 15,
    desc: 'Aesthetic‚Ñ¢. Very cottagecore.', w: 3, h: 1,
    color: '#FFD700', mouseBehavior: null, wallMount: true },
  { id: 'tiny-laptop', name: 'Tiny Laptop', icon: 'üíª', price: 30,
    desc: 'For doomscrolling at 3am. No judgment.', w: 1, h: 1,
    color: '#708090', mouseBehavior: 'doomscrolling' },
  { id: 'yoga-mat', name: 'Yoga Mat', icon: 'üßò', price: 12,
    desc: 'Namaste in bed, actually.', w: 2, h: 1,
    color: '#9370DB', mouseBehavior: 'yoga' },
  { id: 'live-laugh-cheese', name: '"Live Laugh Cheese"', icon: 'üìú', price: 8,
    desc: 'The pinnacle of interior design.', w: 2, h: 1,
    color: '#FFF8DC', mouseBehavior: null, wallMount: true },
  { id: 'sourdough', name: 'Sourdough Starter', icon: 'üçû', price: 20,
    desc: "Started in 2020. Has a name. Don't ask.", w: 1, h: 1,
    color: '#DEB887', mouseBehavior: 'eating' },
  { id: 'ring-light', name: 'Ring Light', icon: 'üí°', price: 18,
    desc: 'Content creation station. Very influencer.', w: 1, h: 1,
    color: '#FFE4B5', mouseBehavior: null },
  { id: 'cardboard-couch', name: 'Cardboard Couch', icon: 'üõã', price: 15,
    desc: "It's giving... IKEA but make it rodent.", w: 2, h: 1,
    color: '#8FBC8F', mouseBehavior: 'idle' },
  { id: 'spool-table', name: 'Spool Table', icon: 'ü™ë', price: 10,
    desc: 'Upcycled. Sustainable. Cottagecore.', w: 1, h: 1,
    color: '#D2691E', mouseBehavior: null },
  { id: 'eraser-tv', name: 'Eraser TV', icon: 'üì∫', price: 20,
    desc: 'Only shows static but they love it.', w: 1, h: 1,
    color: '#2F4F4F', mouseBehavior: 'watching' },
  { id: 'ethernet-rope', name: 'Ethernet Jump Rope', icon: 'üîå', price: 10,
    desc: 'Cat5e for cardio. Technically still connected.', w: 1, h: 1,
    color: '#4682B4', mouseBehavior: 'playing' },
  { id: 'cork-stool', name: 'Cork Stool', icon: 'ü™ë', price: 6,
    desc: 'Wine night leftover. Reduce reuse re-sit.', w: 1, h: 1,
    color: '#BC8F8F', mouseBehavior: null },
  { id: 'tiny-plant', name: 'Tiny Plant', icon: 'ü™¥', price: 8,
    desc: "It's fake but we don't talk about that.", w: 1, h: 1,
    color: '#228B22', mouseBehavior: null },
  { id: 'disco-ball', name: 'Disco Ball', icon: 'ü™©', price: 22,
    desc: 'For when the zoomies hit at midnight.', w: 1, h: 1,
    color: '#E0E0E0', mouseBehavior: 'zoomies', wallMount: true },
  { id: 'among-us-bean', name: 'Sus Beanbag', icon: 'ü´ò', price: 15,
    desc: 'A bit sus but very comfy. Emergency nap.', w: 1, h: 1,
    color: '#EF4444', mouseBehavior: 'sleeping' },
  { id: 'cheese-wheel', name: 'Cheese Wheel', icon: 'üßÄ', price: 25,
    desc: 'The holy grail. The one cheese to rule them all.', w: 1, h: 1,
    color: '#FFD700', mouseBehavior: 'eating' },
  { id: 'stamp-painting', name: 'Stamp Painting', icon: 'üñº', price: 8,
    desc: 'Is it modern art? Is it a stamp? Yes.', w: 1, h: 1,
    color: '#DDA0DD', mouseBehavior: null, wallMount: true },
  { id: 'tiny-hoodie', name: 'Tiny Hoodie Rack', icon: 'üß•', price: 12,
    desc: 'For when the vibes are chilly.', w: 1, h: 1,
    color: '#4169E1', mouseBehavior: null },
  // Birthday items (hidden until birthday event)
  { id: 'birthday-cake', name: 'Birthday Cake', icon: 'üéÇ', price: 0,
    desc: 'Happy 20th Nico & Rose! üéâ', w: 1, h: 1,
    color: '#FF69B4', mouseBehavior: 'eating', birthday: true },
  { id: 'party-banner', name: 'Party Banner', icon: 'üéâ', price: 0,
    desc: "It's giving... birthday.", w: 3, h: 1,
    color: '#FF1493', mouseBehavior: null, birthday: true, wallMount: true },
  { id: 'exercise-wheel', name: 'Exercise Wheel', icon: 'üé°', price: 0,
    desc: 'Cardio queen era. Spin to win.', w: 3, h: 3,
    color: '#708898', mouseBehavior: 'wheeling', exerciseRoom: true },
];

// ============================================================
// CANVAS SETUP ‚Äî 480x360 game coords, scaled to fit
// ============================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GAME_W = 480;
const GAME_H = 360;
const GRID_SIZE = 24;
const ROOM_Y = 40;
const ROOM_H = 280;
const ROOM_W = GAME_W;
const FLOOR_H = 40;
const GRID_COLS = Math.floor((ROOM_W - 16) / GRID_SIZE);
const GRID_ROWS = Math.floor((ROOM_H - FLOOR_H - 30) / GRID_SIZE);
const GRID_OFFSET_X = 8;
const GRID_OFFSET_Y = ROOM_Y + 30;

let scale = 1, offsetX = 0, offsetY = 0;

function resizeCanvas() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  scale = Math.min(w / GAME_W, h / GAME_H);
  canvas.style.width = (GAME_W * scale) + 'px';
  canvas.style.height = (GAME_H * scale) + 'px';
  const dpr = window.devicePixelRatio || 1;
  canvas.width = GAME_W * dpr;
  canvas.height = GAME_H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  offsetX = (w - GAME_W * scale) / 2;
  offsetY = (h - GAME_H * scale) / 2;
  canvas.style.marginLeft = offsetX + 'px';
  canvas.style.marginTop = offsetY + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function screenToGame(sx, sy) {
  const rect = canvas.getBoundingClientRect();
  return { x: (sx - rect.left) / scale, y: (sy - rect.top) / scale };
}
function gameToGrid(gx, gy) {
  return { col: Math.floor((gx - GRID_OFFSET_X) / GRID_SIZE), row: Math.floor((gy - GRID_OFFSET_Y) / GRID_SIZE) };
}
function gridToGame(col, row) {
  return { x: GRID_OFFSET_X + col * GRID_SIZE, y: GRID_OFFSET_Y + row * GRID_SIZE };
}

// ============================================================
// TOAST
// ============================================================
let toastTimeout;
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => el.classList.remove('show'), 3000);
}

// ============================================================
// SAVE / LOAD
// ============================================================
function saveGame() {
  try {
    localStorage.setItem('mouseHouseSave', JSON.stringify({
      coins: state.coins, ownedItems: state.ownedItems,
      placedItems: state.placedItems, currentRoom: state.currentRoom,
      miceState: state.miceState, birthdayEventSeen: state.birthdayEventSeen,
      letterRead: state.letterRead, lootCrumbsUsed: state.lootCrumbsUsed,
      totalCoinsEarned: state.totalCoinsEarned, activeGoal: state.activeGoal
    }));
  } catch (e) {}
}

function loadGame() {
  try {
    const d = JSON.parse(localStorage.getItem('mouseHouseSave'));
    if (d) {
      state.coins = d.coins ?? CONFIG.startingCoins;
      state.ownedItems = d.ownedItems ?? [];
      state.placedItems = d.placedItems ?? [];
      state.currentRoom = d.currentRoom ?? 0;
      state.birthdayEventSeen = d.birthdayEventSeen ?? false;
      state.letterRead = d.letterRead ?? false;
      state.lootCrumbsUsed = d.lootCrumbsUsed ?? 0;
      state.totalCoinsEarned = d.totalCoinsEarned ?? 0;
      state.activeGoal = d.activeGoal ?? null;
      if (d.miceState) {
        Object.assign(state.miceState.pip, d.miceState.pip || d.miceState.shadow || {});
        Object.assign(state.miceState.chai, d.miceState.chai || d.miceState.cloud || {});
      }
    }
  } catch (e) {}
}

function closeModal() { document.getElementById('modal-container').innerHTML = ''; }

function updateCoinDisplay() {
  document.getElementById('coin-display').textContent = state.coins;
  const flyoutCoins = document.getElementById('flyout-coin-display');
  if (flyoutCoins) flyoutCoins.textContent = state.coins;
}

// ============================================================
// ROOM TABS
// ============================================================
const ROOMS = [
  {
    name: 'Bedroom', icon: 'üõè',
    wallTop: '#5c4a6e', wallBot: '#4a3a5c', floor: '#6b5a50', floorAlt: '#5e4e44',
    baseboard: '#7a6a5a', ceiling: '#6e5a80', accent: '#8a70a0',
    windowNight: '#1a1a3e', windowGlow: '#2a2a5e', shelfColor: '#7a6a5a'
  },
  {
    name: 'Kitchen', icon: 'üç≥',
    wallTop: '#4a6e5a', wallBot: '#3a5c4a', floor: '#6b6050', floorAlt: '#5e5444',
    baseboard: '#7a6a5a', ceiling: '#5a8068', accent: '#70a08a',
    windowNight: '#1a2e1a', windowGlow: '#2a4e2a', shelfColor: '#8a7a60'
  },
  {
    name: 'Living Room', icon: 'üõã',
    wallTop: '#6e5a4a', wallBot: '#5c4a3a', floor: '#6b5a48', floorAlt: '#5e4e3e',
    baseboard: '#7a6a5a', ceiling: '#806a50', accent: '#a08a60',
    windowNight: '#2e1a1a', windowGlow: '#4e2a2a', shelfColor: '#7a6a50'
  },
  {
    name: 'Exercise Room', icon: 'üèÉ',
    wallTop: '#4a5a6e', wallBot: '#3a4a5c', floor: '#5a6050', floorAlt: '#4e5444',
    baseboard: '#6a7a8a', ceiling: '#5a6a80', accent: '#6080a0',
    windowNight: '#1a1a2e', windowGlow: '#2a2a4e', shelfColor: '#6a7a8a'
  }
];

function buildRoomTabs() {
  const tabs = document.getElementById('room-tabs');
  tabs.innerHTML = ROOMS.map((r, i) =>
    `<button class="${i === state.currentRoom ? 'active' : ''}" onclick="switchRoom(${i})">${r.icon}</button>`
  ).join('');
}
function switchRoom(i) {
  state.currentRoom = i;
  buildRoomTabs();
  saveGame();
}

// ============================================================
// PARTICLES (dust motes, floating in rooms)
// ============================================================
let particles = [];
function initParticles() {
  for (let i = 0; i < 15; i++) {
    particles.push({
      x: Math.random() * GAME_W,
      y: ROOM_Y + Math.random() * ROOM_H,
      size: 1 + Math.random() * 1.5,
      speedX: (Math.random() - 0.5) * 0.15,
      speedY: -0.05 - Math.random() * 0.1,
      alpha: 0.15 + Math.random() * 0.2
    });
  }
}
function updateParticles(dt) {
  particles.forEach(p => {
    p.x += p.speedX * dt * 0.06;
    p.y += p.speedY * dt * 0.06;
    if (p.y < ROOM_Y) { p.y = ROOM_Y + ROOM_H; p.x = Math.random() * GAME_W; }
    if (p.x < 0) p.x = GAME_W;
    if (p.x > GAME_W) p.x = 0;
  });
}
function drawParticles() {
  particles.forEach(p => {
    ctx.fillStyle = `rgba(255, 240, 210, ${p.alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

// ============================================================
// ROOM RENDERING
// ============================================================
function drawRoom(roomIndex) {
  const room = ROOMS[roomIndex];
  const t = Date.now() / 1000;

  // -- Top bar --
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, ROOM_Y);

  // -- Wall gradient (top to bottom) --
  const wallGrad = ctx.createLinearGradient(0, ROOM_Y, 0, ROOM_Y + ROOM_H - FLOOR_H);
  wallGrad.addColorStop(0, room.wallTop);
  wallGrad.addColorStop(1, room.wallBot);
  ctx.fillStyle = wallGrad;
  ctx.fillRect(0, ROOM_Y, ROOM_W, ROOM_H - FLOOR_H);

  // -- Subtle wall texture (soft horizontal lines) --
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  for (let y = ROOM_Y + 8; y < ROOM_Y + ROOM_H - FLOOR_H; y += 12) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(ROOM_W, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1.0;

  // -- Window with night sky --
  const winX = GAME_W / 2 - 34;
  const winY = ROOM_Y + 16;
  const winW = 68, winH = 56;
  // Window recess shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(winX - 3, winY - 3, winW + 6, winH + 6);
  // Night sky
  ctx.fillStyle = room.windowNight;
  ctx.fillRect(winX, winY, winW, winH);
  // Moon glow
  ctx.fillStyle = room.windowGlow;
  ctx.beginPath();
  ctx.arc(winX + winW - 14, winY + 14, 18, 0, Math.PI * 2);
  ctx.fill();
  // Moon
  ctx.fillStyle = '#eee8d0';
  ctx.beginPath();
  ctx.arc(winX + winW - 14, winY + 14, 7, 0, Math.PI * 2);
  ctx.fill();
  // Stars (twinkle)
  const starPositions = [
    [0.15, 0.2], [0.3, 0.65], [0.5, 0.15], [0.7, 0.5], [0.85, 0.3],
    [0.25, 0.4], [0.6, 0.7], [0.45, 0.45]
  ];
  starPositions.forEach(([sx, sy], i) => {
    const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(t * 1.5 + i * 1.7));
    ctx.globalAlpha = twinkle;
    ctx.fillStyle = '#fffde0';
    const size = (i % 3 === 0) ? 2 : 1;
    ctx.fillRect(winX + sx * winW, winY + sy * winH, size, size);
  });
  ctx.globalAlpha = 1.0;
  // Window panes (cross)
  ctx.strokeStyle = '#8a7a60';
  ctx.lineWidth = 3;
  ctx.strokeRect(winX, winY, winW, winH);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(winX + winW / 2, winY);
  ctx.lineTo(winX + winW / 2, winY + winH);
  ctx.moveTo(winX, winY + winH / 2);
  ctx.lineTo(winX + winW, winY + winH / 2);
  ctx.stroke();
  // Window sill
  ctx.fillStyle = '#8a7a60';
  ctx.fillRect(winX - 6, winY + winH, winW + 12, 5);
  // Tiny curtains
  ctx.fillStyle = room.accent;
  ctx.globalAlpha = 0.4;
  ctx.fillRect(winX - 2, winY, 8, winH);
  ctx.fillRect(winX + winW - 6, winY, 8, winH);
  ctx.globalAlpha = 1.0;

  // -- Wall shelf (decorative) --
  const shelfY = ROOM_Y + ROOM_H - FLOOR_H - 80;
  ctx.fillStyle = room.shelfColor;
  ctx.fillRect(20, shelfY, 80, 4);
  ctx.fillRect(ROOM_W - 100, shelfY, 80, 4);
  // Shelf brackets
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(30, shelfY + 4, 3, 10);
  ctx.fillRect(87, shelfY + 4, 3, 10);
  ctx.fillRect(ROOM_W - 90, shelfY + 4, 3, 10);
  ctx.fillRect(ROOM_W - 33, shelfY + 4, 3, 10);

  // -- Warm light glow from above (ambient lamp effect) --
  const lampGrad = ctx.createRadialGradient(GAME_W / 2, ROOM_Y + 4, 10, GAME_W / 2, ROOM_Y + 60, 200);
  lampGrad.addColorStop(0, 'rgba(255, 220, 150, 0.08)');
  lampGrad.addColorStop(1, 'rgba(255, 220, 150, 0)');
  ctx.fillStyle = lampGrad;
  ctx.fillRect(0, ROOM_Y, GAME_W, ROOM_H - FLOOR_H);

  // -- Baseboard --
  ctx.fillStyle = room.baseboard;
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H - 5, ROOM_W, 5);
  // Baseboard shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H - 6, ROOM_W, 1);

  // -- Floor --
  ctx.fillStyle = room.floor;
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H, ROOM_W, FLOOR_H);
  // Floor boards
  ctx.strokeStyle = room.floorAlt;
  ctx.lineWidth = 1;
  for (let fx = 0; fx < ROOM_W; fx += 36) {
    ctx.beginPath();
    ctx.moveTo(fx, ROOM_Y + ROOM_H - FLOOR_H);
    ctx.lineTo(fx, ROOM_Y + ROOM_H);
    ctx.stroke();
  }
  // Floor highlight
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H, ROOM_W, 2);

  // -- Ceiling trim --
  ctx.fillStyle = room.ceiling;
  ctx.fillRect(0, ROOM_Y, ROOM_W, 5);
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(0, ROOM_Y + 5, ROOM_W, 1);

  // -- Dollhouse frame edges (left & right walls) --
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(0, ROOM_Y, 4, ROOM_H);
  ctx.fillRect(ROOM_W - 4, ROOM_Y, 4, ROOM_H);
  // Inner wall shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(4, ROOM_Y, 6, ROOM_H);
  ctx.fillRect(ROOM_W - 10, ROOM_Y, 6, ROOM_H);

  // -- Dust particles --
  drawParticles();

  // -- Draw placed furniture for this room --
  const roomItems = state.placedItems.filter(p => p.room === roomIndex);
  roomItems.forEach(placed => {
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (!item) return;
    // Exercise wheel gets custom rendering
    if (item.id === 'exercise-wheel') {
      drawExerciseWheel(placed);
    } else {
      drawFurnitureItem(item, placed.gridX, placed.gridY);
    }
  });

  // -- Grid overlay in placement/drag mode --
  if (state.placementMode || state.removeMode || state.dragState.active) {
    ctx.strokeStyle = 'rgba(245,214,138,0.18)';
    ctx.lineWidth = 0.5;
    for (let r = 0; r < GRID_ROWS; r++) {
      for (let c = 0; c < GRID_COLS; c++) {
        const pos = gridToGame(c, r);
        ctx.strokeRect(pos.x, pos.y, GRID_SIZE, GRID_SIZE);
      }
    }
  }

  // -- Drag ghost preview --
  if (state.dragState.active) {
    const ds = state.dragState;
    const dragItem = FURNITURE.find(f => f.id === ds.itemId);
    if (dragItem) {
      const gPos = screenToGame(ds.screenX, ds.screenY);
      // Center the item on cursor
      const centerOffX = (dragItem.w * GRID_SIZE) / 2;
      const centerOffY = (dragItem.h * GRID_SIZE) / 2;
      const grid = gameToGrid(gPos.x - centerOffX + GRID_SIZE / 2, gPos.y - centerOffY + GRID_SIZE / 2);
      const excludeIdx = ds.fromPlaced ? ds.fromPlacedIdx : undefined;
      const valid = isPlacementValid(ds.itemId, grid.col, grid.row, excludeIdx);
      ctx.save();
      ctx.globalAlpha = 0.5;
      if (!valid) {
        // Red tint for invalid position
        ctx.globalAlpha = 0.4;
      }
      // Draw at snapped grid position
      const snapPos = gridToGame(grid.col, grid.row);
      if (dragItem.id !== 'exercise-wheel') {
        drawFurnitureItem(dragItem, grid.col, grid.row);
      }
      if (!valid) {
        // Red overlay
        ctx.fillStyle = 'rgba(255,50,50,0.3)';
        ctx.fillRect(snapPos.x, snapPos.y, dragItem.w * GRID_SIZE, dragItem.h * GRID_SIZE);
      }
      ctx.restore();
    }
  }

  // -- Room name label --
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  const labelW = ctx.measureText(`${room.icon} ${room.name}`).width + 20;
  ctx.fillRect(GAME_W / 2 - labelW / 2, ROOM_Y + ROOM_H - 20, labelW, 18);
  ctx.fillStyle = '#d0c0a0';
  ctx.font = '11px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`${room.icon} ${room.name}`, GAME_W / 2, ROOM_Y + ROOM_H - 11);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  // -- Bottom bar --
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, ROOM_Y + ROOM_H, GAME_W, GAME_H - ROOM_Y - ROOM_H);
}

// ============================================================
// FURNITURE RENDERING
// ============================================================
function drawFurnitureItem(item, gx, gy) {
  const pos = gridToGame(gx, gy);
  const w = item.w * GRID_SIZE;
  const h = item.h * GRID_SIZE;
  const x = pos.x, y = pos.y;
  const t = Date.now() / 1000;

  // Parse item.color into r,g,b for shade derivation
  const _cc = item.color;
  const _pr = parseInt(_cc.slice(1,3),16), _pg = parseInt(_cc.slice(3,5),16), _pb = parseInt(_cc.slice(5,7),16);
  const lighter = `rgb(${Math.min(_pr+40,255)},${Math.min(_pg+40,255)},${Math.min(_pb+40,255)})`;
  const darker  = `rgb(${Math.max(_pr-40,0)},${Math.max(_pg-40,0)},${Math.max(_pb-40,0)})`;
  const darkest = `rgb(${Math.max(_pr-70,0)},${Math.max(_pg-70,0)},${Math.max(_pb-70,0)})`;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.beginPath();
  ctx.roundRect(x + 2, y + 2, w, h, 3);
  ctx.fill();

  switch (item.id) {

  case 'matchbox-bed': { // 2x1 48x24
    // Matchbox body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x, y+4, 48, 20, 2); ctx.fill();
    ctx.fillStyle = darker;
    ctx.fillRect(x+1, y+22, 46, 2); // bottom edge
    // Matchbox inner tray
    ctx.fillStyle = lighter;
    ctx.fillRect(x+3, y+6, 42, 14);
    // Pillow
    ctx.fillStyle = '#f0eee8';
    ctx.beginPath(); ctx.roundRect(x+5, y+8, 10, 8, 2); ctx.fill();
    ctx.fillStyle = '#ddd';
    ctx.fillRect(x+6, y+12, 8, 1);
    // Blanket/quilt
    ctx.fillStyle = '#6ba36b';
    ctx.beginPath(); ctx.roundRect(x+17, y+7, 26, 12, 2); ctx.fill();
    ctx.fillStyle = '#5a8f5a';
    ctx.fillRect(x+17, y+13, 26, 1);
    ctx.fillRect(x+29, y+7, 1, 12);
    // Striker strip on side
    ctx.fillStyle = '#3a2510';
    ctx.fillRect(x+1, y+8, 2, 12);
    break;
  }

  case 'thimble-cup': { // 1x1 24x24
    // Thimble body (tapered)
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+6, y+22); ctx.lineTo(x+4, y+8);
    ctx.quadraticCurveTo(x+12, y+3, x+20, y+8);
    ctx.lineTo(x+18, y+22); ctx.closePath(); ctx.fill();
    // Highlight
    ctx.fillStyle = lighter;
    ctx.fillRect(x+8, y+8, 3, 12);
    // Dimple dots near top
    ctx.fillStyle = darker;
    for (let r = 0; r < 2; r++) for (let c = 0; c < 4; c++) {
      ctx.fillRect(x+7+c*3, y+6+r*3, 1, 1);
    }
    // Rim
    ctx.fillStyle = darkest;
    ctx.fillRect(x+4, y+7, 16, 1);
    // Base
    ctx.fillStyle = darker;
    ctx.fillRect(x+6, y+22, 12, 2);
    // Steam wisps
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 2; i++) {
      const sx = x+10+i*5, sy = y+3;
      const off = Math.sin(t*2+i*2)*2;
      ctx.beginPath(); ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(sx+off, sy-4, sx-off, sy-7);
      ctx.stroke();
    }
    break;
  }

  case 'bottlecap-plate': { // 1x1 24x24
    const cx = x+12, cy = y+14;
    // Crimped edge
    ctx.fillStyle = item.color;
    ctx.beginPath();
    for (let i = 0; i < 16; i++) {
      const a = (i/16)*Math.PI*2, r = i%2===0 ? 10 : 8.5;
      const px = cx+Math.cos(a)*r, py = cy+Math.sin(a)*r;
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill();
    // Inner flat area
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.fill();
    // Food crumbs
    ctx.fillStyle = '#c89040';
    ctx.fillRect(cx-2, cy-1, 2, 2);
    ctx.fillRect(cx+2, cy+1, 1, 1);
    ctx.fillRect(cx-1, cy+3, 2, 1);
    break;
  }

  case 'fairy-lights': { // 3x1 72x24
    // Wire
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+2, y+10);
    for (let i = 0; i < 72; i += 4) {
      ctx.lineTo(x+i, y+10 + Math.sin(i*0.15)*3);
    }
    ctx.stroke();
    // Bulbs
    const colors = ['#ff4444','#44ff44','#4488ff','#ffdd00','#ff88ff','#00ffcc','#ffaa00','#88aaff'];
    for (let i = 0; i < 8; i++) {
      const bx = x+6+i*8.5, by = y+10+Math.sin((6+i*8.5)*0.15)*3;
      const twinkle = 0.5 + 0.5*Math.sin(t*4 + i*1.7);
      ctx.globalAlpha = 0.4 + twinkle*0.6;
      ctx.fillStyle = colors[i];
      ctx.beginPath(); ctx.arc(bx, by+2, 2.5, 0, Math.PI*2); ctx.fill();
      // Glow around bulb
      ctx.globalAlpha = twinkle*0.25;
      ctx.beginPath(); ctx.arc(bx, by+2, 5, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
    // Overall glow
    const glow = ctx.createRadialGradient(x+36, y+12, 4, x+36, y+12, 40);
    glow.addColorStop(0, 'rgba(255,240,180,0.12)');
    glow.addColorStop(1, 'rgba(255,240,180,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-10, y-10, 92, 44);
    break;
  }

  case 'tiny-laptop': { // 1x1 24x24
    // Base/keyboard
    ctx.fillStyle = darker;
    ctx.fillRect(x+3, y+15, 18, 7);
    ctx.fillStyle = darkest;
    ctx.fillRect(x+5, y+17, 14, 3); // keyboard area
    // Tiny key dots
    ctx.fillStyle = '#555';
    for (let r = 0; r < 2; r++) for (let c = 0; c < 5; c++)
      ctx.fillRect(x+6+c*3, y+17+r*2, 2, 1);
    // Screen (tilted back)
    ctx.fillStyle = item.color;
    ctx.fillRect(x+3, y+4, 18, 12);
    // Screen content
    ctx.fillStyle = '#1a2a4a';
    ctx.fillRect(x+5, y+5, 14, 9);
    // Blue glow on screen
    ctx.fillStyle = '#4488cc';
    ctx.fillRect(x+6, y+7, 12, 2);
    ctx.fillStyle = '#335577';
    ctx.fillRect(x+6, y+10, 8, 1);
    ctx.fillRect(x+6, y+12, 10, 1);
    // Hinge
    ctx.fillStyle = darkest;
    ctx.fillRect(x+3, y+15, 18, 1);
    break;
  }

  case 'yoga-mat': { // 2x1 48x24
    // Flat mat
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+2, y+14, 40, 8, 2); ctx.fill();
    // Stripe
    ctx.fillStyle = lighter;
    ctx.fillRect(x+4, y+17, 36, 2);
    // Rolled curl at right end
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.arc(x+43, y+18, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(x+43, y+18, 2.5, 0, Math.PI*2); ctx.fill();
    // Mat thickness shadow
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(x+2, y+21, 40, 2);
    break;
  }

  case 'live-laugh-cheese': { // 2x1 48x24
    // Frame
    ctx.fillStyle = '#a08050';
    ctx.beginPath(); ctx.roundRect(x+2, y+3, 44, 18, 2); ctx.fill();
    // Inner
    ctx.fillStyle = item.color;
    ctx.fillRect(x+4, y+5, 40, 14);
    // Text "LLL"
    ctx.fillStyle = '#8B7355';
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('LLL', x+24, y+12);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    // Small cheese doodle
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(x+37, y+14, 4, 3);
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+38, y+15, 1, 1);
    break;
  }

  case 'sourdough': { // 1x1 24x24
    // Jar
    ctx.fillStyle = '#a09080';
    ctx.fillRect(x+5, y+10, 14, 12);
    ctx.fillStyle = '#8a7a6a';
    ctx.fillRect(x+5, y+10, 14, 2); // rim
    // Dough blob rising out
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+6, y+12);
    ctx.quadraticCurveTo(x+8, y+5, x+12, y+5);
    ctx.quadraticCurveTo(x+16, y+4, x+18, y+12);
    ctx.closePath(); ctx.fill();
    // Bubbles
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(x+10, y+8, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+14, y+7, 1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+12, y+10, 1, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'ring-light': { // 1x1 24x24
    const cx = x+12, cy = y+10;
    // Stand
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cx, cy+6); ctx.lineTo(cx, y+22); ctx.stroke();
    ctx.fillStyle = '#555';
    ctx.fillRect(cx-4, y+21, 8, 2);
    // Ring
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.stroke();
    // Bright white glow
    ctx.strokeStyle = 'rgba(255,255,230,0.5)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.stroke();
    // Overall glow
    const glow = ctx.createRadialGradient(cx, cy, 4, cx, cy, 20);
    glow.addColorStop(0, 'rgba(255,250,220,0.15)');
    glow.addColorStop(1, 'rgba(255,250,220,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-8, y-8, 40, 40);
    break;
  }

  case 'cardboard-couch': { // 2x1 48x24
    // Main body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+2, y+6, 44, 16, 2); ctx.fill();
    // Armrests
    ctx.fillStyle = darker;
    ctx.fillRect(x+2, y+4, 6, 18);
    ctx.fillRect(x+40, y+4, 6, 18);
    // Seat cushion line
    ctx.fillStyle = lighter;
    ctx.fillRect(x+9, y+10, 30, 2);
    // Corrugated cardboard lines
    ctx.strokeStyle = darker;
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 6; i++) {
      const ly = y+8+i*2.5;
      ctx.beginPath(); ctx.moveTo(x+9, ly);
      for (let lx = 0; lx < 30; lx += 3) {
        ctx.lineTo(x+9+lx+1.5, ly + (lx%6===0?1:-1));
      }
      ctx.stroke();
    }
    // Bottom edge
    ctx.fillStyle = darkest;
    ctx.fillRect(x+2, y+21, 44, 2);
    break;
  }

  case 'spool-table': { // 1x1 24x24
    const cx = x+12;
    // Top disc
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.ellipse(cx, y+7, 10, 4, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.ellipse(cx, y+6, 8, 3, 0, 0, Math.PI*2); ctx.fill();
    // Center hole
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(cx, y+6, 2, 0, Math.PI*2); ctx.fill();
    // Narrow body
    ctx.fillStyle = item.color;
    ctx.fillRect(cx-4, y+7, 8, 10);
    // Thread wrapping hints
    ctx.fillStyle = '#dda0dd';
    ctx.fillRect(cx-4, y+9, 8, 2);
    ctx.fillRect(cx-4, y+13, 8, 2);
    // Base disc
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.ellipse(cx, y+18, 10, 4, 0, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'eraser-tv': { // 1x1 24x24
    // Antenna
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+9, y+7); ctx.lineTo(x+6, y+2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+15, y+7); ctx.lineTo(x+18, y+2); ctx.stroke();
    // TV body (eraser shape)
    ctx.fillStyle = '#e8a0a8';
    ctx.beginPath(); ctx.roundRect(x+3, y+7, 18, 14, 2); ctx.fill();
    // Eraser band at bottom
    ctx.fillStyle = '#3050a0';
    ctx.fillRect(x+3, y+17, 18, 4);
    // Screen
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(x+5, y+8, 14, 8);
    // Static lines
    ctx.fillStyle = '#445';
    const staticOff = Math.floor(t * 8) % 4;
    for (let i = 0; i < 4; i++) {
      const sy = y+9+((i*2+staticOff)%8);
      if (sy < y+16) ctx.fillRect(x+5, sy, 14, 1);
    }
    // Screen flicker
    ctx.fillStyle = `rgba(150,180,200,${0.05+0.05*Math.sin(t*10)})`;
    ctx.fillRect(x+5, y+8, 14, 8);
    break;
  }

  case 'ethernet-rope': { // 1x1 24x24
    // Coiled cable
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x+12, y+14, 6, 0.3, Math.PI*1.8); ctx.stroke();
    ctx.beginPath();
    ctx.arc(x+12, y+14, 3.5, 0.8, Math.PI*1.5); ctx.stroke();
    // RJ45 connector end
    ctx.fillStyle = '#ccc';
    ctx.fillRect(x+17, y+8, 4, 6);
    ctx.fillStyle = '#aaa';
    ctx.fillRect(x+18, y+9, 2, 4);
    // Clip on connector
    ctx.fillStyle = '#ddd';
    ctx.fillRect(x+18, y+7, 2, 2);
    // Cable coming off connector
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x+19, y+14); ctx.lineTo(x+18, y+17); ctx.stroke();
    break;
  }

  case 'cork-stool': { // 1x1 24x24
    // Cork body (upright cylinder)
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+6, y+5, 12, 17, 3); ctx.fill();
    // Lighter front face
    ctx.fillStyle = lighter;
    ctx.fillRect(x+8, y+7, 8, 13);
    // Dot texture
    ctx.fillStyle = darker;
    for (let r = 0; r < 4; r++) for (let c = 0; c < 3; c++) {
      ctx.fillRect(x+8+c*3, y+8+r*3.5, 1, 1);
    }
    // Top
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.ellipse(x+12, y+6, 6, 2.5, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = darker;
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.ellipse(x+12, y+6, 6, 2.5, 0, 0, Math.PI*2); ctx.stroke();
    break;
  }

  case 'tiny-plant': { // 1x1 24x24
    // Pot (trapezoid)
    ctx.fillStyle = '#b5651d';
    ctx.beginPath();
    ctx.moveTo(x+6, y+13); ctx.lineTo(x+8, y+22);
    ctx.lineTo(x+16, y+22); ctx.lineTo(x+18, y+13);
    ctx.closePath(); ctx.fill();
    // Pot rim
    ctx.fillStyle = '#c97a3a';
    ctx.fillRect(x+5, y+12, 14, 2);
    // Soil
    ctx.fillStyle = '#4a3520';
    ctx.beginPath(); ctx.ellipse(x+12, y+13, 6, 2, 0, 0, Math.PI*2); ctx.fill();
    // Leaves
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.ellipse(x+10, y+8, 3, 5, -0.3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#1e7a1e';
    ctx.beginPath(); ctx.ellipse(x+14, y+9, 2.5, 4, 0.3, 0, Math.PI*2); ctx.fill();
    // Tiny stem
    ctx.strokeStyle = '#2d5a1e';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+12, y+13); ctx.lineTo(x+12, y+8); ctx.stroke();
    break;
  }

  case 'disco-ball': { // 1x1 24x24
    const cx = x+12, cy = y+12;
    // String at top
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx, y+1); ctx.lineTo(cx, y+5); ctx.stroke();
    // Ball body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.fill();
    // Faceted mirror tiles
    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        const tx = cx + c*3, ty = cy + r*3;
        if ((tx-cx)**2+(ty-cy)**2 < 49) {
          const shimmer = 0.3 + 0.7*Math.sin(t*3 + r*2.1 + c*1.7);
          ctx.fillStyle = `rgba(255,255,255,${shimmer*0.6})`;
          ctx.fillRect(tx-1, ty-1, 2.5, 2.5);
        }
      }
    }
    // Sparkle reflections scattered
    for (let i = 0; i < 4; i++) {
      const sa = t*2 + i*1.57;
      const sr = 10 + Math.sin(t*1.3+i)*2;
      const sx = cx + Math.cos(sa)*sr, sy = cy + Math.sin(sa)*sr;
      if (sx > x && sx < x+24 && sy > y && sy < y+24) {
        ctx.fillStyle = `rgba(255,255,200,${0.4+0.4*Math.sin(t*5+i)})`;
        ctx.fillRect(sx-1, sy-1, 2, 2);
      }
    }
    // Glow
    const glow = ctx.createRadialGradient(cx, cy, 3, cx, cy, 18);
    glow.addColorStop(0, 'rgba(255,240,180,0.12)');
    glow.addColorStop(1, 'rgba(255,240,180,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-8, y-8, 40, 40);
    break;
  }

  case 'among-us-bean': { // 1x1 24x24
    // Body (bean shape)
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+8, y+5);
    ctx.quadraticCurveTo(x+18, y+3, x+18, y+10);
    ctx.lineTo(x+18, y+16);
    ctx.quadraticCurveTo(x+18, y+21, x+15, y+21);
    ctx.lineTo(x+14, y+17);
    ctx.lineTo(x+10, y+17);
    ctx.lineTo(x+9, y+21);
    ctx.quadraticCurveTo(x+6, y+21, x+6, y+16);
    ctx.lineTo(x+6, y+10);
    ctx.quadraticCurveTo(x+6, y+5, x+8, y+5);
    ctx.closePath(); ctx.fill();
    // Visor
    ctx.fillStyle = '#87CEEB';
    ctx.beginPath();
    ctx.moveTo(x+7, y+7);
    ctx.quadraticCurveTo(x+7, y+12, x+12, y+12);
    ctx.quadraticCurveTo(x+17, y+12, x+17, y+9);
    ctx.quadraticCurveTo(x+17, y+6, x+12, y+6);
    ctx.quadraticCurveTo(x+7, y+6, x+7, y+7);
    ctx.closePath(); ctx.fill();
    // Visor shine
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillRect(x+9, y+7, 3, 2);
    // Backpack bump
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.roundRect(x+17, y+10, 4, 7, 1);
    ctx.fill();
    break;
  }

  case 'cheese-wheel': { // 1x1 24x24
    // Wedge shape (3D-ish)
    // Top face
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+4, y+8); ctx.lineTo(x+20, y+8);
    ctx.lineTo(x+20, y+14); ctx.lineTo(x+4, y+14);
    ctx.closePath(); ctx.fill();
    // Front face (darker wedge)
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.moveTo(x+4, y+14); ctx.lineTo(x+20, y+14);
    ctx.lineTo(x+18, y+21); ctx.lineTo(x+6, y+21);
    ctx.closePath(); ctx.fill();
    // Side face
    ctx.fillStyle = darkest;
    ctx.beginPath();
    ctx.moveTo(x+20, y+8); ctx.lineTo(x+22, y+10);
    ctx.lineTo(x+20, y+16); ctx.lineTo(x+20, y+14);
    ctx.closePath(); ctx.fill();
    // Holes
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(x+10, y+11, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+16, y+10, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = darkest;
    ctx.beginPath(); ctx.arc(x+9, y+17, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+15, y+17, 1, 0, Math.PI*2); ctx.fill();
    // Rind edge
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+4, y+7, 16, 1);
    break;
  }

  case 'stamp-painting': { // 1x1 24x24
    // Frame
    ctx.fillStyle = '#8B7355';
    ctx.beginPath(); ctx.roundRect(x+2, y+3, 20, 18, 1); ctx.fill();
    // Inner canvas
    ctx.fillStyle = '#faf0e6';
    ctx.fillRect(x+4, y+5, 16, 14);
    // Colorful abstract splotches
    ctx.fillStyle = '#e04060';
    ctx.beginPath(); ctx.arc(x+8, y+10, 3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#4080e0';
    ctx.beginPath(); ctx.arc(x+15, y+13, 2.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#40c060';
    ctx.fillRect(x+11, y+7, 4, 4);
    ctx.fillStyle = '#e0c040';
    ctx.beginPath(); ctx.arc(x+8, y+15, 2, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'tiny-hoodie': { // 1x1 24x24
    // Hook
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+12, y+2); ctx.lineTo(x+12, y+5);
    ctx.arc(x+12, y+4, 2, -Math.PI/2, Math.PI/2);
    ctx.stroke();
    // Body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+5, y+7, 14, 13, 2); ctx.fill();
    // Hood bump
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.arc(x+12, y+7, 5, Math.PI, 0); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(x+12, y+7, 3.5, Math.PI, 0); ctx.fill();
    // Sleeves
    ctx.fillStyle = darker;
    ctx.fillRect(x+3, y+9, 3, 7);
    ctx.fillRect(x+18, y+9, 3, 7);
    // Front pocket
    ctx.fillStyle = darkest;
    ctx.fillRect(x+8, y+15, 8, 3);
    // Drawstrings
    ctx.strokeStyle = lighter;
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(x+10, y+8); ctx.lineTo(x+10, y+11); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+14, y+8); ctx.lineTo(x+14, y+11); ctx.stroke();
    break;
  }

  case 'birthday-cake': { // 1x1 24x24
    // Bottom layer
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+4, y+14, 16, 8, 2); ctx.fill();
    // Frosting drips
    ctx.fillStyle = lighter;
    ctx.fillRect(x+4, y+14, 16, 3);
    ctx.fillRect(x+6, y+17, 2, 2);
    ctx.fillRect(x+14, y+17, 2, 2);
    // Top layer
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.roundRect(x+6, y+10, 12, 5, 1); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.fillRect(x+6, y+10, 12, 2);
    // Candle
    ctx.fillStyle = '#fff';
    ctx.fillRect(x+11, y+4, 2, 6);
    // Flame
    const flicker = Math.sin(t*8)*0.5;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.ellipse(x+12, y+3+flicker, 1.5, 2.5, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#ffdd00';
    ctx.beginPath();
    ctx.ellipse(x+12, y+3+flicker, 0.8, 1.5, 0, 0, Math.PI*2);
    ctx.fill();
    break;
  }

  case 'party-banner': { // 3x1 72x24
    // String
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+2, y+6);
    ctx.quadraticCurveTo(x+36, y+10, x+70, y+6);
    ctx.stroke();
    // Pennant flags
    const flagColors = ['#ff4466','#44bbff','#ffcc00','#66dd66','#ff88dd','#ff8844','#aa88ff','#44ffcc'];
    for (let i = 0; i < 8; i++) {
      const fx = x+6+i*8;
      const fy = y+6 + Math.sin((fx-x)/72*Math.PI)*4;
      ctx.fillStyle = flagColors[i % flagColors.length];
      ctx.beginPath();
      ctx.moveTo(fx-3, fy); ctx.lineTo(fx+3, fy);
      ctx.lineTo(fx, fy+10);
      ctx.closePath(); ctx.fill();
    }
    break;
  }

  default: {
    // Fallback: colored rect + emoji (for unknown items)
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(x+2, y+1, w-4, 3);
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(x+1, y+h-2, w-2, 2);
    const iconSize = Math.min(w, h) - 4;
    ctx.font = `${iconSize}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(item.icon, x + w/2, y + h/2 + 1);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    break;
  }

  } // end switch
}

// ============================================================
// EXERCISE WHEEL SYSTEM
// ============================================================
let wheelState = {
  angle: 0,        // current rotation angle
  speed: 0,        // spin speed (rad/frame)
  miceOn: [],      // keys of mice currently on the wheel ('pip', 'chai')
  flingTimer: 0,   // cooldown before another fling can happen
  flingTarget: null // mouse key being flung
};

function getWheelPlacement() {
  return state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === state.currentRoom);
}

function getWheelCenter(placed) {
  const pos = gridToGame(placed.gridX, placed.gridY);
  const w = 3 * GRID_SIZE; // wheel is 3x3 grid
  const h = 3 * GRID_SIZE;
  return { x: pos.x + w / 2, y: pos.y + h / 2 };
}

function drawExerciseWheel(placed) {
  const center = getWheelCenter(placed);
  const radius = 32;
  const t = Date.now() / 1000;

  // Wheel stand / frame
  ctx.fillStyle = '#5a4a3a';
  ctx.fillRect(center.x - 3, center.y + radius - 4, 6, 12);
  // Base feet
  ctx.fillRect(center.x - 14, center.y + radius + 6, 28, 4);
  ctx.fillStyle = '#4a3a2a';
  ctx.fillRect(center.x - 12, center.y + radius + 8, 24, 3);

  // Axle shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(center.x, center.y + radius + 8, 18, 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Outer wheel ring
  ctx.strokeStyle = '#8a9aaa';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  ctx.stroke();

  // Inner wheel ring (running surface)
  ctx.strokeStyle = '#6a7a8a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius - 5, 0, Math.PI * 2);
  ctx.stroke();

  // Spokes (rotate with wheel)
  ctx.strokeStyle = 'rgba(138,154,170,0.5)';
  ctx.lineWidth = 1.5;
  const numSpokes = 8;
  for (let i = 0; i < numSpokes; i++) {
    const a = wheelState.angle + (i / numSpokes) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(center.x + Math.cos(a) * 6, center.y + Math.sin(a) * 6);
    ctx.lineTo(center.x + Math.cos(a) * (radius - 2), center.y + Math.sin(a) * (radius - 2));
    ctx.stroke();
  }

  // Hub (center axle)
  ctx.fillStyle = '#aabbcc';
  ctx.beginPath();
  ctx.arc(center.x, center.y, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#8a9aaa';
  ctx.beginPath();
  ctx.arc(center.x, center.y, 3, 0, Math.PI * 2);
  ctx.fill();

  // Running treads on inner surface (rotating marks)
  ctx.fillStyle = 'rgba(90,100,110,0.3)';
  for (let i = 0; i < 16; i++) {
    const a = wheelState.angle + (i / 16) * Math.PI * 2;
    const tx = center.x + Math.cos(a) * (radius - 3);
    const ty = center.y + Math.sin(a) * (radius - 3);
    ctx.fillRect(tx - 1, ty - 1, 2, 2);
  }

  // Draw mice on the wheel
  wheelState.miceOn.forEach((mouseKey, idx) => {
    const mouse = state.miceState[mouseKey];
    const cfg = CONFIG.mice[mouseKey];
    if (mouse.action !== 'wheeling') return;

    // Mouse runs at bottom-inside of wheel, offset by wheel rotation
    // The mouse stays at roughly the bottom but the wheel rotates around it
    const mouseAngle = Math.PI / 2 + Math.sin(t * 3) * 0.15; // slight bobbing
    const runRadius = radius - 14;
    const mx = center.x + Math.cos(mouseAngle) * runRadius - 14;
    const my = center.y + Math.sin(mouseAngle) * runRadius - 20;

    // Running legs animation synced to wheel speed
    const runFrame = Math.floor(t * 8 * Math.max(1, wheelState.speed * 8)) % 4;
    drawMouse(mx, my, cfg, 1, runFrame, 'walking');
  });

  // Metallic sheen on wheel (top highlight)
  ctx.strokeStyle = 'rgba(200,220,240,0.2)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius, -Math.PI * 0.7, -Math.PI * 0.3);
  ctx.stroke();
}

function updateExerciseWheel(dt) {
  // Find wheel in exercise room (room 3)
  const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel');
  if (!wheelPlaced) return;

  // Update fling cooldown
  if (wheelState.flingTimer > 0) wheelState.flingTimer -= dt;

  // Check which mice are on the wheel
  const onWheel = [];
  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    if (mouse.action === 'wheeling' && mouse.room === wheelPlaced.room) {
      onWheel.push(key);
    }
  });
  wheelState.miceOn = onWheel;

  // Update wheel speed based on mice running
  if (onWheel.length > 0) {
    const targetSpeed = onWheel.length === 1 ? 0.04 : 0.08; // faster with two mice
    wheelState.speed += (targetSpeed - wheelState.speed) * 0.02;
  } else {
    // Slow down gradually
    wheelState.speed *= 0.98;
    if (wheelState.speed < 0.001) wheelState.speed = 0;
  }

  wheelState.angle += wheelState.speed * dt * 0.06;

  // Two-mouse interaction: one gets flung off!
  if (onWheel.length === 2 && wheelState.flingTimer <= 0 && Math.random() < 0.0008 * dt) {
    const flingKey = Math.random() < 0.5 ? onWheel[0] : onWheel[1];
    const stayKey = flingKey === onWheel[0] ? onWheel[1] : onWheel[0];
    flingMouseOffWheel(flingKey, stayKey, wheelPlaced);
  }

  // Occasional wheel squeak sound
  if (onWheel.length > 0 && Math.random() < 0.001 * dt) {
    sfxWheelSpin();
  }
}

function flingMouseOffWheel(flingKey, stayKey, wheelPlaced) {
  const mouse = state.miceState[flingKey];
  const center = getWheelCenter(wheelPlaced);

  // Fling the mouse!
  mouse.action = 'flung';
  mouse.actionTimer = 2500;
  mouse.flingVX = (Math.random() < 0.5 ? -1 : 1) * (2 + Math.random() * 2);
  mouse.flingVY = -(3 + Math.random() * 2);
  mouse.flingX = center.x - 14;
  mouse.flingY = center.y + 10;
  mouse.flingBounced = false;

  wheelState.flingTimer = 12000; // cooldown before next fling
  wheelState.speed *= 1.5; // wheel speeds up from the fling

  sfxWheelFling();

  // Flung mouse reaction
  const flingQuotes = [
    'YEET üòµ‚Äçüí´', 'I\'m flying!! üí´', 'was not ready', 'AAAA', 
    'parkour??', 'didn\'t sign up for this', '10/10 landing', 'ow',
    'that was on purpose actually', 'wheeeee! ...ow'
  ];
  speechBubbles.push({
    x: mouse.flingX + 14, y: mouse.flingY - 10,
    text: flingQuotes[Math.floor(Math.random() * flingQuotes.length)],
    timer: 3000, maxTimer: 3000, mouseKey: flingKey
  });

  // Staying mouse reaction (delayed)
  setTimeout(() => {
    const stayQuotes = [
      'lmaooo üòÇ', 'skill issue', 'MY wheel now', 'byeee üëã',
      'should\'ve held on', 'couldn\'t be me', 'ratio + flung'
    ];
    speechBubbles.push({
      x: state.miceState[stayKey].x + 14, y: MOUSE_FLOOR_Y - 10,
      text: stayQuotes[Math.floor(Math.random() * stayQuotes.length)],
      timer: 3000, maxTimer: 3000, mouseKey: stayKey
    });
  }, 800);

  // Floating stars around flung mouse
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      spawnFloatingEffect(
        mouse.flingX + 14 + (Math.random() - 0.5) * 30,
        mouse.flingY + (Math.random() - 0.5) * 20,
        ['‚≠ê', 'üí´', 'üòµ‚Äçüí´', '‚ú®', 'üí•'][i]
      );
    }, i * 100 + 200);
  }
}

function updateFlungMouse(mouse, dt) {
  if (mouse.action !== 'flung') return false;

  const gravity = 0.008 * dt;
  mouse.flingVY += gravity;
  mouse.flingX += mouse.flingVX * dt * 0.06;
  mouse.flingY += mouse.flingVY * dt * 0.06;

  // Bounce off floor
  if (mouse.flingY >= MOUSE_FLOOR_Y && !mouse.flingBounced) {
    mouse.flingBounced = true;
    mouse.flingVY = -Math.abs(mouse.flingVY) * 0.4;
    mouse.flingVX *= 0.5;
    // Small bounce sound
    sfxSqueak();
  }

  // Settle on floor
  if (mouse.flingBounced && mouse.flingY >= MOUSE_FLOOR_Y) {
    mouse.flingY = MOUSE_FLOOR_Y;
    mouse.x = Math.max(15, Math.min(ROOM_W - 45, mouse.flingX));
    mouse.action = 'idle';
    mouse.actionTimer = 3000 + Math.random() * 2000;
    mouse.dir = Math.random() < 0.5 ? 1 : -1;
    return false;
  }

  // Bounce off walls
  if (mouse.flingX < 15) { mouse.flingX = 15; mouse.flingVX = Math.abs(mouse.flingVX) * 0.5; }
  if (mouse.flingX > ROOM_W - 45) { mouse.flingX = ROOM_W - 45; mouse.flingVX = -Math.abs(mouse.flingVX) * 0.5; }

  return true; // still flying
}

function drawFlungMouse(mouse, cfg) {
  if (mouse.action !== 'flung') return;
  const t = Date.now() / 1000;

  // Tumbling rotation
  const tumble = t * 8;

  ctx.save();
  const cx = mouse.flingX + 14;
  const cy = mouse.flingY + 10;
  ctx.translate(cx, cy);
  ctx.rotate(Math.sin(tumble) * 0.5);
  ctx.translate(-cx, -cy);

  drawMouse(mouse.flingX, mouse.flingY, cfg, 1, 0, 'idle');

  // Dizzy stars orbiting
  if (mouse.flingBounced) {
    const starR = 12;
    for (let i = 0; i < 3; i++) {
      const sa = t * 4 + (i / 3) * Math.PI * 2;
      ctx.font = '8px serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚≠ê', cx + Math.cos(sa) * starR, cy - 12 + Math.sin(sa) * 4);
    }
    ctx.textAlign = 'left';
  }

  ctx.restore();
}

// ============================================================
// EXERCISE ROOM SETUP (auto-place wheel)
// ============================================================
function ensureExerciseRoomSetup() {
  // Auto-place the exercise wheel in the exercise room if not already placed
  const hasWheel = state.placedItems.some(p => p.itemId === 'exercise-wheel');
  if (!hasWheel) {
    if (!state.ownedItems.includes('exercise-wheel')) {
      state.ownedItems.push('exercise-wheel');
    }
    // Place wheel centered in exercise room (room 3)
    state.placedItems.push({
      itemId: 'exercise-wheel', room: 3,
      gridX: Math.floor(GRID_COLS / 2) - 1, gridY: GRID_ROWS - 3
    });
    saveGame();
  }
}

// ============================================================
// FURNITURE PLACEMENT & REMOVAL
// ============================================================
function startPlacement(itemId) {
  state.placementMode = itemId;
  state.removeMode = false;
  highlightTrayItem(itemId);
}

function cancelPlacement() {
  state.placementMode = null;
  state.removeMode = false;
  state.dragState = { active: false, itemId: null, screenX: 0, screenY: 0, fromPlaced: false, fromPlacedIdx: -1 };
  document.getElementById('trash-zone').classList.remove('visible', 'hover');
}

function toggleRemoveMode() {
  // No longer used as a separate mode ‚Äî kept as no-op for compatibility
}

function isPlacementValid(itemId, col, row, excludeIdx) {
  const item = FURNITURE.find(f => f.id === itemId);
  if (!item) return false;
  if (col < 0 || row < 0 || col + item.w > GRID_COLS || row + item.h > GRID_ROWS) return false;
  const overlaps = state.placedItems.some((p, idx) => {
    if (excludeIdx !== undefined && idx === excludeIdx) return false;
    if (p.room !== state.currentRoom) return false;
    const pi = FURNITURE.find(f => f.id === p.itemId);
    if (!pi) return false;
    return !(col + item.w <= p.gridX || p.gridX + pi.w <= col ||
             row + item.h <= p.gridY || p.gridY + pi.h <= row);
  });
  return !overlaps;
}

function handlePlacementClick(gx, gy) {
  const grid = gameToGrid(gx, gy);
  if (grid.col < 0 || grid.col >= GRID_COLS || grid.row < 0 || grid.row >= GRID_ROWS) return;

  if (state.removeMode) {
    const idx = state.placedItems.findIndex(p => {
      if (p.room !== state.currentRoom) return false;
      const it = FURNITURE.find(f => f.id === p.itemId);
      if (!it) return false;
      return grid.col >= p.gridX && grid.col < p.gridX + it.w &&
             grid.row >= p.gridY && grid.row < p.gridY + it.h;
    });
    if (idx >= 0) {
      const removed = state.placedItems[idx];
      const item = FURNITURE.find(f => f.id === removed.itemId);
      if (item?.exerciseRoom) {
        showToast("Can't remove the wheel! üé° The mice would riot.");
        return;
      }
      state.placedItems.splice(idx, 1);
      showToast(`Removed ${item?.name || 'item'} üóë`);
      saveGame();
    }
    return;
  }

  const item = FURNITURE.find(f => f.id === state.placementMode);
  if (!item) return;

  if (!isPlacementValid(item.id, grid.col, grid.row)) {
    showToast("Doesn't fit there! üê≠");
    return;
  }

  state.placedItems.push({
    itemId: item.id, room: state.currentRoom,
    gridX: grid.col, gridY: grid.row
  });

  sfxPlace();
  showToast(`Placed ${item.icon} ${item.name}!`);
  cancelPlacement();
  addHappiness(3);
  saveGame();
  refreshShopFlyout();
  refreshItemTray();
  reactToNewFurniture(item);
}

function reactToNewFurniture(item) {
  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    if (mouse.room !== state.currentRoom) return;
    const placed = state.placedItems[state.placedItems.length - 1];
    const targetPos = gridToGame(placed.gridX, placed.gridY);
    mouse.action = 'walking';
    mouse.targetX = targetPos.x + (key === 'pip' ? -10 : 20);
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 5000;
    setTimeout(() => {
      if (mouse.room === state.currentRoom) {
        const curiosity = ['ooh what\'s this? üëÄ', 'new thing! üéâ', '*sniff sniff*',
          'is this for me?', 'fancy ‚ú®', 'immediately claims this'][Math.floor(Math.random() * 6)];
        speechBubbles.push({
          x: mouse.x + 14, y: MOUSE_FLOOR_Y - 10,
          text: curiosity, timer: 2500, maxTimer: 2500, mouseKey: key
        });
      }
    }, 1500);
  });
}

// ============================================================
// SHOP FLYOUT PANEL
// ============================================================
function toggleShopFlyout() {
  state.shopOpen = !state.shopOpen;
  const flyout = document.getElementById('shop-flyout');
  const tray = document.getElementById('item-tray');
  if (state.shopOpen) {
    // Close games flyout if open
    if (gamesOpen) closeGamesFlyout();
    refreshShopFlyout();
    refreshItemTray();
    flyout.classList.add('open');
    tray.classList.add('open');
  } else {
    flyout.classList.remove('open');
    tray.classList.remove('open');
    cancelPlacement();
  }
}

function closeShopFlyout() {
  state.shopOpen = false;
  document.getElementById('shop-flyout').classList.remove('open');
  document.getElementById('item-tray').classList.remove('open');
  cancelPlacement();
}

function refreshShopFlyout() {
  const owned = new Set(state.ownedItems);
  const container = document.getElementById('flyout-items');
  document.getElementById('flyout-coin-display').textContent = state.coins;
  let html = '';
  FURNITURE.forEach(item => {
    if (item.birthday && !state.birthdayEventSeen) return;
    if (item.exerciseRoom) return;
    const isOwned = owned.has(item.id);
    const canAfford = state.coins >= item.price;
    const cls = isOwned ? 'owned' : (!canAfford ? 'cant-afford' : '');
    html += `<div class="flyout-item ${cls}" data-item-id="${item.id}">
      <div class="fi-icon">${item.icon}</div>
      <div class="fi-name">${item.name}</div>
      <div class="fi-price">${isOwned ? '‚úÖ Owned' : (item.price === 0 ? 'üéÅ Free!' : 'üßÄ ' + item.price)}</div>
    </div>`;
  });
  container.innerHTML = html;
  // Attach click handlers
  container.querySelectorAll('.flyout-item').forEach(el => {
    el.addEventListener('click', () => {
      const id = el.dataset.itemId;
      const isOwned = state.ownedItems.includes(id);
      if (isOwned) {
        startPlacement(id);
        showToast('Drag from the tray below to place! üëá');
      } else {
        const item = FURNITURE.find(f => f.id === id);
        if (item && state.coins >= item.price) {
          buyItem(id);
        }
      }
    });
  });
  // Update loot info
  const lootInfo = document.getElementById('flyout-loot-info');
  lootInfo.textContent = state.lootCrumbsUsed > 0
    ? `Opened ${state.lootCrumbsUsed} times. Totally not addictive.`
    : 'Ironic gacha. Always free. No regrets.';
}

function refreshItemTray() {
  const tray = document.getElementById('item-tray');
  const owned = new Set(state.ownedItems);
  let html = '';
  FURNITURE.forEach(item => {
    if (!owned.has(item.id)) return;
    if (item.exerciseRoom) return;
    if (item.birthday && !state.birthdayEventSeen) return;
    const isActive = state.placementMode === item.id;
    html += `<div class="tray-item ${isActive ? 'active' : ''}" data-item-id="${item.id}">
      <div class="ti-icon">${item.icon}</div>
      <div class="ti-name">${item.name}</div>
    </div>`;
  });
  tray.innerHTML = html;
}

function highlightTrayItem(itemId) {
  document.querySelectorAll('.tray-item').forEach(el => {
    el.classList.toggle('active', el.dataset.itemId === itemId);
  });
  // Scroll tray item into view
  const active = document.querySelector(`.tray-item[data-item-id="${itemId}"]`);
  if (active) active.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
}

// ============================================================
// DRAG & DROP PLACEMENT SYSTEM
// ============================================================
function startDrag(itemId, sx, sy, fromPlaced, fromPlacedIdx) {
  state.dragState = {
    active: true, itemId, screenX: sx, screenY: sy,
    fromPlaced: !!fromPlaced, fromPlacedIdx: fromPlacedIdx ?? -1
  };
  state.placementMode = itemId;
  document.getElementById('trash-zone').classList.add('visible');
}

function updateDrag(sx, sy) {
  if (!state.dragState.active) return;
  state.dragState.screenX = sx;
  state.dragState.screenY = sy;
  // Check trash zone hover
  const trashEl = document.getElementById('trash-zone');
  const trashRect = trashEl.getBoundingClientRect();
  const inTrash = sx >= trashRect.left && sx <= trashRect.right &&
                  sy >= trashRect.top && sy <= trashRect.bottom;
  trashEl.classList.toggle('hover', inTrash);
}

function endDrag(sx, sy) {
  if (!state.dragState.active) return;
  const ds = state.dragState;

  // Check if dropped on trash zone
  const trashEl = document.getElementById('trash-zone');
  const trashRect = trashEl.getBoundingClientRect();
  const inTrash = sx >= trashRect.left && sx <= trashRect.right &&
                  sy >= trashRect.top && sy <= trashRect.bottom;

  if (inTrash && ds.fromPlaced && ds.fromPlacedIdx >= 0) {
    const removed = state.placedItems[ds.fromPlacedIdx];
    const item = FURNITURE.find(f => f.id === removed?.itemId);
    if (item?.exerciseRoom) {
      showToast("Can't remove the wheel! üé° The mice would riot.");
    } else if (removed) {
      state.placedItems.splice(ds.fromPlacedIdx, 1);
      showToast(`Removed ${item?.name || 'item'} üóë`);
      saveGame();
      refreshShopFlyout();
      refreshItemTray();
    }
    cancelPlacement();
    return;
  }

  // Try to place on canvas
  const pos = screenToGame(sx, sy);
  const item = FURNITURE.find(f => f.id === ds.itemId);
  if (!item) { cancelPlacement(); return; }
  // Use same centering as ghost preview
  const centerOffX = (item.w * GRID_SIZE) / 2;
  const centerOffY = (item.h * GRID_SIZE) / 2;
  const grid = gameToGrid(pos.x - centerOffX + GRID_SIZE / 2, pos.y - centerOffY + GRID_SIZE / 2);

  const excludeIdx = ds.fromPlaced ? ds.fromPlacedIdx : undefined;
  if (isPlacementValid(ds.itemId, grid.col, grid.row, excludeIdx)) {
    if (ds.fromPlaced && ds.fromPlacedIdx >= 0) {
      // Repositioning ‚Äî update existing entry
      state.placedItems[ds.fromPlacedIdx].gridX = grid.col;
      state.placedItems[ds.fromPlacedIdx].gridY = grid.row;
      sfxPlace();
      showToast(`Moved ${item.icon} ${item.name}!`);
    } else {
      // New placement
      state.placedItems.push({
        itemId: item.id, room: state.currentRoom,
        gridX: grid.col, gridY: grid.row
      });
      sfxPlace();
      showToast(`Placed ${item.icon} ${item.name}!`);
      addHappiness(3);
      reactToNewFurniture(item);
    }
    saveGame();
    refreshShopFlyout();
    refreshItemTray();
  } else {
    if (ds.fromPlaced) {
      // Repositioning failed ‚Äî item stays where it was (already still in array)
      showToast("Can't place there! üê≠");
    }
    // New placement from tray ‚Äî just cancel, item returns to tray
  }
  cancelPlacement();
}

function findPlacedItemAt(gx, gy) {
  const grid = gameToGrid(gx, gy);
  const idx = state.placedItems.findIndex(p => {
    if (p.room !== state.currentRoom) return false;
    const it = FURNITURE.find(f => f.id === p.itemId);
    if (!it) return false;
    return grid.col >= p.gridX && grid.col < p.gridX + it.w &&
           grid.row >= p.gridY && grid.row < p.gridY + it.h;
  });
  return idx;
}

// Wire up flyout buttons
document.getElementById('flyout-close-btn').addEventListener('click', closeShopFlyout);
document.getElementById('games-flyout-close').addEventListener('click', closeGamesFlyout);
document.getElementById('flyout-loot-btn').addEventListener('click', () => {
  lootCrumbs();
});

// Wire up tray drag events (delegated)
(function setupTrayDrag() {
  const tray = document.getElementById('item-tray');

  tray.addEventListener('mousedown', e => {
    const tile = e.target.closest('.tray-item');
    if (!tile) return;
    e.preventDefault();
    startDrag(tile.dataset.itemId, e.clientX, e.clientY, false, -1);
  });
  tray.addEventListener('touchstart', e => {
    const tile = e.target.closest('.tray-item');
    if (!tile) return;
    e.preventDefault();
    const t = e.touches[0];
    startDrag(tile.dataset.itemId, t.clientX, t.clientY, false, -1);
  }, { passive: false });
})();

// Global mouse/touch move & up for drag
document.addEventListener('mousemove', e => {
  if (state.dragState.active) {
    e.preventDefault();
    updateDrag(e.clientX, e.clientY);
  }
});
document.addEventListener('touchmove', e => {
  if (state.dragState.active) {
    e.preventDefault();
    updateDrag(e.touches[0].clientX, e.touches[0].clientY);
  }
}, { passive: false });
document.addEventListener('mouseup', e => {
  if (state.dragState.active) {
    endDrag(e.clientX, e.clientY);
  }
});
document.addEventListener('touchend', e => {
  if (state.dragState.active) {
    const t = e.changedTouches[0];
    endDrag(t.clientX, t.clientY);
  }
});

function openShop() {
  toggleShopFlyout();
}

function buyItem(itemId) {
  const item = FURNITURE.find(f => f.id === itemId);
  if (!item || state.coins < item.price) return;
  state.coins -= item.price;
  state.ownedItems.push(itemId);
  sfxBuy();
  updateCoinDisplay();
  saveGame();
  showToast(`Bought ${item.icon} ${item.name}! ${item.desc}`);
  refreshShopFlyout();
  refreshItemTray();
}

function lootCrumbs() {
  const unowned = FURNITURE.filter(f => !state.ownedItems.includes(f.id) && !f.birthday && !f.exerciseRoom);
  if (unowned.length === 0) {
    showToast('You own everything! Go touch grass. üå±');
    return;
  }
  const item = unowned[Math.floor(Math.random() * unowned.length)];
  state.ownedItems.push(item.id);
  state.lootCrumbsUsed++;
  sfxBuy();
  saveGame();
  showToast(`üéÅ Loot Crumb opened! You got: ${item.icon} ${item.name}!`);
  refreshShopFlyout();
  refreshItemTray();
}

// Wire up HUD buttons
document.getElementById('btn-shop').addEventListener('click', openShop);
document.getElementById('btn-games').addEventListener('click', openMinigames);
document.getElementById('btn-letter').addEventListener('click', openLetter);

// ============================================================
// MINI-GAME MENU (flyout)
// ============================================================
let gamesOpen = false;

function toggleGamesFlyout() {
  gamesOpen = !gamesOpen;
  const flyout = document.getElementById('games-flyout');
  if (gamesOpen) {
    // Close shop flyout if open
    if (state.shopOpen) toggleShopFlyout();
    flyout.classList.add('open');
  } else {
    flyout.classList.remove('open');
  }
}

function closeGamesFlyout() {
  gamesOpen = false;
  document.getElementById('games-flyout').classList.remove('open');
}

function openMinigames() {
  toggleGamesFlyout();
}

// ============================================================
// CHEESE CHASE MINI-GAME
// ============================================================
let cheeseChaseActive = false;
let cc = {};
let ccInputY = null;

function startCheeseChase() {
  closeModal();
  closeGamesFlyout();
  cheeseChaseActive = true;
  ccInputY = null;
  cc = {
    mouseY: GAME_H / 2,
    score: 0,
    obstacles: [],
    cheeses: [],
    spawnTimer: 0,
    speed: 1.8,
    distance: 0,
    gameOver: false,
    bgStars: []
  };
  // Background decor
  for (let i = 0; i < 25; i++) {
    cc.bgStars.push({ x: Math.random() * GAME_W, y: Math.random() * GAME_H, s: 1 + Math.random() });
  }
}

function updateCheeseChase(dt) {
  if (!cheeseChaseActive || cc.gameOver) return;

  cc.distance += cc.speed;
  cc.speed = 1.8 + cc.distance / 4000;
  cc.spawnTimer -= dt;

  // Spawn obstacles and cheese
  if (cc.spawnTimer <= 0) {
    cc.spawnTimer = 500 + Math.random() * 500 - Math.min(cc.distance / 50, 200);
    cc.spawnTimer = Math.max(cc.spawnTimer, 200);

    if (Math.random() < 0.45) {
      // Cheese collectible
      cc.cheeses.push({
        x: GAME_W + 10,
        y: 30 + Math.random() * (GAME_H - 60),
        size: 14
      });
    } else {
      // Obstacle (mousetrap or cat)
      const isCat = Math.random() < 0.3;
      const h = isCat ? 35 + Math.random() * 25 : 25 + Math.random() * 50;
      cc.obstacles.push({
        x: GAME_W + 10,
        y: Math.random() < 0.5 ? 0 : GAME_H - h,
        w: isCat ? 28 : 18,
        h: h,
        type: isCat ? 'cat' : 'trap'
      });
    }
  }

  // Move everything left
  cc.obstacles.forEach(o => o.x -= cc.speed);
  cc.cheeses.forEach(c => c.x -= cc.speed);
  cc.obstacles = cc.obstacles.filter(o => o.x > -40);
  cc.cheeses = cc.cheeses.filter(c => c.x > -20);

  // Mouse input following
  if (ccInputY !== null) {
    cc.mouseY += (ccInputY - cc.mouseY) * 0.12;
  }
  cc.mouseY = Math.max(12, Math.min(GAME_H - 12, cc.mouseY));

  // Collision detection
  const mBox = { x: 35, y: cc.mouseY - 9, w: 24, h: 18 };

  // Collect cheese
  cc.cheeses = cc.cheeses.filter(c => {
    const cBox = { x: c.x - 7, y: c.y - 7, w: 14, h: 14 };
    if (boxOverlap(mBox, cBox)) {
      cc.score++;
      sfxCheeseCollect();
      // Sparkle effect
      spawnFloatingEffect(c.x, c.y, '‚ú®');
      return false;
    }
    return true;
  });

  // Hit obstacle
  for (const o of cc.obstacles) {
    if (boxOverlap(mBox, o)) {
      cc.gameOver = true;
      sfxCrash();
      break;
    }
  }
}

function boxOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

function drawCheeseChase() {
  if (!cheeseChaseActive) return;
  const t = Date.now() / 1000;

  // Warm dark background
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // Scrolling background dots
  cc.bgStars.forEach(s => {
    const sx = ((s.x - cc.distance * 0.2) % GAME_W + GAME_W) % GAME_W;
    ctx.fillStyle = 'rgba(245,214,138,0.15)';
    ctx.fillRect(sx, s.y, s.s, s.s);
  });

  // Floor and ceiling lines
  ctx.fillStyle = '#3d2b1a';
  ctx.fillRect(0, 0, GAME_W, 5);
  ctx.fillRect(0, GAME_H - 5, GAME_W, 5);

  // Obstacles
  cc.obstacles.forEach(o => {
    if (o.type === 'cat') {
      // Cat silhouette
      ctx.fillStyle = '#5a3020';
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 4);
      ctx.fill();
      // Cat ears
      if (o.y === 0) {
        ctx.fillRect(o.x + 4, o.y + o.h - 2, 6, 8);
        ctx.fillRect(o.x + o.w - 10, o.y + o.h - 2, 6, 8);
      } else {
        ctx.fillRect(o.x + 4, o.y - 6, 6, 8);
        ctx.fillRect(o.x + o.w - 10, o.y - 6, 6, 8);
      }
      // Eyes
      const eyeY = o.y === 0 ? o.y + o.h - 12 : o.y + 10;
      ctx.fillStyle = '#44ee44';
      ctx.beginPath();
      ctx.ellipse(o.x + 8, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(o.x + o.w - 8, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      // Slit pupils
      ctx.fillStyle = '#1a0f05';
      ctx.fillRect(o.x + 7, eyeY - 2, 1.5, 4);
      ctx.fillRect(o.x + o.w - 9, eyeY - 2, 1.5, 4);
    } else {
      // Mousetrap
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(o.x, o.y, o.w, o.h);
      ctx.fillStyle = '#a08030';
      ctx.fillRect(o.x + 2, o.y + 2, o.w - 4, 4);
      // Spring
      ctx.strokeStyle = '#c0a050';
      ctx.lineWidth = 1.5;
      const springBase = o.y === 0 ? o.y + o.h : o.y;
      ctx.beginPath();
      for (let i = 0; i < o.h; i += 6) {
        const sx = o.x + o.w / 2 + (i % 12 === 0 ? -4 : 4);
        ctx.lineTo(sx, springBase + (o.y === 0 ? -i : i));
      }
      ctx.stroke();
      // Danger icon
      ctx.font = '10px serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚ö†Ô∏è', o.x + o.w / 2, o.y + o.h / 2 + 4);
      ctx.textAlign = 'left';
    }
  });

  // Cheese collectibles
  cc.cheeses.forEach(c => {
    // Glow
    ctx.fillStyle = 'rgba(255,215,0,0.15)';
    ctx.beginPath();
    ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
    ctx.fill();
    // Emoji
    ctx.font = '14px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üßÄ', c.x, c.y);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
  });

  // Player mouse
  const mFrame = Math.floor(cc.distance / 15) % 4;
  drawMouse(35, cc.mouseY - 10, CONFIG.mice.pip, 1, mFrame, 'walking');

  // Floating effects (sparkles on cheese collect)
  drawFloatingEffects();

  // HUD
  ctx.fillStyle = 'rgba(26,15,5,0.7)';
  ctx.fillRect(0, 0, GAME_W, 28);
  ctx.fillStyle = '#f5d68a';
  ctx.font = '14px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`üßÄ ${cc.score}`, 10, 19);
  ctx.textAlign = 'right';
  ctx.fillText(`${Math.floor(cc.distance / 10)}m`, GAME_W - 10, 19);
  // Speed indicator
  ctx.fillStyle = '#a89070';
  ctx.font = '10px monospace';
  ctx.fillText(`‚ö°${cc.speed.toFixed(1)}x`, GAME_W - 10, 12);
  ctx.textAlign = 'left';

  // Game over overlay
  if (cc.gameOver) {
    ctx.fillStyle = 'rgba(26,15,5,0.8)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);

    ctx.fillStyle = '#f5d68a';
    ctx.font = '28px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('ü™§ CAUGHT!', GAME_W / 2, GAME_H / 2 - 35);

    ctx.font = '14px monospace';
    ctx.fillStyle = '#e8d5b5';
    ctx.fillText(`Cheese: üßÄ ${cc.score}  |  Distance: ${Math.floor(cc.distance / 10)}m`, GAME_W / 2, GAME_H / 2);

    const earned = cc.score * 2;
    ctx.fillStyle = '#f5d68a';
    ctx.font = '16px monospace';
    ctx.fillText(`Earned: üßÄ ${earned} coins!`, GAME_W / 2, GAME_H / 2 + 25);

    ctx.fillStyle = '#a89070';
    ctx.font = '12px monospace';
    ctx.fillText('tap / click to continue', GAME_W / 2, GAME_H / 2 + 55);
    ctx.textAlign = 'left';
  }
}

function endCheeseChase() {
  const earned = cc.score * 2;
  state.coins += earned;
  state.totalCoinsEarned += earned;
  addHappiness(5);
  updateCoinDisplay();
  saveGame();
  cheeseChaseActive = false;
  sfxCoinCollect();
  spawnCoinEffect(earned, GAME_W / 2, GAME_H / 2 - 20);
  showToast(`Cheese Chase: earned üßÄ ${earned} coins!`);
}

// ============================================================
// DOOMSCROLL MINI-GAME
// ============================================================
const DOOMSCROLL_POSTS = [
  // Good posts ‚Äî like these!
  { text: 'mice are literally the best pets no cap üê≠', good: true, user: '@mousewhisperer' },
  { text: 'just found the BIGGEST cheese wheel at Costco', good: true, user: '@cheeseenthusiast' },
  { text: 'my mouse learned to high five today ü•∫', good: true, user: '@tinypaws' },
  { text: 'cheese board appreciation post üßÄ‚ú®', good: true, user: '@cheeseboard_daily' },
  { text: 'reminder: you are loved and valid üíõ', good: true, user: '@wholesomemouse' },
  { text: `${CONFIG.mice.pip.name} and ${CONFIG.mice.chai.name} fan account üê≠üê≠`, good: true, user: '@mouse_stan' },
  { text: 'POV: the mouse found the cheese stash', good: true, user: '@mousemoments' },
  { text: 'tiny mouse in a tiny hat. that\'s it. that\'s the post.', good: true, user: '@tinyhat' },
  { text: 'cozy mouse house tour üè†üê≠ (it\'s perfect)', good: true, user: '@cozymouse' },
  { text: 'petition to make mice the national animal', good: true, user: '@mouseactivist' },
  { text: 'just watched a mouse do yoga and now I believe in god', good: true, user: '@spiritual_mouse' },
  { text: 'normalize napping 14 hours a day (I am a mouse)', good: true, user: '@sleepymouse' },
  { text: 'cheese is just milk that believed in itself üßÄ', good: true, user: '@deepcheese' },
  // Bad posts ‚Äî skip these!
  { text: 'actually, mice are mid', good: false, user: '@wrongopinions' },
  { text: 'hot take: cheese is overrated', good: false, user: '@controversialcarl' },
  { text: 'reply guys assemble ü§ì‚òùÔ∏è', good: false, user: '@replyguy47' },
  { text: 'imagine not having a sigma grindset in 2026', good: false, user: '@sigmagrinder' },
  { text: 'I mass-followed 10,000 accounts for clout', good: false, user: '@followback' },
  { text: 'this u? ü§®üì∏', good: false, user: '@exposed' },
  { text: 'I did my own research (watched 2 youtube videos)', good: false, user: '@truthseeker99' },
  { text: 'brand account trying to be relatable: slay bestie', good: false, user: '@megacorp_official' },
  { text: 'ratio + L + no cheese', good: false, user: '@ratioenjoyer' },
  { text: 'who asked? (I am very lonely)', good: false, user: '@whoasked' },
  { text: 'wake up at 4am or you\'re a failure (I am unwell)', good: false, user: '@hustleculture' },
  { text: 'my toxic trait is thinking I\'m the main character', good: false, user: '@toxicmain' },
  { text: 'vibe check: you failed. rip bozo.', good: false, user: '@vibechecker' },
];

let dsActive = false;
let ds = {};

function startDoomscroll() {
  closeModal();
  closeGamesFlyout();
  dsActive = true;
  const shuffled = [...DOOMSCROLL_POSTS].sort(() => Math.random() - 0.5);
  ds = {
    posts: shuffled.slice(0, 10),
    current: 0,
    score: 0,
    strikes: 0,
    maxStrikes: 3,
    finished: false,
    feedback: null
  };
  renderDoomscroll();
}

function renderDoomscroll() {
  if (!dsActive) return;
  const container = document.getElementById('modal-container');

  if (ds.finished) {
    const earned = ds.score * 3;
    state.coins += earned;
    state.totalCoinsEarned += earned;
    addHappiness(4);
    updateCoinDisplay();
    spawnCoinEffect(earned);
    sfxCoinCollect();
    saveGame();

    container.innerHTML = `<div class="modal-overlay">
      <div class="modal-content" style="min-width:300px;max-width:420px;">
        <h2>üì± Doomscroll Complete!</h2>
        <p style="text-align:center;font-size:15px;color:#f5d68a;margin:14px 0;">
          Good posts liked: ${ds.score} ‚úÖ<br>
          Cringe posts liked: ${ds.strikes} üò¨<br><br>
          <span style="font-size:18px;">Earned: üßÄ ${earned} cheese coins!</span>
        </p>
        <p style="text-align:center;color:#a89070;font-size:11px;">
          ${ds.strikes === 0 ? 'Perfect feed! Your algorithm is immaculate.' :
            ds.strikes >= 3 ? 'Touch grass immediately. üå±' :
            'Not bad, but maybe log off for a bit.'}
        </p>
        <button class="close-btn" onclick="dsActive=false;closeModal()">Nice</button>
      </div>
    </div>`;
    return;
  }

  const post = ds.posts[ds.current];
  const strikeDisplay = '‚ùå'.repeat(ds.strikes) + '‚¨ú'.repeat(ds.maxStrikes - ds.strikes);

  container.innerHTML = `<div class="modal-overlay">
    <div class="modal-content" style="min-width:300px;max-width:440px;">
      <h2>üì± Doomscroll</h2>
      <p style="text-align:center;color:#a89070;font-size:11px;margin-bottom:6px;">
        Post ${ds.current + 1} of ${ds.posts.length} &nbsp;|&nbsp; üßÄ ${ds.score * 3} earned &nbsp;|&nbsp; ${strikeDisplay}
      </p>
      ${ds.feedback ? `<p style="text-align:center;font-size:13px;margin:6px 0;color:${ds.feedback.color};">${ds.feedback.text}</p>` : ''}
      <div class="doomscroll-post" style="margin:14px 0;">
        <div class="post-user">${post.user}</div>
        <div class="post-text" style="font-size:14px;margin-top:6px;">${post.text}</div>
      </div>
      <div style="display:flex;gap:10px;justify-content:center;margin-top:10px;">
        <button class="minigame-btn" onclick="doomscrollAction(true)" style="width:42%;">
          ‚ù§Ô∏è Like
        </button>
        <button class="minigame-btn" onclick="doomscrollAction(false)" style="width:42%;">
          ‚è≠ Skip
        </button>
      </div>
      <p style="text-align:center;color:#6b5030;font-size:10px;margin-top:8px;">
        Like the good posts. Skip the cringe. 3 strikes = game over.
      </p>
    </div>
  </div>`;
}

function doomscrollAction(liked) {
  const post = ds.posts[ds.current];

  if (liked && post.good) {
    ds.score++;
    ds.feedback = { text: '‚úÖ Based! +3 üßÄ', color: '#7bc67e' };
    sfxGoodLike();
  } else if (liked && !post.good) {
    ds.strikes++;
    ds.feedback = { text: 'üò¨ Yikes, you liked cringe!', color: '#e06050' };
    sfxBadLike();
  } else if (!liked && post.good) {
    ds.feedback = { text: 'üò¢ You skipped a good one!', color: '#e8a040' };
    sfxUIClick();
  } else {
    ds.feedback = { text: 'üëç Good skip, that was cringe', color: '#7bc67e' };
    sfxGoodLike();
  }

  ds.current++;
  if (ds.current >= ds.posts.length || ds.strikes >= ds.maxStrikes) {
    ds.finished = true;
  }
  renderDoomscroll();
}

// ============================================================
// MOUSE MAZE MINI-GAME
// ============================================================
let mouseMazeActive = false;
let mz = {};

function generateMaze(cols, rows) {
  // Recursive backtracker algorithm
  const grid = [];
  for (let r = 0; r < rows; r++) {
    grid[r] = [];
    for (let c = 0; c < cols; c++) {
      grid[r][c] = { top: true, right: true, bottom: true, left: true, visited: false };
    }
  }
  const stack = [];
  let cur = { r: 0, c: 0 };
  grid[0][0].visited = true;
  const dirs = [
    { dr: -1, dc: 0, wall: 'top', opp: 'bottom' },
    { dr: 1, dc: 0, wall: 'bottom', opp: 'top' },
    { dr: 0, dc: -1, wall: 'left', opp: 'right' },
    { dr: 0, dc: 1, wall: 'right', opp: 'left' }
  ];
  function neighbors(r, c) {
    return dirs.filter(d => {
      const nr = r + d.dr, nc = c + d.dc;
      return nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].visited;
    });
  }
  let totalVisited = 1;
  const totalCells = rows * cols;
  while (totalVisited < totalCells) {
    const nb = neighbors(cur.r, cur.c);
    if (nb.length > 0) {
      const pick = nb[Math.floor(Math.random() * nb.length)];
      stack.push(cur);
      grid[cur.r][cur.c][pick.wall] = false;
      cur = { r: cur.r + pick.dr, c: cur.c + pick.dc };
      grid[cur.r][cur.c][pick.opp] = false;
      grid[cur.r][cur.c].visited = true;
      totalVisited++;
    } else {
      cur = stack.pop();
    }
  }
  return grid;
}

function startMouseMaze() {
  closeModal();
  closeGamesFlyout();
  mouseMazeActive = true;
  mz = {
    level: 1,
    totalScore: 0,
    totalCheese: 0
  };
  initMazeLevel(mz.level);
}

function initMazeLevel(level) {
  const cols = 6 + level * 2;  // 8, 10, 12
  const rows = 5 + level;      // 6, 7, 8
  const grid = generateMaze(cols, rows);
  const cellW = Math.floor((GAME_W - 20) / cols);
  const cellH = Math.floor((GAME_H - 50) / rows);
  const cellSize = Math.min(cellW, cellH, 36);
  const mazeW = cols * cellSize;
  const mazeH = rows * cellSize;
  const ox = Math.floor((GAME_W - mazeW) / 2);
  const oy = Math.floor((GAME_H - 30 - mazeH) / 2) + 28;

  // Place cheese in random dead-end or interior cells
  const cheeses = [];
  const numCheese = 3 + level * 2;
  const candidates = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (r === 0 && c === 0) continue;
      if (r === rows - 1 && c === cols - 1) continue;
      candidates.push({ r, c });
    }
  }
  candidates.sort(() => Math.random() - 0.5);
  for (let i = 0; i < Math.min(numCheese, candidates.length); i++) {
    cheeses.push({ r: candidates[i].r, c: candidates[i].c, collected: false });
  }

  Object.assign(mz, {
    grid, cols, rows, cellSize, ox, oy,
    playerR: 0, playerC: 0,
    exitR: rows - 1, exitC: cols - 1,
    cheeses,
    moves: 0,
    startTime: Date.now(),
    elapsed: 0,
    levelComplete: false,
    gameOver: false,
    animX: 0, animY: 0, // smooth animation offset
    moveQueue: [],
    inputCooldown: 0
  });
  mz.animX = 0;
  mz.animY = 0;
}

function updateMouseMaze(dt) {
  if (!mouseMazeActive || mz.gameOver || mz.levelComplete) return;
  mz.elapsed = Date.now() - mz.startTime;

  // Smooth animation toward current cell
  mz.animX += (0 - mz.animX) * 0.2;
  mz.animY += (0 - mz.animY) * 0.2;

  // Process move queue
  if (mz.inputCooldown > 0) mz.inputCooldown -= dt;
  if (mz.moveQueue.length > 0 && mz.inputCooldown <= 0) {
    const dir = mz.moveQueue.shift();
    tryMazeMove(dir);
    mz.inputCooldown = 80;
  }
}

function tryMazeMove(dir) {
  if (mz.levelComplete || mz.gameOver) return;
  const cell = mz.grid[mz.playerR][mz.playerC];
  let dr = 0, dc = 0;
  if (dir === 'up' && !cell.top) dr = -1;
  else if (dir === 'down' && !cell.bottom) dr = 1;
  else if (dir === 'left' && !cell.left) dc = -1;
  else if (dir === 'right' && !cell.right) dc = 1;
  else return;

  mz.animX = -dc * mz.cellSize;
  mz.animY = -dr * mz.cellSize;
  mz.playerR += dr;
  mz.playerC += dc;
  mz.moves++;

  // Check cheese collection
  mz.cheeses.forEach(ch => {
    if (!ch.collected && ch.r === mz.playerR && ch.c === mz.playerC) {
      ch.collected = true;
      mz.totalCheese++;
      sfxCheeseCollect();
      const px = mz.ox + mz.playerC * mz.cellSize + mz.cellSize / 2;
      const py = mz.oy + mz.playerR * mz.cellSize + mz.cellSize / 2;
      spawnFloatingEffect(px, py, '‚ú®');
    }
  });

  // Check exit
  if (mz.playerR === mz.exitR && mz.playerC === mz.exitC) {
    mz.levelComplete = true;
    const timeBonus = Math.max(0, 30 - Math.floor(mz.elapsed / 1000));
    mz.totalScore += mz.cheeses.filter(c => c.collected).length * 3 + timeBonus;
    sfxGoalComplete();
  }
}

function drawMouseMaze() {
  if (!mouseMazeActive) return;
  const t = Date.now() / 1000;

  // Background
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // HUD bar
  ctx.fillStyle = 'rgba(26,15,5,0.85)';
  ctx.fillRect(0, 0, GAME_W, 26);
  ctx.fillStyle = '#f5d68a';
  ctx.font = '12px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`üßÄ ${mz.totalCheese}`, 10, 17);
  ctx.textAlign = 'center';
  ctx.fillText(`Level ${mz.level}/3`, GAME_W / 2, 17);
  ctx.textAlign = 'right';
  const secs = Math.floor((mz.elapsed || 0) / 1000);
  ctx.fillText(`‚è± ${secs}s  |  ${mz.moves} moves`, GAME_W - 10, 17);
  ctx.textAlign = 'left';

  const { grid, cols, rows, cellSize, ox, oy } = mz;

  // Maze floor
  ctx.fillStyle = '#2b1d0e';
  ctx.fillRect(ox - 2, oy - 2, cols * cellSize + 4, rows * cellSize + 4);

  // Draw cells
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cx = ox + c * cellSize;
      const cy = oy + r * cellSize;
      const cell = grid[r][c];

      // Cell floor
      ctx.fillStyle = (r + c) % 2 === 0 ? '#3d2b1a' : '#362618';
      ctx.fillRect(cx, cy, cellSize, cellSize);

      // Walls
      ctx.strokeStyle = '#a07040';
      ctx.lineWidth = 2;
      if (cell.top) {
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + cellSize, cy); ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy + cellSize); ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath(); ctx.moveTo(cx, cy + cellSize); ctx.lineTo(cx + cellSize, cy + cellSize); ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath(); ctx.moveTo(cx + cellSize, cy); ctx.lineTo(cx + cellSize, cy + cellSize); ctx.stroke();
      }
    }
  }

  // Outer border
  ctx.strokeStyle = '#c89050';
  ctx.lineWidth = 3;
  ctx.strokeRect(ox, oy, cols * cellSize, rows * cellSize);

  // Exit marker (glowing)
  const exX = ox + mz.exitC * cellSize;
  const exY = oy + mz.exitR * cellSize;
  const glow = 0.4 + 0.3 * Math.sin(t * 3);
  ctx.fillStyle = `rgba(100, 220, 100, ${glow})`;
  ctx.fillRect(exX + 2, exY + 2, cellSize - 4, cellSize - 4);
  ctx.font = `${Math.min(cellSize - 6, 16)}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('üö™', exX + cellSize / 2, exY + cellSize / 2);

  // Cheese items
  mz.cheeses.forEach(ch => {
    if (ch.collected) return;
    const chX = ox + ch.c * cellSize + cellSize / 2;
    const chY = oy + ch.r * cellSize + cellSize / 2;
    const bob = Math.sin(t * 2 + ch.r + ch.c) * 2;
    ctx.font = `${Math.min(cellSize - 8, 14)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üßÄ', chX, chY + bob);
  });

  // Player mouse (Chai) with smooth animation
  const pxBase = ox + mz.playerC * cellSize;
  const pyBase = oy + mz.playerR * cellSize;
  const px = pxBase + mz.animX;
  const py = pyBase + mz.animY;
  // Scale mouse to fit cell
  const mouseDrawSize = Math.min(cellSize - 4, 28);
  const mScale = mouseDrawSize / 28;
  ctx.save();
  const mcx = px + cellSize / 2;
  const mcy = py + cellSize / 2;
  ctx.translate(mcx, mcy);
  ctx.scale(mScale, mScale);
  ctx.translate(-mcx, -mcy);
  drawMouse(px + (cellSize - 28) / 2, py + (cellSize - 20) / 2 - 2, CONFIG.mice.chai, 1, Math.floor(t * 4) % 4, 'walking');
  ctx.restore();

  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  // Floating effects
  drawFloatingEffects();

  // Level complete overlay
  if (mz.levelComplete) {
    ctx.fillStyle = 'rgba(26,15,5,0.75)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.fillStyle = '#f5d68a';
    ctx.font = '24px monospace';
    ctx.textAlign = 'center';
    if (mz.level >= 3) {
      ctx.fillText('üéâ Maze Complete!', GAME_W / 2, GAME_H / 2 - 40);
      const timeBonus = Math.max(0, 30 - Math.floor(mz.elapsed / 1000));
      ctx.font = '13px monospace';
      ctx.fillStyle = '#e8d5b5';
      ctx.fillText(`Cheese: üßÄ ${mz.totalCheese}  |  Time bonus: +${timeBonus}`, GAME_W / 2, GAME_H / 2 - 5);
      const earned = mz.totalScore;
      ctx.fillStyle = '#f5d68a';
      ctx.font = '16px monospace';
      ctx.fillText(`Earned: üßÄ ${earned} coins!`, GAME_W / 2, GAME_H / 2 + 25);
      ctx.fillStyle = '#a89070';
      ctx.font = '12px monospace';
      ctx.fillText('tap / click to continue', GAME_W / 2, GAME_H / 2 + 55);
    } else {
      ctx.fillText(`‚úÖ Level ${mz.level} Clear!`, GAME_W / 2, GAME_H / 2 - 20);
      ctx.font = '13px monospace';
      ctx.fillStyle = '#e8d5b5';
      ctx.fillText(`Cheese collected: üßÄ ${mz.totalCheese}`, GAME_W / 2, GAME_H / 2 + 10);
      ctx.fillStyle = '#a89070';
      ctx.font = '12px monospace';
      ctx.fillText('tap / click for next level', GAME_W / 2, GAME_H / 2 + 40);
    }
    ctx.textAlign = 'left';
  }
}

function endMouseMaze() {
  const earned = mz.totalScore;
  state.coins += earned;
  state.totalCoinsEarned += earned;
  addHappiness(6);
  updateCoinDisplay();
  saveGame();
  mouseMazeActive = false;
  sfxCoinCollect();
  spawnCoinEffect(earned, GAME_W / 2, GAME_H / 2 - 20);
  showToast(`Mouse Maze: earned üßÄ ${earned} coins!`);
}

function handleMazeInput(sx, sy) {
  if (mz.levelComplete) {
    if (mz.level >= 3) {
      endMouseMaze();
    } else {
      mz.level++;
      initMazeLevel(mz.level);
    }
    return;
  }
}

// Maze swipe/drag support
let mazeSwipeStart = null;

function mazeSwipeBegin(sx, sy) {
  mazeSwipeStart = { x: sx, y: sy };
}

function mazeSwipeEnd(sx, sy) {
  if (!mazeSwipeStart) return;
  const dx = sx - mazeSwipeStart.x;
  const dy = sy - mazeSwipeStart.y;
  mazeSwipeStart = null;
  const minDist = 15;
  if (Math.abs(dx) < minDist && Math.abs(dy) < minDist) return;
  if (Math.abs(dx) > Math.abs(dy)) {
    mz.moveQueue.push(dx > 0 ? 'right' : 'left');
  } else {
    mz.moveQueue.push(dy > 0 ? 'down' : 'up');
  }
}

// ============================================================
// BIRTHDAY EVENT
// ============================================================
function triggerBirthdayEvent() {
  if (state.birthdayEventSeen) return;
  state.birthdayEventSeen = true;

  // Give birthday items
  if (!state.ownedItems.includes('birthday-cake')) state.ownedItems.push('birthday-cake');
  if (!state.ownedItems.includes('party-banner')) state.ownedItems.push('party-banner');

  // Place them in the living room
  state.placedItems.push({ itemId: 'party-banner', room: 2, gridX: 3, gridY: 0 });
  state.placedItems.push({ itemId: 'birthday-cake', room: 2, gridX: 8, gridY: GRID_ROWS - 1 });

  // Bonus coins
  state.coins += 100;
  state.totalCoinsEarned += 100;
  updateCoinDisplay();

  // Both mice to living room for the party
  state.miceState.pip.room = 2;
  state.miceState.pip.x = 150;
  state.miceState.pip.action = 'idle';
  state.miceState.pip.actionTimer = 6000;
  state.miceState.chai.room = 2;
  state.miceState.chai.x = 280;
  state.miceState.chai.action = 'idle';
  state.miceState.chai.actionTimer = 6000;

  // Switch to living room
  state.currentRoom = 2;
  buildRoomTabs();

  addHappiness(20);
  saveGame();

  // Celebration sequence
  setTimeout(() => {
    sfxFanfare();
    showToast(`üéÇ Happy Birthday ${CONFIG.twins.name1} & ${CONFIG.twins.name2}! üéâ`);
    // Confetti burst
    for (let i = 0; i < 20; i++) {
      setTimeout(() => {
        spawnFloatingEffect(
          80 + Math.random() * (GAME_W - 160),
          ROOM_Y + 50 + Math.random() * 100,
          ['üéâ','üéä','üéÇ','üßÄ','üíõ','‚≠ê','üéà','‚ú®'][Math.floor(Math.random() * 8)]
        );
      }, i * 80);
    }
  }, 500);

  setTimeout(() => {
    showToast('üßÄ +100 bonus coins! The mice threw a party!');
  }, 4000);

  setTimeout(() => {
    showToast('üíå Check the letter button for a special message!');
  }, 7500);
}

// ============================================================
// BIRTHDAY LETTER
// ============================================================
function openLetter() {
  state.letterRead = true;
  saveGame();
  const container = document.getElementById('modal-container');
  const msgHtml = CONFIG.birthdayMessage.replace(/\n/g, '<br>');
  container.innerHTML = `<div class="modal-overlay" onclick="if(event.target===this)closeModal()">
    <div class="modal-content" style="max-width:480px;">
      <h2>üíå A Letter for You</h2>
      <div class="letter-content">
        <h3>üê≠ Special Delivery üê≠</h3>
        ${msgHtml}
      </div>
      <button class="close-btn" onclick="closeModal()">üíõ</button>
    </div>
  </div>`;
}

// ============================================================
// PARTY HATS (drawn on mice during birthday)
// ============================================================
function drawPartyHat(x, y, action, dir, cfg) {
  if (!state.birthdayEventSeen) return;
  const mouseScale = (cfg && cfg.scale) || 1.0;
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  const t = Date.now() / 1000;
  const bob = action === 'sleeping' ? 0 : Math.sin(t * 3) * 0.6;

  ctx.save();

  // Apply same scale transform as drawMouse so hat aligns
  if (mouseScale !== 1.0) {
    const pivotX = cx + 14;
    const pivotY = cy + 20;
    ctx.translate(pivotX, pivotY);
    ctx.scale(mouseScale, mouseScale);
    ctx.translate(-pivotX, -pivotY);
  }
  // Apply same flip as drawMouse so hat stays on top of head
  if (dir < 0) {
    ctx.translate(cx + 14, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(cx + 14), 0);
  }

  let hatX, hatY;
  if (action === 'sleeping') {
    hatX = cx + 17; hatY = cy + 1;
  } else {
    hatX = cx + 19; hatY = cy - 6 + bob;
  }

  // Hat body (cone)
  ctx.fillStyle = '#FF1493';
  ctx.beginPath();
  ctx.moveTo(hatX, hatY - 10);
  ctx.lineTo(hatX - 5, hatY + 2);
  ctx.lineTo(hatX + 5, hatY + 2);
  ctx.closePath();
  ctx.fill();

  // Stripe
  ctx.fillStyle = '#FFD700';
  ctx.fillRect(hatX - 4, hatY - 2, 8, 2);

  // Pom pom on top
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.arc(hatX, hatY - 10, 2.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// ============================================================
// COIN FLOATING ANIMATION
// ============================================================
function spawnCoinEffect(amount, x, y) {
  if (x === undefined) x = GAME_W / 2;
  if (y === undefined) y = 30;
  for (let i = 0; i < Math.min(amount / 2, 8); i++) {
    setTimeout(() => {
      spawnFloatingEffect(
        x + (Math.random() - 0.5) * 40,
        y + Math.random() * 20,
        'üßÄ'
      );
    }, i * 120);
  }
}

// ============================================================
// HAPPINESS SYSTEM
// ============================================================
const HAPPINESS_DECAY_RATE = 0.0003; // very slow: ~1 point per ~55 minutes

function getAverageHappiness() {
  return Math.round((state.miceState.pip.happiness + state.miceState.chai.happiness) / 2);
}

function addHappiness(amount) {
  state.miceState.pip.happiness = Math.min(100, state.miceState.pip.happiness + amount);
  state.miceState.chai.happiness = Math.min(100, state.miceState.chai.happiness + amount);
  updateHappinessDisplay();
}

function updateHappiness(dt) {
  state.miceState.pip.happiness = Math.max(10, state.miceState.pip.happiness - HAPPINESS_DECAY_RATE * dt);
  state.miceState.chai.happiness = Math.max(10, state.miceState.chai.happiness - HAPPINESS_DECAY_RATE * dt);
  updateHappinessDisplay();
}

function updateHappinessDisplay() {
  const avg = getAverageHappiness();
  const el = document.getElementById('happiness-value');
  if (el) el.textContent = avg;
  // Color the heart based on level
  const hd = document.getElementById('happiness-display');
  if (hd) {
    if (avg >= 70) hd.style.color = '#f5d68a';
    else if (avg >= 40) hd.style.color = '#e8a040';
    else hd.style.color = '#e06050';
  }
}

// ============================================================
// GOALS / WISHES SYSTEM
// ============================================================
const GOAL_TEMPLATES = [
  { text: '{mouse} wants a cozy bed üõè', itemId: 'matchbox-bed' },
  { text: '{mouse} is craving cheese üßÄ', itemId: 'cheese-wheel' },
  { text: '{mouse} wants a coffee ‚òï', itemId: 'thimble-cup' },
  { text: '{mouse} wants to doomscroll üíª', itemId: 'tiny-laptop' },
  { text: '{mouse} needs a yoga session üßò', itemId: 'yoga-mat' },
  { text: '{mouse} wants to watch TV üì∫', itemId: 'eraser-tv' },
  { text: '{mouse} wants aesthetic lights ‚ú®', itemId: 'fairy-lights' },
  { text: '{mouse} wants a plant friend ü™¥', itemId: 'tiny-plant' },
  { text: '{mouse} needs a disco ball ü™©', itemId: 'disco-ball' },
  { text: '{mouse} wants to sit somewhere üõã', itemId: 'cardboard-couch' },
  { text: '{mouse} craves sourdough üçû', itemId: 'sourdough' },
  { text: '{mouse} wants the vibes sign üìú', itemId: 'live-laugh-cheese' },
];

let goalCooldown = 20000 + Math.random() * 15000;

function updateGoals(dt) {
  // Check if current goal is fulfilled
  if (state.activeGoal) {
    const isPlaced = state.placedItems.some(p => p.itemId === state.activeGoal.itemId);
    if (isPlaced) {
      // Goal completed!
      const bonus = 15;
      state.coins += bonus;
      state.totalCoinsEarned += bonus;
      addHappiness(10);
      updateCoinDisplay();
      spawnCoinEffect(bonus);
      sfxGoalComplete();
      showToast(`‚úÖ Goal complete! ${state.activeGoal.text} ‚Äî +üßÄ${bonus} +‚ù§Ô∏è!`);
      state.activeGoal = null;
      updateGoalDisplay();
      saveGame();
      goalCooldown = 25000 + Math.random() * 20000;
      return;
    }
  }

  // Generate new goal if none active
  if (!state.activeGoal) {
    goalCooldown -= dt;
    if (goalCooldown <= 0) {
      generateNewGoal();
      goalCooldown = 30000 + Math.random() * 20000;
    }
  }
}

function generateNewGoal() {
  // Pick a goal for an item not yet placed
  const unplaced = GOAL_TEMPLATES.filter(g =>
    !state.placedItems.some(p => p.itemId === g.itemId)
  );
  if (unplaced.length === 0) return;

  const template = unplaced[Math.floor(Math.random() * unplaced.length)];
  const mouseKey = Math.random() < 0.5 ? 'pip' : 'chai';
  const mouseName = CONFIG.mice[mouseKey].name;
  const text = template.text.replace('{mouse}', mouseName);

  state.activeGoal = { text, itemId: template.itemId, mouseKey };
  updateGoalDisplay();
  saveGame();

  // Mouse says the wish
  const mouse = state.miceState[mouseKey];
  speechBubbles.push({
    x: mouse.x + 14, y: MOUSE_FLOOR_Y - 10,
    text: text, timer: 4000, maxTimer: 4000, mouseKey
  });
}

function updateGoalDisplay() {
  const el = document.getElementById('goal-display');
  const row2 = document.getElementById('hud-row2');
  if (!el || !row2) return;
  if (state.activeGoal) {
    el.textContent = `üéØ ${state.activeGoal.text}`;
    el.title = `Place ${FURNITURE.find(f => f.id === state.activeGoal.itemId)?.name || 'the item'} to complete!`;
    row2.classList.add('visible');
  } else {
    el.textContent = '';
    el.title = '';
    row2.classList.remove('visible');
  }
}

// ============================================================
// MOUSE SPRITE DRAWING
// ============================================================
const MOUSE_FLOOR_Y = ROOM_Y + ROOM_H - FLOOR_H - 20;

function drawMouse(x, y, cfg, dir, frame, action) {
  const mouseScale = cfg.scale || 1.0;
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  const t = Date.now() / 1000;

  ctx.save();
  // Apply mouse-specific scale (Pip is larger)
  if (mouseScale !== 1.0) {
    const pivotX = cx + 14;
    const pivotY = cy + 20; // scale from feet so they stay on ground
    ctx.translate(pivotX, pivotY);
    ctx.scale(mouseScale, mouseScale);
    ctx.translate(-pivotX, -pivotY);
  }
  if (dir < 0) {
    ctx.translate(cx + 14, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(cx + 14), 0);
  }

  if (action === 'sleeping') {
    // Body
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 12, 11, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    // Belly highlight
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 13, 7, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    // Head tucked in
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy + 8, 6, 5, 0.3, 0, Math.PI * 2);
    ctx.fill();
    // Ear
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 3, 4, 5, 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 3, 2.5, 3, 0.4, 0, Math.PI * 2);
    ctx.fill();
    // Tail curled
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy + 12);
    ctx.quadraticCurveTo(cx - 8, cy + 6, cx - 4, cy + 2);
    ctx.stroke();
    // Zzz
    const zOff = Math.sin(t * 2) * 2;
    ctx.fillStyle = 'rgba(200,200,255,0.6)';
    ctx.font = '8px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('z', cx + 22, cy - 1 + zOff);
    ctx.font = '11px monospace';
    ctx.fillText('z', cx + 27, cy - 7 + zOff * 1.3);
    ctx.font = '13px monospace';
    ctx.fillText('Z', cx + 32, cy - 14 + zOff * 1.6);
    ctx.textAlign = 'left';
  } else if (action === 'zoomies') {
    // Fast running mouse with motion blur!
    const zBob = Math.sin(t * 14) * 2;
    const zFrame = Math.floor(t * 12) % 2;

    // Motion lines behind
    ctx.strokeStyle = 'rgba(200,180,140,0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(cx - 4 - i * 6, cy + 6 + i * 3 + zBob);
      ctx.lineTo(cx - 12 - i * 6, cy + 6 + i * 3 + zBob);
      ctx.stroke();
    }

    // Shadow (stretched)
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(cx + 14, cy + 20, 16, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tail streaming
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(cx, cy + 10 + zBob);
    ctx.quadraticCurveTo(cx - 12, cy + 4 + zBob, cx - 16, cy + 8 + zBob);
    ctx.stroke();
    ctx.lineCap = 'butt';

    // Legs (alternating fast)
    ctx.fillStyle = cfg.bodyColor;
    const legOff = zFrame * 4;
    ctx.fillRect(cx + 4 + legOff, cy + 15 + zBob, 3, 6);
    ctx.fillRect(cx + 14 - legOff, cy + 15 + zBob, 3, 6);
    ctx.fillStyle = cfg.bellyColor;
    ctx.fillRect(cx + 3 + legOff, cy + 20 + zBob, 5, 2);
    ctx.fillRect(cx + 13 - legOff, cy + 20 + zBob, 5, 2);

    // Body (stretched)
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 12, cy + 10 + zBob, 12, 7, -0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 12, cy + 12 + zBob, 7, 4, -0.1, 0, Math.PI * 2);
    ctx.fill();

    // Head (forward-leaning)
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 22, cy + 4 + zBob, 7, 5.5, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Ears (windswept)
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy - 3 + zBob, 4, 5, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy - 3 + zBob, 2.5, 3, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 24, cy - 2 + zBob, 4, 5, -0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 24, cy - 2 + zBob, 2.5, 3, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // Wide excited eyes
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.ellipse(cx + 20, cy + 2 + zBob, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 25, cy + 2 + zBob, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(cx + 20.5, cy + 1 + zBob, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + 25.5, cy + 1 + zBob, 1, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = cfg.noseColor;
    ctx.beginPath();
    ctx.ellipse(cx + 29, cy + 4 + zBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Open mouth (excitement!)
    ctx.fillStyle = '#2a1a1a';
    ctx.beginPath();
    ctx.ellipse(cx + 27, cy + 6 + zBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

  } else {
    // Standing / walking / idle / furniture-interaction mouse
    const isFurnitureAction = ['doomscrolling','watching','yoga','eating','playing'].includes(action);
    const breathe = Math.sin(t * 3) * 0.6;
    const bob = action === 'walking' ? Math.sin(t * 10) * 1.5 : breathe;
    const lean = action === 'walking' ? Math.sin(t * 10) * 0.03 :
                 action === 'yoga' ? Math.sin(t * 2) * 0.06 : 0;

    ctx.translate(cx + 14, cy + 18);
    ctx.rotate(lean);
    ctx.translate(-(cx + 14), -(cy + 18));

    // Shadow on floor
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(cx + 14, cy + 20, 12, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tail
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    const tailWag = Math.sin(t * 4) * 4;
    ctx.beginPath();
    ctx.moveTo(cx + 2, cy + 12 + bob);
    ctx.quadraticCurveTo(cx - 8, cy + 4 + tailWag, cx - 12, cy + 8 + tailWag);
    ctx.stroke();
    ctx.lineCap = 'butt';

    // Back legs
    const legAnim = action === 'walking' ? Math.sin(t * 10) * 3 : 0;
    ctx.fillStyle = cfg.bodyColor;
    ctx.fillRect(cx + 4 - legAnim, cy + 16 + bob, 4, 5);
    ctx.fillRect(cx + 12 + legAnim, cy + 16 + bob, 4, 5);
    // Tiny feet
    ctx.fillStyle = cfg.bellyColor;
    ctx.fillRect(cx + 3 - legAnim, cy + 20 + bob, 5, 2);
    ctx.fillRect(cx + 11 + legAnim, cy + 20 + bob, 5, 2);

    // Body (rounded)
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 11 + bob, 10, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 13 + bob, 6, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 5 + bob, 7, 6, 0.15, 0, Math.PI * 2);
    ctx.fill();

    // Ears (big & round!)
    // Left ear
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 15, cy - 4 + bob, 5, 6, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 15, cy - 4 + bob, 3, 4, -0.3, 0, Math.PI * 2);
    ctx.fill();
    // Right ear
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 23, cy - 4 + bob, 5, 6, 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 23, cy - 4 + bob, 3, 4, 0.3, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (big & cute)
    if (action === 'doomscrolling' || action === 'watching') {
      // Screen-glow eyes
      ctx.fillStyle = '#66ccff';
      ctx.beginPath();
      ctx.ellipse(cx + 17, cy + 3 + bob, 2.2, 2.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22, cy + 3 + bob, 2.2, 2.8, 0, 0, Math.PI * 2);
      ctx.fill();
    } else if (action === 'yoga') {
      // Closed peaceful eyes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx + 17, cy + 3 + bob, 2, 0.3, Math.PI - 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx + 22, cy + 3 + bob, 2, 0.3, Math.PI - 0.3);
      ctx.stroke();
    } else if (action === 'eating') {
      // Happy squinty eyes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx + 17, cy + 4 + bob, 2, Math.PI + 0.3, -0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx + 22, cy + 4 + bob, 2, Math.PI + 0.3, -0.3);
      ctx.stroke();
    } else {
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.ellipse(cx + 17, cy + 3 + bob, 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22, cy + 3 + bob, 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx + 17.5, cy + 2 + bob, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 22.5, cy + 2 + bob, 0.8, 0, Math.PI * 2);
      ctx.fill();
    }

    // Nose (tiny pink)
    ctx.fillStyle = cfg.noseColor;
    ctx.beginPath();
    ctx.ellipse(cx + 26, cy + 5 + bob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Whiskers
    ctx.strokeStyle = 'rgba(180,160,140,0.5)';
    ctx.lineWidth = 0.7;
    ctx.beginPath();
    ctx.moveTo(cx + 25, cy + 5 + bob);
    ctx.lineTo(cx + 32, cy + 2 + bob);
    ctx.moveTo(cx + 25, cy + 6 + bob);
    ctx.lineTo(cx + 32, cy + 7 + bob);
    ctx.moveTo(cx + 25, cy + 5.5 + bob);
    ctx.lineTo(cx + 33, cy + 4.5 + bob);
    ctx.stroke();

    // Tiny smile
    ctx.strokeStyle = 'rgba(100,60,60,0.3)';
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(cx + 23, cy + 6 + bob, 3, 0.2, 1.2);
    ctx.stroke();
  }

  ctx.restore();
}

// ============================================================
// MOUSE AI
// ============================================================
function updateMouse(mouse, dt, personality) {
  // Handle flung state separately
  if (mouse.action === 'flung') {
    updateFlungMouse(mouse, dt);
    return;
  }

  // Wheeling mice don't move normally ‚Äî they're on the wheel
  if (mouse.action === 'wheeling') {
    mouse.actionTimer -= dt;
    if (mouse.actionTimer <= 0) {
      mouse.action = 'idle';
      mouse.actionTimer = 2000 + Math.random() * 2000;
      // Step off the wheel ‚Äî reposition to nearby floor
      const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === mouse.room);
      if (wheelPlaced) {
        const center = getWheelCenter(wheelPlaced);
        mouse.x = center.x + (Math.random() < 0.5 ? -40 : 40);
        mouse.x = Math.max(15, Math.min(ROOM_W - 45, mouse.x));
      }
    }
    return;
  }

  // Animation timer
  mouse.animTimer += dt;
  if (mouse.animTimer > 180) {
    mouse.frame = (mouse.frame + 1) % 4;
    mouse.animTimer = 0;
  }

  // Action timer countdown
  mouse.actionTimer -= dt;
  if (mouse.actionTimer <= 0) {
    pickNewAction(mouse, personality);
  }

  // Movement
  if (mouse.action === 'walking' && mouse.targetX !== undefined) {
    const speed = 0.05 * dt;
    const dist = mouse.targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.x = mouse.targetX;
      mouse.targetX = undefined;
      mouse.action = 'idle';
      mouse.actionTimer = 1500 + Math.random() * 2000;
    }
  } else if (mouse.action === 'zoomies') {
    const speed = 0.15 * dt;
    mouse.x += mouse.dir * speed;
    if (mouse.x > ROOM_W - 50) { mouse.dir = -1; }
    if (mouse.x < 20) { mouse.dir = 1; }
  } else if (mouse.targetX !== undefined) {
    // Walk toward furniture target for any behavior
    const speed = 0.04 * dt;
    const dist = mouse.targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.targetX = undefined;
    }
  }

  // Clamp to room bounds
  mouse.x = Math.max(15, Math.min(ROOM_W - 45, mouse.x));
}

function pickNewAction(mouse, personality) {
  const roll = Math.random();

  // Chance to switch rooms
  if (roll < 0.1) {
    const newRoom = Math.floor(Math.random() * ROOMS.length);
    if (newRoom !== mouse.room) {
      mouse.room = newRoom;
      mouse.x = 30 + Math.random() * (ROOM_W - 90);
    }
    mouse.action = 'idle';
    mouse.actionTimer = 1000 + Math.random() * 1500;
    return;
  }

  // Check what furniture behaviors are available in this room
  const roomItems = state.placedItems.filter(p => p.room === mouse.room);
  const furnitureBehaviors = [];
  roomItems.forEach(placed => {
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (item && item.mouseBehavior && !furnitureBehaviors.includes(item.mouseBehavior)) {
      furnitureBehaviors.push({ behavior: item.mouseBehavior, placed });
    }
  });

  // 40% chance to interact with furniture if any is available
  if (furnitureBehaviors.length > 0 && Math.random() < 0.4) {
    let pick;
    // Pip is hungrier ‚Äî strongly prefers food items
    const foodBehaviors = furnitureBehaviors.filter(fb => fb.behavior === 'eating');
    if (personality === 'chaotic' && foodBehaviors.length > 0 && Math.random() < 0.6) {
      pick = foodBehaviors[Math.floor(Math.random() * foodBehaviors.length)];
    } else {
      // Both mice love the exercise wheel ‚Äî high preference
      const wheelBehaviors = furnitureBehaviors.filter(fb => fb.behavior === 'wheeling');
      if (wheelBehaviors.length > 0 && Math.random() < 0.5) {
        pick = wheelBehaviors[0];
      } else {
        pick = furnitureBehaviors[Math.floor(Math.random() * furnitureBehaviors.length)];
      }
    }
    mouse.action = pick.behavior;
    const targetPos = gridToGame(pick.placed.gridX, pick.placed.gridY);
    mouse.targetX = targetPos.x + Math.random() * 10;
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 3000 + Math.random() * 4000;
    if (pick.behavior === 'sleeping') mouse.actionTimer = 5000 + Math.random() * 5000;
    if (pick.behavior === 'zoomies') mouse.actionTimer = 2000 + Math.random() * 2000;
    if (pick.behavior === 'wheeling') mouse.actionTimer = 6000 + Math.random() * 8000; // mice love the wheel
    return;
  }

  // Personality-weighted action selection
  let weights;
  if (personality === 'chaotic') {
    weights = [
      { action: 'idle', w: 20 },
      { action: 'walking', w: 35 },
      { action: 'sleeping', w: 12 },
      { action: 'zoomies', w: 18 }
    ];
  } else {
    weights = [
      { action: 'idle', w: 30 },
      { action: 'walking', w: 25 },
      { action: 'sleeping', w: 30 },
      { action: 'zoomies', w: 5 }
    ];
  }

  const totalW = weights.reduce((s, w) => s + w.w, 0);
  let pick = Math.random() * totalW;
  let chosen = 'idle';
  for (const w of weights) {
    pick -= w.w;
    if (pick <= 0) { chosen = w.action; break; }
  }

  mouse.action = chosen;

  if (chosen === 'walking') {
    mouse.targetX = 20 + Math.random() * (ROOM_W - 70);
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 8000;
  } else if (chosen === 'sleeping') {
    mouse.actionTimer = 5000 + Math.random() * 6000;
  } else if (chosen === 'zoomies') {
    mouse.actionTimer = 2500 + Math.random() * 2000;
    mouse.dir = Math.random() < 0.5 ? 1 : -1;
    if (mouse.room === state.currentRoom) sfxZoomies();
  } else {
    mouse.actionTimer = 2000 + Math.random() * 3000;
  }
}

// Draw status bar at the bottom showing mouse names + actions
function drawMouseStatus() {
  const pip = state.miceState.pip;
  const chai = state.miceState.chai;
  const y = GAME_H - 8;

  ctx.save();
  ctx.font = '10px monospace';
  ctx.textBaseline = 'alphabetic';

  const actionIcons = { sleeping: 'üí§', walking: 'üêæ', zoomies: 'üí®', eating: 'üòã',
    doomscrolling: 'üì±', watching: 'üì∫', yoga: 'üßò', playing: 'üèÉ',
    wheeling: 'üé°', flung: 'üòµ‚Äçüí´' };

  // Pip status (left)
  const sIcon = actionIcons[pip.action] || '‚ú®';
  let pipText = `${sIcon} ${CONFIG.mice.pip.name}: ${pip.action}`;
  if (pip.room !== state.currentRoom) {
    pipText += ` (${ROOMS[pip.room].icon})`;
  }
  ctx.fillStyle = '#888';
  ctx.textAlign = 'left';
  ctx.fillText(pipText, 8, y);

  // Chai status (right)
  const cIcon = actionIcons[chai.action] || '‚ú®';
  let chaiText = `${cIcon} ${CONFIG.mice.chai.name}: ${chai.action}`;
  if (chai.room !== state.currentRoom) {
    chaiText += ` (${ROOMS[chai.room].icon})`;
  }
  ctx.fillStyle = '#888';
  ctx.textAlign = 'right';
  ctx.fillText(chaiText, GAME_W - 8, y);

  ctx.restore();
}

// ============================================================
// SPEECH BUBBLES & FLOATING EFFECTS
// ============================================================
const PIP_QUOTES = [
  'no thoughts head empty', 'chaos mode activated', 'catch me if you can üí®',
  'it\'s giving... gremlin', 'slay', 'built different tbh', 'caught in 4k üì∏',
  'living my best cheese life', 'zero chill, full send', 'main character energy',
  'this is fine üî•', 'unhinged and unbothered', 'speed run any%', 'yeet',
  'bet', 'say less', 'lowkey feral rn', 'bestie wake up', 'ZOOM', 'not sorry üòà',
  'is there more cheese??', 'snack break? snack break.', 'I smell food üëÉ',
  'built different (and hungry)', 'cheese is a personality trait'
];
const CHAI_QUOTES = [
  'this is giving cozy', 'soft hours only üåô', 'no thoughts, just vibes',
  'not me napping again', 'it\'s giving... mouse', 'sleepy but slay',
  'wholesome content only', 'living slow üêå', 'comfort is key', 'gentle chaos',
  'self care is sleeping', 'cozy era', 'manifesting cheese ‚ú®', 'just existing üí´',
  'zzz is a lifestyle', 'pls don\'t wake me', 'warm thoughts only', 'soft launch üßÄ',
  'cottagecore mouse', 'peace was always an option üïä'
];

const WHEEL_QUOTES = [
  'CARDIO üí™', 'fitness era', 'running from my problems',
  'marathon training arc', 'can\'t stop won\'t stop', 'legs go brrr',
  'gym rat? no. gym MOUSE', 'my fitbit is shaking',
  'hot mouse summer prep', 'this counts as a marathon right',
  'i am speed üèÉ', 'wheeeeel!', 'spinning into my best self'
];

let speechBubbles = [];  // { x, y, text, timer, maxTimer, mouseKey }
let floatingEffects = []; // { x, y, text, timer, vy }

let speechCooldown = 8000 + Math.random() * 7000; // 8-15 sec

function triggerSpeech(mouseKey) {
  const mouse = state.miceState[mouseKey];
  if (mouse.room !== state.currentRoom) return;
  let quotes;
  if (mouse.action === 'wheeling') {
    quotes = WHEEL_QUOTES;
  } else {
    quotes = mouseKey === 'pip' ? PIP_QUOTES : CHAI_QUOTES;
  }
  const text = quotes[Math.floor(Math.random() * quotes.length)];
  speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
  speechBubbles.push({
    x: mouse.x + 14,
    y: MOUSE_FLOOR_Y - 10,
    text, timer: 3000, maxTimer: 3000, mouseKey
  });
  sfxSpeechBubble();
}

function updateSpeechBubbles(dt) {
  speechCooldown -= dt;
  if (speechCooldown <= 0) {
    speechCooldown = 8000 + Math.random() * 7000;
    // Pick a random mouse to speak
    const mouseKey = Math.random() < 0.5 ? 'pip' : 'chai';
    triggerSpeech(mouseKey);
  }
  speechBubbles.forEach(b => {
    b.timer -= dt;
    // Track mouse position (handle wheel and flung states)
    const mouse = state.miceState[b.mouseKey];
    if (mouse.action === 'flung' && mouse.flingX !== undefined) {
      b.x = mouse.flingX + 14;
      b.y = mouse.flingY - 10;
    } else if (mouse.action === 'wheeling') {
      const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === mouse.room);
      if (wheelPlaced) {
        const center = getWheelCenter(wheelPlaced);
        b.x = center.x;
        b.y = center.y - 40;
      }
    } else {
      b.x = mouse.x + 14;
      b.y = MOUSE_FLOOR_Y - 10;
    }
  });
  speechBubbles = speechBubbles.filter(b => b.timer > 0);
}

function drawSpeechBubbles() {
  speechBubbles.forEach(b => {
    const alpha = Math.min(1, b.timer / 500); // fade out last 500ms
    ctx.globalAlpha = alpha;
    ctx.font = '9px monospace';
    const tw = ctx.measureText(b.text).width;
    const pw = tw + 12;
    const ph = 18;
    const px = Math.max(4, Math.min(GAME_W - pw - 4, b.x - pw / 2));
    const py = b.y - ph - 8;

    // Bubble bg
    ctx.fillStyle = 'rgba(255,250,240,0.92)';
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, 6);
    ctx.fill();
    // Bubble border
    ctx.strokeStyle = 'rgba(180,150,100,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, 6);
    ctx.stroke();
    // Tail triangle
    ctx.fillStyle = 'rgba(255,250,240,0.92)';
    ctx.beginPath();
    ctx.moveTo(b.x - 4, py + ph);
    ctx.lineTo(b.x, py + ph + 6);
    ctx.lineTo(b.x + 4, py + ph);
    ctx.fill();
    // Text
    ctx.fillStyle = '#3a2a1a';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.text, px + pw / 2, py + ph / 2);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.globalAlpha = 1.0;
  });
}

function spawnFloatingEffect(x, y, text) {
  floatingEffects.push({ x, y, text, timer: 1200, vy: -0.04 });
}

function updateFloatingEffects(dt) {
  floatingEffects.forEach(e => {
    e.timer -= dt;
    e.y += e.vy * dt;
    e.x += Math.sin(Date.now() / 200 + e.y) * 0.15;
  });
  floatingEffects = floatingEffects.filter(e => e.timer > 0);
}

function drawFloatingEffects() {
  floatingEffects.forEach(e => {
    const alpha = Math.min(1, e.timer / 400);
    ctx.globalAlpha = alpha;
    ctx.font = '14px serif';
    ctx.textAlign = 'center';
    ctx.fillText(e.text, e.x, e.y);
    ctx.textAlign = 'left';
    ctx.globalAlpha = 1.0;
  });
}

// ============================================================
// CLICK-TO-PET
// ============================================================
function tryPetMouse(gx, gy) {
  const mice = [
    { key: 'pip', state: state.miceState.pip, cfg: CONFIG.mice.pip },
    { key: 'chai', state: state.miceState.chai, cfg: CONFIG.mice.chai }
  ];
  for (const m of mice) {
    if (m.state.room !== state.currentRoom) continue;
    const mx = m.state.x;
    const my = MOUSE_FLOOR_Y;
    if (gx > mx - 5 && gx < mx + 30 && gy > my - 10 && gy < my + 25) {
      // Pet this mouse!
      sfxPet();
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          spawnFloatingEffect(
            mx + 10 + (Math.random() - 0.5) * 20,
            my - 5 - Math.random() * 15,
            ['‚ù§Ô∏è', 'üíï', 'üíñ', 'üíó', 'ü•∞'][Math.floor(Math.random() * 5)]
          );
        }, i * 100);
      }
      // Mouse reacts
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== m.key);
      const petQuotes = m.key === 'pip'
        ? ['okay that\'s nice', 'more pls ü•∫', '*purrs in mouse*', 'acceptable', 'don\'t stop üëÄ', 'feed me tho']
        : ['ü•∞ü•∞ü•∞', 'best day ever', '*happy squeak*', 'i love you', 'this is everything'];
      speechBubbles.push({
        x: mx + 14, y: MOUSE_FLOOR_Y - 10,
        text: petQuotes[Math.floor(Math.random() * petQuotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey: m.key
      });
      // Briefly pause their action (they enjoy it)
      m.state.action = 'idle';
      m.state.actionTimer = 2500;
      m.state.happiness = Math.min(100, (m.state.happiness || 80) + 5);
      return true;
    }
  }
  return false;
}

// ============================================================
// MOUSE INTERACTIONS (when both in same room)
// ============================================================
let interactionCooldown = 12000 + Math.random() * 8000;

function updateMouseInteractions(dt) {
  const s = state.miceState.pip;
  const c = state.miceState.chai;
  if (s.room !== c.room) { interactionCooldown = 5000 + Math.random() * 5000; return; }

  interactionCooldown -= dt;
  if (interactionCooldown > 0) return;
  interactionCooldown = 15000 + Math.random() * 10000;

  const interaction = Math.random();

  if (interaction < 0.35) {
    // Nuzzle: move toward each other
    const midX = (s.x + c.x) / 2;
    s.action = 'walking'; s.targetX = midX - 15; s.dir = 1;
    c.action = 'walking'; c.targetX = midX + 15; c.dir = -1;
    s.actionTimer = 4000; c.actionTimer = 4000;
    setTimeout(() => {
      if (s.room === c.room && s.room === state.currentRoom) {
        spawnFloatingEffect((s.x + c.x) / 2 + 14, MOUSE_FLOOR_Y - 10, 'üíï');
        triggerSpeech(Math.random() < 0.5 ? 'pip' : 'chai');
      }
    }, 2000);
  } else if (interaction < 0.65) {
    // Play-chase: Pip chases Chai (or vice versa)
    const chaser = Math.random() < 0.6 ? s : c;
    const runner = chaser === s ? c : s;
    const chaserKey = chaser === s ? 'pip' : 'chai';
    runner.action = 'walking';
    runner.targetX = Math.random() < 0.5 ? 40 : ROOM_W - 60;
    runner.dir = runner.targetX > runner.x ? 1 : -1;
    runner.actionTimer = 4000;
    chaser.action = 'walking';
    chaser.dir = runner.dir;
    chaser.actionTimer = 4000;
    // Chase after a small delay
    setTimeout(() => {
      chaser.targetX = runner.targetX + (Math.random() < 0.5 ? -20 : 20);
    }, 400);
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== chaserKey);
    speechBubbles.push({
      x: chaser.x + 14, y: MOUSE_FLOOR_Y - 10,
      text: chaserKey === 'pip' ? 'get back here! üí®' : 'wheee! üèÉ',
      timer: 2000, maxTimer: 2000, mouseKey: chaserKey
    });
  } else {
    // Judging: one mouse stares at the other
    const judger = Math.random() < 0.6 ? s : c;
    const judgerKey = judger === s ? 'pip' : 'chai';
    judger.action = 'idle';
    judger.actionTimer = 4000;
    judger.dir = (judger === s ? c.x : s.x) > judger.x ? 1 : -1;
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== judgerKey);
    speechBubbles.push({
      x: judger.x + 14, y: MOUSE_FLOOR_Y - 10,
      text: judgerKey === 'pip'
        ? ['sus ü§®', 'cringe', 'who asked?', 'bruh'][Math.floor(Math.random() * 4)]
        : ['rude', 'don\'t look at me', 'why tho', 'üòê'][Math.floor(Math.random() * 4)],
      timer: 3000, maxTimer: 3000, mouseKey: judgerKey
    });
  }
}
canvas.addEventListener('mousedown', e => handleCanvasInput(e.clientX, e.clientY, e));
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  handleCanvasInput(e.touches[0].clientX, e.touches[0].clientY, e);
}, { passive: false });

function handleCanvasInput(sx, sy, originalEvent) {
  const pos = screenToGame(sx, sy);

  // Cheese Chase input
  if (cheeseChaseActive) {
    if (cc.gameOver) {
      endCheeseChase();
      return;
    }
    ccInputY = pos.y;
    return;
  }

  // Mouse Maze input
  if (mouseMazeActive) {
    handleMazeInput(sx, sy);
    mazeSwipeBegin(pos.x, pos.y);
    return;
  }

  // Check if clicking/touching a placed item to pick it up for repositioning
  if (state.shopOpen || state.dragState.active) {
    const placedIdx = findPlacedItemAt(pos.x, pos.y);
    if (placedIdx >= 0) {
      const placed = state.placedItems[placedIdx];
      const item = FURNITURE.find(f => f.id === placed.itemId);
      if (item && !item.exerciseRoom) {
        startDrag(placed.itemId, sx, sy, true, placedIdx);
        return;
      }
    }
  }

  // Try petting a mouse
  if (tryPetMouse(pos.x, pos.y)) return;
}

canvas.addEventListener('mousemove', e => {
  if (cheeseChaseActive && !cc.gameOver) ccInputY = screenToGame(e.clientX, e.clientY).y;
  if (state.dragState.active) updateDrag(e.clientX, e.clientY);
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (cheeseChaseActive && !cc.gameOver) ccInputY = screenToGame(e.touches[0].clientX, e.touches[0].clientY).y;
  if (state.dragState.active) updateDrag(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

canvas.addEventListener('mouseup', e => {
  if (mouseMazeActive && mazeSwipeStart) {
    const pos = screenToGame(e.clientX, e.clientY);
    mazeSwipeEnd(pos.x, pos.y);
  }
});
canvas.addEventListener('touchend', e => {
  if (mouseMazeActive && mazeSwipeStart) {
    const t = e.changedTouches[0];
    const pos = screenToGame(t.clientX, t.clientY);
    mazeSwipeEnd(pos.x, pos.y);
  }
});

document.addEventListener('keydown', e => {
  if (cheeseChaseActive && !cc.gameOver) {
    if (e.key === 'ArrowUp' || e.key === 'w') cc.mouseY -= 10;
    if (e.key === 'ArrowDown' || e.key === 's') cc.mouseY += 10;
  }
  if (mouseMazeActive && !mz.levelComplete && !mz.gameOver) {
    if (e.key === 'ArrowUp' || e.key === 'w') { e.preventDefault(); mz.moveQueue.push('up'); }
    if (e.key === 'ArrowDown' || e.key === 's') { e.preventDefault(); mz.moveQueue.push('down'); }
    if (e.key === 'ArrowLeft' || e.key === 'a') { e.preventDefault(); mz.moveQueue.push('left'); }
    if (e.key === 'ArrowRight' || e.key === 'd') { e.preventDefault(); mz.moveQueue.push('right'); }
  }
});

document.getElementById('title-screen').addEventListener('click', startGame);
document.getElementById('title-screen').addEventListener('touchstart', e => {
  e.preventDefault(); startGame();
});

// ============================================================
// GAME START
// ============================================================
function startGame() {
  if (state.gameStarted) return;
  state.gameStarted = true;
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  loadGame();
  loadAudioPrefs();
  initAudio();
  updateCoinDisplay();
  updateHappinessDisplay();
  updateGoalDisplay();
  buildRoomTabs();
  initParticles();
  ensureExerciseRoomSetup();
  triggerBirthdayEvent();
  if (!audioMuted) startMusic();
}

// ============================================================
// MAIN LOOP
// ============================================================
let lastTime = performance.now();

function gameLoop(now) {
  const dt = Math.min(now - lastTime, 50);
  lastTime = now;

  if (state.gameStarted) {
    if (cheeseChaseActive) {
      updateCheeseChase(dt);
      updateFloatingEffects(dt);
      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawCheeseChase();
    } else if (mouseMazeActive) {
      updateMouseMaze(dt);
      updateFloatingEffects(dt);
      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawMouseMaze();
    } else {
      updateParticles(dt);
      updateMouse(state.miceState.pip, dt, CONFIG.mice.pip.personality);
      updateMouse(state.miceState.chai, dt, CONFIG.mice.chai.personality);
      updateSpeechBubbles(dt);
      updateFloatingEffects(dt);
      updateMouseInteractions(dt);
      updateHappiness(dt);
      updateGoals(dt);
      updateExerciseWheel(dt);

      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawRoom(state.currentRoom);

      // Draw mice in current room (skip mice on the wheel or flung ‚Äî drawn separately)
      const pip = state.miceState.pip;
      const chai = state.miceState.chai;
      if (pip.room === state.currentRoom && pip.action !== 'wheeling') {
        if (pip.action === 'flung') {
          drawFlungMouse(pip, CONFIG.mice.pip);
        } else {
          drawMouse(pip.x, MOUSE_FLOOR_Y, CONFIG.mice.pip, pip.dir, pip.frame, pip.action);
        }
        drawPartyHat(pip.action === 'flung' ? pip.flingX : pip.x,
                     pip.action === 'flung' ? pip.flingY : MOUSE_FLOOR_Y, pip.action, pip.dir, CONFIG.mice.pip);
      }
      if (chai.room === state.currentRoom && chai.action !== 'wheeling') {
        if (chai.action === 'flung') {
          drawFlungMouse(chai, CONFIG.mice.chai);
        } else {
          drawMouse(chai.x, MOUSE_FLOOR_Y, CONFIG.mice.chai, chai.dir, chai.frame, chai.action);
        }
        drawPartyHat(chai.action === 'flung' ? chai.flingX : chai.x,
                     chai.action === 'flung' ? chai.flingY : MOUSE_FLOOR_Y, chai.action, chai.dir, CONFIG.mice.chai);
      }

      drawSpeechBubbles();
      drawFloatingEffects();
      drawMouseStatus();
    }
  }

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
