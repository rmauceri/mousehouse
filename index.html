<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<title>üê≠ Mouse House</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%; overflow: hidden;
  background: #2b1d0e;
  font-family: 'Courier New', monospace;
}
body { display: flex; flex-direction: column; }
#gameCanvas {
  display: block; margin: 0 auto;
  image-rendering: pixelated; image-rendering: crisp-edges;
  cursor: pointer;
}

/* ---- HUD ---- */
#hud {
  position: absolute; top: 0; left: 0; width: 100%;
  display: none; flex-direction: column;
  background: rgba(30,20,10,0.85);
  color: #f5d68a; font-size: 16px; z-index: 10;
  border-bottom: 2px solid #a07040;
}
#hud-row1 {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 12px;
}
.hud-group { display: flex; align-items: center; gap: 6px; }
.hud-group-rooms { display: flex; align-items: center; gap: 3px; }
#hud-row2 {
  display: none; text-align: center; padding: 3px 12px 5px;
  border-top: 1px solid rgba(160,112,64,0.3);
}
#hud-row2.visible { display: block; }
#goal-display {
  font-size: 13px; color: #e8d5b5; white-space: normal;
  line-height: 1.3;
}
#hud button {
  background: #3d2b1a; color: #f5d68a; border: 2px solid #a07040;
  padding: 5px 12px; font-family: 'Courier New', monospace; font-size: 13px;
  cursor: pointer; border-radius: 4px;
  transition: background 0.15s;
}
#hud button:hover { background: #5a3d24; }
#hud button.active { background: #f5d68a; color: #2b1d0e; }
.room-tabs { display: flex; gap: 3px; }
.room-tabs button { font-size: 12px; padding: 4px 10px; }
/* Nav row: hidden on desktop, shown on mobile */
#hud-nav-row {
  display: none; justify-content: space-between; padding: 3px 8px 4px;
  border-top: 1px solid rgba(160,112,64,0.3);
}

/* ---- Modals ---- */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.8); display: flex; justify-content: center;
  align-items: center; z-index: 100;
}
.modal-content {
  background: #3d2b1a; border: 3px solid #f5d68a; border-radius: 12px;
  padding: 20px; max-width: 90vw; max-height: 85vh; overflow-y: auto;
  color: #e8d5b5; font-family: 'Courier New', monospace;
}
.modal-content h2 { color: #f5d68a; text-align: center; margin-bottom: 12px; }
.modal-content .close-btn {
  display: block; margin: 12px auto 0; background: #f5d68a; color: #2b1d0e;
  border: none; padding: 8px 24px; font-size: 16px; cursor: pointer;
  border-radius: 4px; font-family: 'Courier New', monospace; font-weight: bold;
}
.modal-content .close-btn:hover { background: #ffe4a0; }

/* ---- Shop grid ---- */
.shop-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px; margin: 10px 0;
}
.shop-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 10px; text-align: center; cursor: pointer; transition: border-color 0.2s;
}
.shop-item:hover { border-color: #f5d68a; }
.shop-item.owned { border-color: #7bc67e; opacity: 0.7; }
.shop-item .item-icon { font-size: 28px; margin-bottom: 4px; }
.shop-item .item-name { color: #f5d68a; font-size: 12px; font-weight: bold; }
.shop-item .item-desc { color: #a89070; font-size: 10px; margin: 4px 0; }
.shop-item .item-price { color: #f5d68a; font-size: 14px; font-weight: bold; }

/* ---- Minigame buttons ---- */
.minigame-btn {
  display: block; width: 80%; margin: 8px auto; padding: 12px;
  background: #2b1d0e; border: 2px solid #f5d68a; color: #f5d68a;
  font-family: 'Courier New', monospace; font-size: 14px; cursor: pointer;
  border-radius: 6px; text-align: center;
}
.minigame-btn:hover { background: #5a3d24; }

/* ---- Toast ---- */
#toast {
  position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
  background: rgba(30,20,10,0.92); color: #f5d68a; padding: 10px 22px;
  border-radius: 8px; font-size: 14px; pointer-events: none;
  opacity: 0; transition: opacity 0.3s; z-index: 50; text-align: center;
  border: 1px solid #a07040; max-width: 90vw;
  font-family: 'Courier New', monospace;
}
#toast.show { opacity: 1; }

/* ---- Placement bar (legacy, hidden) ---- */
#placement-bar { display: none !important; }

/* ---- Shop Flyout Panel ---- */
#shop-flyout, #games-flyout, #album-flyout, #trophy-flyout {
  position: fixed; top: 0; right: 0; width: 300px; height: 100%;
  background: rgba(30,20,10,0.95); border-left: 2px solid #a07040;
  z-index: 30; transform: translateX(100%); transition: transform 0.3s ease;
  display: flex; flex-direction: column; font-family: 'Courier New', monospace;
  overflow: hidden;
}
#shop-flyout.open, #games-flyout.open, #album-flyout.open, #trophy-flyout.open { transform: translateX(0); }
#shop-flyout .flyout-header {
  padding: 10px 14px; border-bottom: 2px solid #a07040;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0;
}
#shop-flyout .flyout-header h2 { color: #f5d68a; font-size: 16px; margin: 0; }
#shop-flyout .flyout-close {
  background: none; border: none; color: #f5d68a; font-size: 20px;
  cursor: pointer; padding: 2px 6px; line-height: 1;
}
#shop-flyout .flyout-coins {
  text-align: center; color: #a89070; font-size: 12px; padding: 6px 14px;
  border-bottom: 1px solid rgba(160,112,64,0.3); flex-shrink: 0;
}
#shop-flyout .flyout-coins strong { color: #f5d68a; }
#shop-flyout .flyout-items {
  flex: 1; overflow-y: auto; padding: 8px;
  display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
  align-content: start;
}
#shop-flyout .flyout-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 6px;
  padding: 8px 4px; text-align: center; cursor: pointer;
  transition: border-color 0.15s, background 0.15s;
}
#shop-flyout .flyout-item:hover { border-color: #f5d68a; }
#shop-flyout .flyout-item.owned { border-color: #7bc67e; }
#shop-flyout .flyout-item.cant-afford { opacity: 0.35; cursor: not-allowed; }
#shop-flyout .flyout-item .fi-icon { font-size: 22px; }
#shop-flyout .flyout-item .fi-name { color: #f5d68a; font-size: 10px; font-weight: bold; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#shop-flyout .flyout-item .fi-price { color: #a89070; font-size: 10px; margin-top: 2px; }
#shop-flyout .flyout-item.owned .fi-price { color: #7bc67e; }
#shop-flyout .flyout-footer {
  padding: 8px 14px; border-top: 2px solid #a07040; flex-shrink: 0;
  text-align: center;
}
#shop-flyout .flyout-footer button {
  background: #3d2b1a; color: #f5d68a; border: 2px solid #a07040;
  padding: 6px 14px; cursor: pointer; border-radius: 4px;
  font-family: 'Courier New', monospace; font-size: 12px; width: 100%;
  margin-bottom: 4px;
}
#shop-flyout .flyout-footer button:hover { background: #5a3d24; }
#shop-flyout .flyout-footer .loot-info { color: #a89070; font-size: 9px; margin-top: 2px; }

/* ---- Games Flyout ---- */
#games-flyout .flyout-header {
  padding: 10px 14px; border-bottom: 2px solid #a07040;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0;
}
#games-flyout .flyout-header h2 { color: #f5d68a; font-size: 16px; margin: 0; }
#games-flyout .flyout-close {
  background: none; border: none; color: #f5d68a; font-size: 20px;
  cursor: pointer; padding: 2px 6px; line-height: 1;
}
#games-flyout .flyout-subtitle {
  text-align: center; color: #a89070; font-size: 11px; padding: 6px 14px;
  border-bottom: 1px solid rgba(160,112,64,0.3); flex-shrink: 0;
}
#games-flyout .game-list {
  flex: 1; overflow-y: auto; padding: 10px 14px;
  display: flex; flex-direction: column; gap: 8px;
}
#games-flyout .game-item {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 12px; cursor: pointer; transition: border-color 0.15s, background 0.15s;
}
#games-flyout .game-item:hover { border-color: #f5d68a; background: #3d2b1a; }
#games-flyout .game-item .gi-title { color: #f5d68a; font-size: 14px; font-weight: bold; }
#games-flyout .game-item .gi-desc { color: #a89070; font-size: 10px; margin-top: 4px; }

/* ---- Album Flyout ---- */
#album-flyout .flyout-header, #trophy-flyout .flyout-header {
  padding: 10px 14px; border-bottom: 2px solid #a07040;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0;
}
#album-flyout .flyout-header h2, #trophy-flyout .flyout-header h2 { color: #f5d68a; font-size: 16px; margin: 0; }
#album-flyout .flyout-close, #trophy-flyout .flyout-close {
  background: none; border: none; color: #f5d68a; font-size: 20px;
  cursor: pointer; padding: 2px 6px; line-height: 1;
}
#album-flyout .flyout-subtitle, #trophy-flyout .flyout-subtitle {
  text-align: center; color: #a89070; font-size: 11px; padding: 6px 14px;
  border-bottom: 1px solid rgba(160,112,64,0.3); flex-shrink: 0;
}
#album-flyout .flyout-body, #trophy-flyout .flyout-body {
  flex: 1; overflow-y: auto; padding: 10px;
}

/* ---- Item Tray (bottom palette) ---- */
#tray-toggle {
  position: fixed; bottom: 0; left: 50%; transform: translateX(-50%);
  z-index: 31; width: 40px; height: 22px; background: rgba(30,20,10,0.92);
  border: 2px solid #a07040; border-bottom: none; border-radius: 6px 6px 0 0;
  color: #f5d68a; font-size: 16px; cursor: pointer; display: none;
  align-items: center; justify-content: center; font-family: 'Courier New', monospace;
  transition: background 0.15s;
}
#tray-toggle:hover { background: #3d2b1a; }
#tray-toggle.disabled { opacity: 0.35; pointer-events: none; }
#tray-toggle.open { bottom: 72px; }
#item-tray {
  position: fixed; bottom: 0; left: 0; width: 100%; height: 72px;
  background: rgba(30,20,10,0.92); border-top: 2px solid #a07040;
  z-index: 30; display: none; overflow-x: auto; overflow-y: hidden;
  white-space: nowrap; padding: 6px 10px;
  -webkit-overflow-scrolling: touch;
}
#item-tray.open { display: flex; align-items: center; gap: 6px; }
.tray-item {
  display: inline-flex; flex-direction: column; align-items: center;
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 6px;
  padding: 4px 8px; cursor: grab; user-select: none; -webkit-user-select: none;
  flex-shrink: 0; min-width: 56px; transition: border-color 0.15s;
}
.tray-item:hover { border-color: #f5d68a; }
.tray-item.active { border-color: #f5d68a; background: #3d2b1a; }
.tray-item .ti-icon { font-size: 20px; pointer-events: none; }
.tray-item .ti-name { font-size: 8px; color: #a89070; pointer-events: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 50px; }

/* ---- Trash Zone ---- */
#trash-zone {
  position: fixed; bottom: 0; left: 50%; transform: translateX(-50%);
  width: 120px; height: 50px; background: rgba(200,50,50,0.7);
  border: 2px dashed #ff6666; border-radius: 10px 10px 0 0;
  z-index: 35; display: none; justify-content: center; align-items: center;
  color: #fff; font-size: 24px; font-family: 'Courier New', monospace;
  pointer-events: none;
}
#trash-zone.visible { display: flex; }
#trash-zone.hover { background: rgba(200,50,50,0.95); border-color: #ff4444; }

/* ---- Birthday letter ---- */
.letter-content {
  background: #f5f0dc; color: #333; padding: 20px; border-radius: 8px;
  font-family: Georgia, serif; font-size: 15px; line-height: 1.6;
  max-width: 400px; margin: 0 auto;
}
.letter-content h3 { text-align: center; margin-bottom: 10px; color: #8b4513; }

/* ---- Title screen ---- */
#title-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: radial-gradient(ellipse at 50% 45%, #3d2b1a 0%, #2b1d0e 50%, #1a0f05 100%);
  display: flex; flex-direction: column;
  justify-content: center; align-items: center; z-index: 200;
  cursor: pointer; overflow: hidden;
}
/* Stage spotlights from top corners */
#title-screen::before, #title-screen::after {
  content: ''; position: absolute; top: 0; width: 0; height: 0;
  border-style: solid; pointer-events: none; opacity: 0.18;
  filter: blur(14px);
  z-index: 0;
}
#title-screen::before {
  left: 8%; border-width: 0 120px 75vh 120px;
  border-color: transparent transparent rgba(255,240,200,0.5) transparent;
  transform: rotate(-6deg); transform-origin: top center;
}
#title-screen::after {
  right: 8%; border-width: 0 120px 75vh 120px;
  border-color: transparent transparent rgba(255,240,200,0.5) transparent;
  transform: rotate(6deg); transform-origin: top center;
}
/* Floor glow pools where spotlights land */
.title-spotlight-floor {
  position: absolute; bottom: 22%; left: 50%; transform: translateX(-50%);
  width: 75%; height: 80px;
  background: radial-gradient(ellipse at 50% 50%, rgba(255,240,200,0.18) 0%, rgba(255,220,160,0.08) 50%, transparent 100%);
  pointer-events: none; z-index: 0;
  filter: blur(8px);
}
/* Ensure content sits above spotlights */
#title-screen h1, #title-screen .adventure-subtitle,
#title-screen .mice-display, #title-screen .start-text,
#title-screen .title-buttons, .title-particle {
  position: relative; z-index: 1;
}
#title-screen h1 {
  color: #f5d68a; font-size: 52px; margin-bottom: 0; letter-spacing: 2px;
  text-shadow: 3px 3px 0 #1a0f05, 0 0 30px rgba(245,214,138,0.4);
  opacity: 0; animation: title-fade-in 0.8s ease-out 0.2s forwards;
}
#title-screen .adventure-subtitle {
  color: #c8a870; font-size: 16px; margin-bottom: 8px;
  text-shadow: 0 0 12px rgba(200,168,112,0.4);
  opacity: 0; animation: title-fade-in 0.8s ease-out 0.5s forwards;
}
#title-screen .start-text {
  color: #f5d68a; font-size: 16px;
  margin-top: 12px;
  background: rgba(245,214,138,0.1); border: 1px solid rgba(245,214,138,0.3);
  padding: 8px 28px; border-radius: 20px;
  text-shadow: 0 0 10px rgba(245,214,138,0.4);
  animation: title-fade-in 0.8s ease-out 1.1s forwards, cta-glow 2s ease-in-out 2s infinite;
  opacity: 0;
}
#title-screen .mice-display {
  display: flex; gap: 40px; align-items: flex-end; margin-bottom: 8px;
  opacity: 0; animation: title-fade-in 0.8s ease-out 0.8s forwards;
}
#title-screen .mouse-art {
  display: flex; flex-direction: column; align-items: center; gap: 2px;
  overflow: hidden;
}
#title-screen .mouse-art .name {
  color: #f5d68a; font-size: 15px; font-weight: bold;
  text-shadow: 0 0 8px rgba(245,214,138,0.5);
  letter-spacing: 1px;
}
#title-screen .mouse-art .tagline {
  color: #a89070; font-size: 11px; height: 16px;
  transition: opacity 0.4s;
}
#title-screen canvas { border-radius: 8px; }
#title-screen .title-buttons {
  position: absolute; bottom: 16px; right: 16px;
  display: flex; gap: 8px;
  opacity: 0; animation: title-fade-in 0.6s ease-out 1.4s forwards;
}
#title-screen .title-buttons button {
  background: rgba(245,214,138,0.1); border: 1px solid rgba(107,80,48,0.6);
  color: #a89070; font-size: 16px; padding: 6px 10px; border-radius: 8px;
  cursor: pointer; font-family: monospace; transition: all 0.2s;
  width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
}
#title-screen .title-buttons button:hover {
  background: rgba(245,214,138,0.25); border-color: #f5d68a; color: #f5d68a;
}
@keyframes title-fade-in {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes cta-glow {
  0%, 100% { box-shadow: 0 0 8px rgba(245,214,138,0.1); opacity: 1; }
  50% { box-shadow: 0 0 16px rgba(245,214,138,0.3); opacity: 0.7; }
}
#title-about-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.7); z-index: 210; display: none;
  justify-content: center; align-items: center;
}
#title-about-overlay.visible { display: flex; }
#title-about-box {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 12px;
  padding: 20px 24px; max-width: 380px; max-height: 80vh; overflow-y: auto;
  color: #e8d5b5; font-family: monospace; font-size: 12px; line-height: 1.6;
}
#title-about-box h2 { color: #f5d68a; font-size: 18px; margin: 0 0 8px; }
#title-about-box h3 { color: #c8a870; font-size: 13px; margin: 10px 0 4px; }
#title-about-box p { margin: 4px 0; }
#title-about-box ul { margin: 4px 0 4px 16px; padding: 0; }
#title-about-box li { margin: 2px 0; }
#title-about-box .close-about {
  display: block; margin: 12px auto 0; background: #6b5030; border: none;
  color: #f5d68a; padding: 6px 20px; border-radius: 6px; cursor: pointer;
  font-family: monospace; font-size: 13px;
}
#title-about-box .close-about:hover { background: #8b6840; }
/* Floating cheese/sparkle particles on title */
.title-particle {
  position: absolute; font-size: 16px; pointer-events: none;
  animation: float-up 6s linear infinite;
  opacity: 0.6;
}
@keyframes float-up {
  0% { transform: translateY(0) rotate(0deg); opacity: 0; }
  10% { opacity: 0.6; }
  90% { opacity: 0.6; }
  100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
}

/* ---- Doomscroll posts ---- */
.doomscroll-post {
  background: #2b1d0e; border: 2px solid #6b5030; border-radius: 8px;
  padding: 12px; margin: 8px 0; cursor: pointer; transition: all 0.2s;
}
.doomscroll-post:hover { border-color: #f5d68a; }
.doomscroll-post .post-user { color: #a89070; font-size: 11px; margin-bottom: 4px; }
.doomscroll-post .post-text { color: #e8d5b5; font-size: 13px; }

/* ---- Flyout backdrop (light dismiss) ---- */
#flyout-backdrop {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.4); z-index: 29; display: none;
}
#flyout-backdrop.visible { display: block; }

/* ---- Overflow menu (mobile) ---- */
#btn-overflow {
  display: none; background: #3d2b1a; color: #f5d68a; border: 2px solid #a07040;
  padding: 4px 10px; font-size: 16px; cursor: pointer; border-radius: 4px;
  font-family: 'Courier New', monospace; line-height: 1;
}
#btn-overflow:hover { background: #5a3d24; }
#overflow-menu {
  display: none; position: fixed; top: 0; right: 0; width: 180px; height: 100%;
  background: rgba(30,20,10,0.97); border-left: 2px solid #a07040;
  z-index: 35; flex-direction: column; padding: 12px 10px; gap: 4px;
  font-family: 'Courier New', monospace;
  transform: translateX(100%); transition: transform 0.25s ease;
}
#overflow-menu.open { display: flex; transform: translateX(0); }
#overflow-menu button {
  background: #2b1d0e; color: #f5d68a; border: 2px solid #6b5030;
  padding: 10px 12px; font-size: 14px; cursor: pointer; border-radius: 6px;
  font-family: 'Courier New', monospace; text-align: left;
  transition: border-color 0.15s, background 0.15s;
}
#overflow-menu button:hover { border-color: #f5d68a; background: #3d2b1a; }

/* ---- Mobile layout (portrait phones) ---- */
@media (max-width: 600px) {
  /* HUD flows above canvas instead of overlaying */
  #hud { position: relative; order: -1; }

  /* Row 1: all button groups visible */
  #hud-row1 { justify-content: space-between; padding: 4px 6px; gap: 4px; }
  #hud-stats { display: flex; font-size: 13px; }
  #hud-actions { display: flex; }
  #hud-actions .btn-label { display: none; }
  #hud-utils { display: flex; }
  #hud-system { display: flex; }
  .hud-group-rooms { display: none; }

  /* Compact bordered buttons for phone */
  #hud-actions button, #hud-utils button, #hud-system button {
    padding: 3px 5px; font-size: 15px; min-width: 28px;
    border: 2px solid #a07040; background: #3d2b1a; border-radius: 4px;
  }

  /* Room tab row hidden (room name on canvas + swipe/arrows) */
  #hud-nav-row { display: none !important; }

  /* Status row: always reserves space so canvas doesn't jump */
  #hud-row2 { display: block; min-height: 22px; }

  /* Flyouts: 80% width on mobile, leaving backdrop strip for light-dismiss */
  #shop-flyout, #games-flyout, #album-flyout, #trophy-flyout { width: 80%; }

  /* Item tray: bottom sheet grid instead of horizontal strip */
  #item-tray {
    height: auto !important; max-height: 35vh;
    overflow-y: auto !important; overflow-x: hidden !important;
    white-space: normal !important;
    flex-wrap: wrap !important;
    padding: 8px !important;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none; -ms-overflow-style: none;
  }
  #item-tray::-webkit-scrollbar { display: none; }
  #item-tray.open {
    display: grid !important;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
  }
  .tray-item {
    min-width: unset; width: 100%;
    cursor: pointer;
  }
  #tray-toggle.open { bottom: auto; }
}

/* ---- Landscape phones ---- */
@media (max-height: 440px) and (orientation: landscape) {
  body { flex-direction: row; }
  #hud {
    position: relative; order: -1;
    flex-direction: column; width: 42px !important; min-width: 42px; max-width: 42px;
    height: 100vh;
    border-bottom: none; border-right: 2px solid #a07040;
    padding: 4px 0; overflow: hidden;
    flex-shrink: 0; align-items: center; justify-content: center;
  }
  #hud-row1 {
    flex-direction: column; padding: 0; gap: 4px;
    align-items: center; width: 100%;
  }
  #hud-stats { display: none !important; }
  #hud-actions {
    display: flex !important; flex-direction: column; gap: 6px; align-items: center;
  }
  #hud-actions .btn-label { display: none; }
  #hud-actions button, #hud-utils button, #hud-system button {
    padding: 3px 5px; font-size: 15px; min-width: 28px;
    border: 2px solid #a07040; background: #3d2b1a; border-radius: 4px;
  }
  #hud-utils {
    display: flex !important; flex-direction: column; gap: 6px; align-items: center;
    margin-top: 10px;
  }
  #hud-system {
    display: flex !important; flex-direction: column; gap: 6px; align-items: center;
    margin-top: 10px;
  }
  .hud-group-rooms { display: none !important; }
  #hud-nav-row { display: none !important; }
  #hud-row2 { display: none !important; }
  /* Flyouts & modals */
  #shop-flyout, #games-flyout, #album-flyout, #trophy-flyout { width: 300px; }
  /* Tray: constrain height in landscape */
  #item-tray {
    max-height: 30vh;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none; -ms-overflow-style: none;
  }
  #item-tray::-webkit-scrollbar { display: none; }
  .modal-content { max-height: 95vh; }
}
/* ---- D-Pad Controller (mobile maze) ---- */
#maze-dpad {
  display: none;
  grid-template-columns: 44px 44px 44px;
  grid-template-rows: 44px 44px 44px;
  gap: 3px; justify-content: center; align-content: center;
  padding: 6px 0;
}
#maze-dpad.visible { display: grid; }
.dpad-btn {
  width: 44px; height: 44px; border: 2px solid #a07040;
  border-radius: 8px; background: rgba(30,20,10,0.9);
  color: #f5d68a; font-size: 20px; cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  user-select: none; -webkit-user-select: none;
  touch-action: manipulation;
}
.dpad-btn:active { background: #3d2b1a; border-color: #f5d68a; }
.dpad-center { background: transparent; border: none; }
@media (min-width: 769px) {
  #maze-dpad { display: none !important; }
}
@media (max-height: 440px) and (orientation: landscape) {
  #maze-dpad.visible {
    position: fixed; right: 8px; top: 50%; transform: translateY(-50%);
    display: grid; padding: 0;
  }
}

</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="maze-dpad">
  <div></div>
  <button class="dpad-btn" data-dir="up">‚ñ≤</button>
  <div></div>
  <button class="dpad-btn" data-dir="left">‚óÄ</button>
  <div class="dpad-center"></div>
  <button class="dpad-btn" data-dir="right">‚ñ∂</button>
  <div></div>
  <button class="dpad-btn" data-dir="down">‚ñº</button>
  <div></div>
</div>

<div id="hud">
  <div id="hud-row1">
    <div class="hud-group" id="hud-stats">
      <span>üßÄ <span id="coin-display">0</span></span>
      <span id="happiness-display" title="Mouse Happiness">‚ù§Ô∏è <span id="happiness-value">80</span>%</span>
    </div>
    <div class="hud-group-rooms">
      <div class="room-tabs" id="room-tabs"></div>
    </div>
    <div class="hud-group" id="hud-actions">
      <button id="btn-shop">üõí<span class="btn-label"> aMouseZon</span></button>
      <button id="btn-games">üéÆ<span class="btn-label"> Games</span></button>
      <button id="btn-selfie" title="Take a selfie!" onclick="takeMouseSelfie()">üì∏</button>
    </div>
    <div class="hud-group" id="hud-utils">
      <button id="btn-album" title="Photo Album" onclick="openPhotoAlbum()">üñºÔ∏è</button>
      <button id="btn-trophy" title="Achievements" onclick="openTrophyCase()">üèÜ</button>
      <button id="btn-letter">üíå</button>
    </div>
    <div class="hud-group" id="hud-system">
      <button id="btn-sound" title="Sound">üîá</button>
      <button id="btn-exit" title="Exit to title">üö™</button>
    </div>
  </div>
  <div id="hud-nav-row">
    <div class="room-tabs" id="room-tabs-mobile"></div>
  </div>
  <div id="hud-row2">
    <div id="goal-display"></div>
  </div>
</div>

<div id="volume-popup" style="display:none;position:fixed;z-index:15;background:rgba(30,20,10,0.95);border:2px solid #a07040;border-radius:8px;padding:10px 14px;font-family:'Courier New',monospace;">
  <label style="color:#f5d68a;font-size:12px;">Volume</label><br>
  <input type="range" id="volume-slider" min="0" max="100" value="50" style="width:100px;margin-top:4px;accent-color:#f5d68a;">
</div>

<div id="toast"></div>

<div id="placement-bar">
  <div class="info" id="placement-info">Click/tap a spot to place the item</div>
  <button id="btn-cancel-place">‚úñ Cancel</button>
  <button id="btn-remove-mode">üóë Remove</button>
</div>

<div id="flyout-backdrop"></div>

<div id="shop-flyout">
  <div class="flyout-header">
    <h2>üõí aMouseZon</h2>
    <button class="flyout-close" id="flyout-close-btn">‚úñ</button>
  </div>
  <div class="flyout-coins">Free 2-day delivery | üßÄ <strong id="flyout-coin-display">0</strong> coins</div>
  <div class="flyout-items" id="flyout-items"></div>
  <div class="flyout-footer">
    <button id="flyout-loot-btn">üéÅ Loot Crumbs ‚Äî Free Mystery Item!</button>
    <div class="loot-info" id="flyout-loot-info"></div>
  </div>
</div>

<div id="games-flyout">
  <div class="flyout-header">
    <h2>üéÆ Arcade</h2>
    <button class="flyout-close" id="games-flyout-close">‚úñ</button>
  </div>
  <div class="flyout-subtitle">Earn cheese coins to shop at aMouseZon!</div>
  <div class="game-list">
    <div class="game-item" onclick="startCheeseChase()">
      <div class="gi-title">üßÄ Cheese Chase</div>
      <div class="gi-desc">Dodge obstacles, grab snacks & power-ups!</div>
    </div>
    <div class="game-item" onclick="startDoomscroll()">
      <div class="gi-title">üì± Doomscroll</div>
      <div class="gi-desc">Touch grass? Never heard of it.</div>
    </div>
    <div class="game-item" onclick="startMouseMaze()">
      <div class="gi-title">üïπÔ∏è Pac Mouse</div>
      <div class="gi-desc">Eat berries, dodge the cat!</div>
    </div>
    <div class="game-item" onclick="startWhackACat()">
      <div class="gi-title">üê± Whack-a-Cat</div>
      <div class="gi-desc">Bonk the cats, protect the cheese!</div>
    </div>
  </div>
</div>

<div id="album-flyout">
  <div class="flyout-header">
    <h2>üì∏ Photo Album</h2>
    <button class="flyout-close" id="album-flyout-close">‚úñ</button>
  </div>
  <div class="flyout-subtitle" id="album-subtitle"></div>
  <div class="flyout-body" id="album-body"></div>
</div>

<div id="trophy-flyout">
  <div class="flyout-header">
    <h2>üèÜ Trophy Case</h2>
    <button class="flyout-close" id="trophy-flyout-close">‚úñ</button>
  </div>
  <div class="flyout-subtitle" id="trophy-subtitle"></div>
  <div class="flyout-body" id="trophy-body"></div>
</div>

<div id="tray-toggle" title="Toggle item tray"><span style="display:inline-block;transform:rotate(-90deg)">¬ª</span></div>
<div id="item-tray"></div>

<div id="trash-zone">üóë</div>

<div id="title-screen">
  <div class="title-spotlight-floor"></div>
  <h1>Mouse House</h1>
  <div class="adventure-subtitle">‚ú® The Adventures of Pip & Chai ‚ú®</div>
  <div class="mice-display">
    <div class="mouse-art">
      <canvas id="title-pip" width="200" height="160"></canvas>
      <div class="name">Pip</div>
      <div class="tagline" id="pip-tagline"></div>
    </div>
    <div class="mouse-art">
      <canvas id="title-chai" width="200" height="160"></canvas>
      <div class="name">Chai</div>
      <div class="tagline" id="chai-tagline"></div>
    </div>
  </div>
  <div class="start-text">~ tap or click to start ~</div>
  <div class="title-buttons">
    <button id="title-about-btn" onclick="event.stopPropagation(); toggleTitleAbout()" title="About">üìñ</button>
    <button id="title-mute-btn" onclick="event.stopPropagation(); toggleTitleMute()" title="Sound">üîä</button>
  </div>
</div>

<div id="title-about-overlay" onclick="closeTitleAbout()">
  <div id="title-about-box" onclick="event.stopPropagation()">
    <h2>üê≠ Mouse House</h2>
    <p>A cozy virtual pet game for Nico & Rose! Watch Pip and Chai explore their dollhouse, buy them furniture, play mini-games, and unlock achievements together.</p>
    <h3>üè† Features</h3>
    <ul>
      <li><b>4 rooms</b> ‚Äî Bedroom, Kitchen, Living Room & Exercise Room with platforms and ramps</li>
      <li><b>20+ furniture items</b> ‚Äî Hammocks, climbing ropes, beds, laptops, yoga mats & more from the aMouseZon shop</li>
      <li><b>4 mini-games</b> ‚Äî Cheese Chase (dodge & collect), Pac Mouse (maze with cat ghost), Whack-a-Cat (bonk the cats!), and Doomscroll (curate your feed)</li>
      <li><b>23 achievements</b> ‚Äî Track your progress in the üèÜ Trophy Case</li>
      <li><b>Exercise Wheel</b> ‚Äî Watch the mice spin (and get flung!)</li>
      <li><b>Mouse AI</b> ‚Äî Pip & Chai explore, climb, nap, chase each other, use furniture, do mischief, and share their thoughts</li>
      <li><b>Goals</b> ‚Äî Mice request items; place them to earn bonus coins and watch the mouse react</li>
      <li><b>üì∏ Selfies</b> ‚Äî Snap zoomed-in photos of the mice, preview with 8 filters, save to your üñºÔ∏è Photo Album, or copy to clipboard</li>
    </ul>
    <h3>ü™ô How to Play</h3>
    <ul>
      <li>Earn coins by playing mini-games, completing goals, and unlocking achievements</li>
      <li>Spend coins to pet mice for happiness, or shop at <b>aMouseZon</b> (üõí) for furniture and food</li>
      <li>Drag items from the tray to place them; click placed items to reposition</li>
      <li>Switch rooms with the tabs or swipe left/right</li>
      <li>Play mini-games from the üéÆ button ‚Äî use keyboard or touch</li>
    </ul>
    <h3>üí° Tips</h3>
    <ul>
      <li><b>Pet the mice!</b> Click/tap on them for coins and happiness</li>
      <li><b>Feed them!</b> Buy cheese üßÄ or blueberries ü´ê ‚Äî they get hungry over time</li>
      <li><b>Double-click status bar</b> to jump to a mouse's room</li>
      <li><b>Loot Crumbs</b> in the shop gives free coins once per day</li>
      <li>Food is consumable ‚Äî buy more when it runs out! (üîÑ in shop)</li>
      <li>New furniture sparks curiosity ‚Äî mice will check it out!</li>
      <li>Pip is chaotic & hungry üòà ¬∑ Chai is cozy & chill üßò</li>
    </ul>
    <button class="close-about" onclick="closeTitleAbout()">Got it! üê≠</button>
    <div style="text-align:center;margin-top:10px;">
      <a href="#" id="reset-game-link" onclick="event.preventDefault();confirmResetGame(this);" style="color:#7a6a5a;font-size:11px;text-decoration:underline;cursor:pointer;">Reset Game</a>
    </div>
  </div>
</div>

<div id="modal-container"></div>

<script>
// ============================================================
// CONFIG ‚Äî Easy to change names, colors, messages
// ============================================================
const CONFIG = {
  mice: {
    pip: {
      name: 'Pip', bodyColor: '#4a4a4a', earColor: '#3a3a3a',
      bellyColor: '#5e5e5e', eyeColor: '#111', noseColor: '#ffaaaa',
      personality: 'chaotic', // more zoomies, sarcastic quotes
      scale: 1.15 // Pip is slightly larger than Chai
    },
    chai: {
      name: 'Chai', bodyColor: '#b8b8b8', earColor: '#a5a5a5',
      bellyColor: '#d0d0d0', eyeColor: '#222', noseColor: '#ffbbbb',
      personality: 'chill', // more sleeping, wholesome quotes
      scale: 1.0
    }
  },
  twins: { name1: 'Nico', name2: 'Rose', age: 20, birthday: 'February 21' },
  startingCoins: 50,
  birthdayMessage: `Dear Nico & Rose,

Happy 20th birthday! üéÇ

Twenty years of watching you two grow into the amazing, hilarious, kind humans you are. From tiny babies to tiny-mouse enthusiasts, you've filled every day with joy (and chaos, but mostly joy).

Pip and Chai are lucky to have you ‚Äî and so am I.

Here's a little mouse house for you to make your own. Decorate it, play some games, and know that every pixel was placed with love.

Always in your corner,
Dad üê≠üíõ`
};

// ============================================================
// AUDIO ENGINE (Web Audio API ‚Äî all synthesized)
// ============================================================
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let audioMuted = true;
let audioVolume = 0.5;
let musicPlaying = false;
let musicTimeout = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);
  masterGain.gain.value = audioMuted ? 0 : audioVolume;

  musicGain = audioCtx.createGain();
  musicGain.connect(masterGain);
  musicGain.gain.value = 0.3;

  sfxGain = audioCtx.createGain();
  sfxGain.connect(masterGain);
  sfxGain.gain.value = 0.7;
}

function updateSoundButtons() {
  document.getElementById('btn-sound').textContent = audioMuted ? 'üîá' : 'üîä';
}

function toggleMute() {
  initAudio();
  audioMuted = !audioMuted;
  masterGain.gain.setTargetAtTime(audioMuted ? 0 : audioVolume, audioCtx.currentTime, 0.05);
  updateSoundButtons();
  try { localStorage.setItem('mouseHouseAudio', JSON.stringify({ muted: audioMuted, volume: audioVolume })); } catch(e) {}
  if (!audioMuted && !musicPlaying) startMusic();
}

function setVolume(v) {
  audioVolume = v;
  if (masterGain && !audioMuted) {
    masterGain.gain.setTargetAtTime(audioVolume, audioCtx.currentTime, 0.05);
  }
  try { localStorage.setItem('mouseHouseAudio', JSON.stringify({ muted: audioMuted, volume: audioVolume })); } catch(e) {}
}

function loadAudioPrefs() {
  try {
    const d = JSON.parse(localStorage.getItem('mouseHouseAudio'));
    if (d) {
      audioMuted = d.muted ?? true;
      audioVolume = d.volume ?? 0.5;
      updateSoundButtons();
      document.getElementById('volume-slider').value = Math.round(audioVolume * 100);
    }
  } catch(e) {}
}

// --- Synth helpers ---
function playTone(freq, duration, type, gainVal, dest) {
  if (!audioCtx || audioMuted) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type || 'sine';
  osc.frequency.value = freq;
  g.gain.value = gainVal || 0.3;
  g.gain.setTargetAtTime(0, audioCtx.currentTime + duration * 0.7, duration * 0.15);
  osc.connect(g);
  g.connect(dest || sfxGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + duration);
}

function playNoise(duration, gainVal) {
  if (!audioCtx || audioMuted) return;
  const bufSize = audioCtx.sampleRate * duration;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.value = gainVal || 0.1;
  g.gain.setTargetAtTime(0, audioCtx.currentTime + duration * 0.5, duration * 0.2);
  src.connect(g);
  g.connect(sfxGain);
  src.start();
}

// --- Sound effects ---
function sfxSqueak() {
  if (!audioCtx) return;
  const baseFreq = 1800 + Math.random() * 600;
  playTone(baseFreq, 0.08, 'sine', 0.2);
  setTimeout(() => playTone(baseFreq * 1.2, 0.06, 'sine', 0.15), 50);
}

function sfxCoinCollect() {
  if (!audioCtx) return;
  playTone(880, 0.08, 'square', 0.12);
  setTimeout(() => playTone(1100, 0.08, 'square', 0.12), 60);
  setTimeout(() => playTone(1320, 0.1, 'square', 0.1), 120);
}

function sfxBuy() {
  if (!audioCtx) return;
  playTone(523, 0.06, 'square', 0.12);
  setTimeout(() => playTone(659, 0.06, 'square', 0.12), 50);
  setTimeout(() => playTone(784, 0.06, 'square', 0.12), 100);
  setTimeout(() => playTone(1047, 0.12, 'square', 0.1), 150);
}

function sfxPlace() {
  if (!audioCtx) return;
  playNoise(0.06, 0.15);
  setTimeout(() => playTone(600, 0.1, 'triangle', 0.1), 40);
  setTimeout(() => playTone(900, 0.08, 'sine', 0.06), 100);
}

function sfxPet() {
  if (!audioCtx) return;
  const f = 1400 + Math.random() * 400;
  playTone(f, 0.06, 'sine', 0.15);
  setTimeout(() => playTone(f * 1.15, 0.06, 'sine', 0.12), 60);
  setTimeout(() => playTone(f * 1.3, 0.08, 'sine', 0.1), 120);
}

function sfxZoomies() {
  if (!audioCtx) return;
  for (let i = 0; i < 4; i++) {
    setTimeout(() => playTone(400 + i * 150, 0.05, 'sawtooth', 0.06), i * 40);
  }
}

function sfxCheeseCollect() {
  if (!audioCtx) return;
  playTone(1200, 0.05, 'sine', 0.15);
  setTimeout(() => playTone(1600, 0.07, 'sine', 0.1), 40);
}

function sfxCrash() {
  if (!audioCtx) return;
  playNoise(0.15, 0.2);
  playTone(200, 0.2, 'sawtooth', 0.12);
  setTimeout(() => playTone(120, 0.25, 'sawtooth', 0.08), 80);
}

function sfxGoodLike() {
  if (!audioCtx) return;
  playTone(523, 0.08, 'triangle', 0.12);
  setTimeout(() => playTone(659, 0.08, 'triangle', 0.12), 70);
  setTimeout(() => playTone(784, 0.12, 'triangle', 0.1), 140);
}

function sfxBadLike() {
  if (!audioCtx) return;
  playTone(300, 0.15, 'sawtooth', 0.1);
  setTimeout(() => playTone(250, 0.15, 'sawtooth', 0.1), 150);
  setTimeout(() => playTone(200, 0.25, 'sawtooth', 0.08), 300);
}

function sfxFanfare() {
  if (!audioCtx) return;
  const notes = [523, 659, 784, 1047, 784, 1047, 1319];
  notes.forEach((n, i) => {
    setTimeout(() => playTone(n, 0.12, 'square', 0.1), i * 100);
  });
}

function sfxGoalComplete() {
  if (!audioCtx) return;
  const notes = [659, 784, 1047, 1319];
  notes.forEach((n, i) => {
    setTimeout(() => playTone(n, 0.1, 'triangle', 0.12), i * 80);
  });
}

function sfxSpeechBubble() {
  if (!audioCtx) return;
  const f = 1000 + Math.random() * 800;
  playTone(f, 0.03, 'sine', 0.06);
}

function sfxWheelSpin() {
  if (!audioCtx) return;
  playTone(300, 0.05, 'triangle', 0.04);
  setTimeout(() => playTone(350, 0.05, 'triangle', 0.04), 60);
}

function sfxWheelFling() {
  if (!audioCtx) return;
  playTone(600, 0.06, 'sawtooth', 0.1);
  setTimeout(() => playTone(400, 0.08, 'sawtooth', 0.08), 50);
  setTimeout(() => playTone(250, 0.12, 'triangle', 0.06), 120);
  setTimeout(() => playNoise(0.08, 0.1), 200);
}

function sfxUIClick() {
  if (!audioCtx) return;
  playTone(800, 0.03, 'square', 0.06);
}

// --- Mouse vocalizations ---
// Cooldown tracker to prevent sound spam
let _mouseSfxCooldown = 0;
function mouseSfxReady() {
  const now = performance.now();
  if (now - _mouseSfxCooldown < 800) return false;
  _mouseSfxCooldown = now;
  return true;
}

function sfxMunch() {
  // Content munching chirps ‚Äî short percussive clicks with a happy uptick
  if (!audioCtx || !mouseSfxReady()) return;
  const f = 1600 + Math.random() * 300;
  playTone(f, 0.03, 'square', 0.08);
  setTimeout(() => playTone(f * 1.05, 0.03, 'square', 0.07), 80);
  setTimeout(() => playTone(f * 1.1, 0.04, 'sine', 0.06), 160);
}

function sfxSnore() {
  // Tiny mouse snore ‚Äî low soft rumble with a gentle rise and fall
  if (!audioCtx || !mouseSfxReady()) return;
  const f = 180 + Math.random() * 40;
  playTone(f, 0.25, 'sine', 0.04);
  setTimeout(() => playTone(f * 1.15, 0.2, 'sine', 0.03), 250);
}

function sfxZoomieSqueak() {
  // Excited rapid squeaks ‚Äî fast ascending chirps
  if (!audioCtx || !mouseSfxReady()) return;
  const base = 2000 + Math.random() * 400;
  for (let i = 0; i < 3; i++) {
    setTimeout(() => playTone(base + i * 200, 0.04, 'sine', 0.09), i * 50);
  }
}

function sfxGroom() {
  // Calm grooming ‚Äî soft scratchy licking sounds
  if (!audioCtx || !mouseSfxReady()) return;
  playNoise(0.04, 0.05);
  setTimeout(() => {
    const f = 1200 + Math.random() * 200;
    playTone(f, 0.03, 'sine', 0.05);
  }, 50);
}

function sfxChitter() {
  // Mouse "talking" ‚Äî rapid tiny chattering
  if (!audioCtx || !mouseSfxReady()) return;
  const base = 1400 + Math.random() * 600;
  const count = 3 + Math.floor(Math.random() * 3);
  for (let i = 0; i < count; i++) {
    const f = base + (Math.random() - 0.5) * 400;
    setTimeout(() => playTone(f, 0.025, 'sine', 0.06), i * 40);
  }
}

function sfxHide() {
  // Sneaky muffled squeak ‚Äî low and quiet
  if (!audioCtx || !mouseSfxReady()) return;
  playTone(900 + Math.random() * 200, 0.06, 'sine', 0.04);
  setTimeout(() => playNoise(0.03, 0.03), 70);
}

function sfxChew() {
  // Crunchy nibbling ‚Äî percussive with texture
  if (!audioCtx || !mouseSfxReady()) return;
  playNoise(0.03, 0.08);
  setTimeout(() => playNoise(0.03, 0.06), 90);
  setTimeout(() => playTone(600 + Math.random() * 200, 0.03, 'square', 0.04), 60);
}

function sfxSwing() {
  // Playful gleeful chirp ‚Äî rising happy tone
  if (!audioCtx || !mouseSfxReady()) return;
  const f = 1200 + Math.random() * 300;
  playTone(f, 0.06, 'triangle', 0.08);
  setTimeout(() => playTone(f * 1.25, 0.08, 'sine', 0.07), 70);
  setTimeout(() => playTone(f * 1.5, 0.06, 'sine', 0.05), 140);
}

function sfxHungryWhimper() {
  // Plaintive descending whimper ‚Äî sad falling tone
  if (!audioCtx || !mouseSfxReady()) return;
  const f = 1600 + Math.random() * 200;
  playTone(f, 0.1, 'sine', 0.1);
  setTimeout(() => playTone(f * 0.8, 0.12, 'sine', 0.08), 100);
  setTimeout(() => playTone(f * 0.6, 0.15, 'sine', 0.05), 220);
}

function sfxNuzzle() {
  // Affectionate trill ‚Äî warm rapid ascending
  if (!audioCtx || !mouseSfxReady()) return;
  const base = 1000 + Math.random() * 200;
  for (let i = 0; i < 5; i++) {
    setTimeout(() => playTone(base + i * 120, 0.04, 'sine', 0.07), i * 35);
  }
}

function sfxStartled() {
  // Sharp surprised squeak ‚Äî sudden high spike
  if (!audioCtx || !mouseSfxReady()) return;
  playTone(2400 + Math.random() * 400, 0.06, 'sine', 0.14);
  setTimeout(() => playTone(1800, 0.04, 'sine', 0.06), 70);
}

// --- Background music (gentle pentatonic loop) ---
// Multiple melodic phrases that cycle for variety
const MUSIC_PHRASES = [
  // Phrase A: gentle ascending (C major pentatonic)
  [[262,300],[294,300],[330,300],[392,300],[440,300],[392,300],[330,600],
   [294,300],[330,300],[262,600]],
  // Phrase B: playful skip pattern
  [[330,200],[392,200],[330,200],[440,400],[392,300],[330,300],[294,300],[262,600],
   [294,200],[330,200],[392,600]],
  // Phrase C: lullaby feel (slower, wider intervals)
  [[262,500],[392,500],[330,400],[294,300],[262,300],
   [330,500],[440,500],[392,400],[330,600]],
  // Phrase D: cheerful bounce
  [[392,200],[392,200],[440,400],[330,200],[330,200],[392,400],
   [294,300],[330,300],[392,300],[440,300],[392,600]],
  // Phrase E: descending calm
  [[523,400],[440,300],[392,300],[330,400],[294,300],[262,300],
   [294,300],[330,300],[262,600]],
  // Phrase F: call and response
  [[262,300],[330,300],[392,600],[0,200],
   [440,300],[392,300],[330,600],[0,200],
   [294,300],[330,300],[262,600]],
];

let musicPhraseIndex = 0;
let musicNoteIndex = 0;
let musicPhrase = MUSIC_PHRASES[0];

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;
  musicPhraseIndex = Math.floor(Math.random() * MUSIC_PHRASES.length);
  musicPhrase = MUSIC_PHRASES[musicPhraseIndex];
  musicNoteIndex = 0;
  playMusicNote();
}

function stopMusic() {
  musicPlaying = false;
  if (musicTimeout) clearTimeout(musicTimeout);
}

function playMusicNote() {
  if (!musicPlaying || audioMuted) { musicPlaying = false; return; }

  // Advance to next phrase when current one finishes
  if (musicNoteIndex >= musicPhrase.length) {
    musicPhraseIndex = (musicPhraseIndex + 1 + Math.floor(Math.random() * (MUSIC_PHRASES.length - 1))) % MUSIC_PHRASES.length;
    musicPhrase = MUSIC_PHRASES[musicPhraseIndex];
    musicNoteIndex = 0;
  }

  const [freq, dur] = musicPhrase[musicNoteIndex];
  musicNoteIndex++;

  if (freq > 0) {
    // Soft triangle wave melody
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 0.04);
    g.gain.setTargetAtTime(0, audioCtx.currentTime + (dur / 1000) * 0.6, (dur / 1000) * 0.15);
    osc.connect(g);
    g.connect(musicGain);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + dur / 1000 + 0.1);

    // Harmony: soft fifth or third below on some notes
    if (musicNoteIndex % 3 === 0) {
      const harmRatio = musicNoteIndex % 6 === 0 ? 0.667 : 0.8; // fifth or major third
      const osc2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = freq * harmRatio;
      g2.gain.value = 0.03;
      g2.gain.setTargetAtTime(0, audioCtx.currentTime + (dur / 1000) * 0.5, (dur / 1000) * 0.2);
      osc2.connect(g2);
      g2.connect(musicGain);
      osc2.start(audioCtx.currentTime);
      osc2.stop(audioCtx.currentTime + dur / 1000 + 0.15);
    }

    // Occasional soft bass note on phrase downbeats
    if (musicNoteIndex === 1) {
      const osc3 = audioCtx.createOscillator();
      const g3 = audioCtx.createGain();
      osc3.type = 'sine';
      osc3.frequency.value = freq * 0.5;
      g3.gain.value = 0.025;
      g3.gain.setTargetAtTime(0, audioCtx.currentTime + 0.3, 0.15);
      osc3.connect(g3);
      g3.connect(musicGain);
      osc3.start(audioCtx.currentTime);
      osc3.stop(audioCtx.currentTime + 0.6);
    }
  }

  musicTimeout = setTimeout(playMusicNote, dur);
}

// ============================================================
// MINI-GAME SOUNDTRACKS
// ============================================================
let gameMusicPlaying = false;
let gameMusicTimeout = null;
let gameMusicIntensity = 0; // 0-1, drives tempo/layers

function stopGameMusic() {
  gameMusicPlaying = false;
  if (gameMusicTimeout) clearTimeout(gameMusicTimeout);
  gameMusicTimeout = null;
}

// --- Cheese Chase: frantic chase in minor key ---
const CHASE_NOTES = [
  // A minor pentatonic, frantic ascending/descending runs
  [440, 392, 349, 330, 294, 330, 349, 392],  // phrase A
  [440, 494, 523, 494, 440, 392, 349, 330],  // phrase B
  [523, 494, 440, 392, 440, 494, 523, 587],  // phrase C ‚Äî climbs higher
  [587, 523, 494, 440, 523, 587, 659, 587],  // phrase D ‚Äî intense
];
let chaseNoteIdx = 0, chasePhraseIdx = 0;

function startChaseMusic() {
  if (!audioCtx || audioMuted) return;
  gameMusicPlaying = true;
  gameMusicIntensity = 0;
  chaseNoteIdx = 0;
  chasePhraseIdx = 0;
  playChaseMusicNote();
}

function playChaseMusicNote() {
  if (!gameMusicPlaying || audioMuted) { gameMusicPlaying = false; return; }
  const phrase = CHASE_NOTES[chasePhraseIdx % CHASE_NOTES.length];
  const freq = phrase[chaseNoteIdx % phrase.length];
  // Tempo increases with intensity: 180ms ‚Üí 90ms
  const tempo = Math.max(90, 180 - gameMusicIntensity * 90);
  const dur = tempo * 0.8;

  // Lead: square wave for retro chase feel
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;
  const vol = 0.04 + gameMusicIntensity * 0.02;
  g.gain.setValueAtTime(0, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
  g.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.5, dur / 1000 * 0.15);
  osc.connect(g); g.connect(musicGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + dur / 1000 + 0.05);

  // Bass pulse on every 4th note
  if (chaseNoteIdx % 4 === 0) {
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'triangle';
    ob.frequency.value = freq * 0.25;
    gb.gain.value = 0.03 + gameMusicIntensity * 0.02;
    gb.gain.setTargetAtTime(0, audioCtx.currentTime + 0.08, 0.04);
    ob.connect(gb); gb.connect(musicGain);
    ob.start(audioCtx.currentTime);
    ob.stop(audioCtx.currentTime + 0.15);
  }

  // Harmony layer kicks in at intensity > 0.3
  if (gameMusicIntensity > 0.3 && chaseNoteIdx % 2 === 0) {
    const oh = audioCtx.createOscillator();
    const gh = audioCtx.createGain();
    oh.type = 'sawtooth';
    oh.frequency.value = freq * 1.5; // fifth above
    gh.gain.value = 0.015 + gameMusicIntensity * 0.01;
    gh.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.4, dur / 1000 * 0.1);
    oh.connect(gh); gh.connect(musicGain);
    oh.start(audioCtx.currentTime);
    oh.stop(audioCtx.currentTime + dur / 1000 + 0.05);
  }

  // High arpeggio at intensity > 0.6
  if (gameMusicIntensity > 0.6 && chaseNoteIdx % 3 === 0) {
    const oa = audioCtx.createOscillator();
    const ga = audioCtx.createGain();
    oa.type = 'sine';
    oa.frequency.value = freq * 2;
    ga.gain.value = 0.02;
    ga.gain.setTargetAtTime(0, audioCtx.currentTime + 0.04, 0.02);
    oa.connect(ga); ga.connect(musicGain);
    oa.start(audioCtx.currentTime);
    oa.stop(audioCtx.currentTime + 0.08);
  }

  chaseNoteIdx++;
  if (chaseNoteIdx >= phrase.length) {
    chaseNoteIdx = 0;
    // Pick higher-intensity phrases as game progresses
    chasePhraseIdx = Math.min(Math.floor(gameMusicIntensity * CHASE_NOTES.length), CHASE_NOTES.length - 1);
  }
  gameMusicTimeout = setTimeout(playChaseMusicNote, tempo);
}

// --- Doomscroll: chill lo-fi with tension on strikes ---
const LOFI_NOTES = [
  [262, 294, 330, 349, 330, 294, 262, 247], // C major chill
  [330, 349, 392, 349, 330, 294, 330, 349], // gentle rise
  [392, 349, 330, 294, 262, 294, 330, 262], // descend
];
let lofiNoteIdx = 0, lofiPhraseIdx = 0;

function startLofiMusic() {
  if (!audioCtx || audioMuted) return;
  gameMusicPlaying = true;
  gameMusicIntensity = 0;
  lofiNoteIdx = 0;
  lofiPhraseIdx = 0;
  playLofiMusicNote();
}

function playLofiMusicNote() {
  if (!gameMusicPlaying || audioMuted) { gameMusicPlaying = false; return; }
  const phrase = LOFI_NOTES[lofiPhraseIdx % LOFI_NOTES.length];
  const freq = phrase[lofiNoteIdx % phrase.length];
  // Tempo: relaxed 280ms, speeds up slightly with strikes
  const tempo = Math.max(180, 280 - gameMusicIntensity * 100);
  const dur = tempo * 1.2;

  // Warm sine pad
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.value = freq;
  g.gain.setValueAtTime(0, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.06);
  g.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.6, dur / 1000 * 0.2);
  osc.connect(g); g.connect(musicGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + dur / 1000 + 0.1);

  // Soft triangle harmony
  if (lofiNoteIdx % 3 === 0) {
    const oh = audioCtx.createOscillator();
    const gh = audioCtx.createGain();
    oh.type = 'triangle';
    oh.frequency.value = freq * 0.75; // third below
    gh.gain.value = 0.025;
    gh.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.4, dur / 1000 * 0.15);
    oh.connect(gh); gh.connect(musicGain);
    oh.start(audioCtx.currentTime);
    oh.stop(audioCtx.currentTime + dur / 1000 + 0.1);
  }

  // Dissonant tension notes as strikes increase
  if (gameMusicIntensity > 0.3 && lofiNoteIdx % 4 === 0) {
    const od = audioCtx.createOscillator();
    const gd = audioCtx.createGain();
    od.type = 'sawtooth';
    // Slightly off-key for tension
    od.frequency.value = freq * (1 + gameMusicIntensity * 0.08);
    gd.gain.value = 0.01 + gameMusicIntensity * 0.02;
    gd.gain.setTargetAtTime(0, audioCtx.currentTime + 0.1, 0.05);
    od.connect(gd); gd.connect(musicGain);
    od.start(audioCtx.currentTime);
    od.stop(audioCtx.currentTime + 0.2);
  }

  // Heartbeat bass at high tension
  if (gameMusicIntensity > 0.5 && lofiNoteIdx % 4 === 0) {
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'sine';
    ob.frequency.value = 80;
    gb.gain.value = 0.04;
    gb.gain.setTargetAtTime(0, audioCtx.currentTime + 0.06, 0.03);
    ob.connect(gb); gb.connect(musicGain);
    ob.start(audioCtx.currentTime);
    ob.stop(audioCtx.currentTime + 0.12);
  }

  lofiNoteIdx++;
  if (lofiNoteIdx >= phrase.length) {
    lofiNoteIdx = 0;
    lofiPhraseIdx++;
  }
  gameMusicTimeout = setTimeout(playLofiMusicNote, tempo);
}

// --- Pac Mouse: exploration to triumph ---
const MAZE_NOTES = [
  // Level 1: sparse, mysterious (E minor)
  [330, 0, 294, 0, 330, 370, 330, 0],
  // Level 2: more melodic (G major)
  [392, 440, 494, 440, 392, 349, 392, 440],
  // Level 3: triumphant (C major rising)
  [523, 494, 523, 587, 659, 587, 523, 659],
];
let mazeNoteIdx = 0;

function startMazeMusic() {
  if (!audioCtx || audioMuted) return;
  gameMusicPlaying = true;
  gameMusicIntensity = 0;
  mazeNoteIdx = 0;
  playMazeMusicNote();
}

function playMazeMusicNote() {
  if (!gameMusicPlaying || audioMuted) { gameMusicPlaying = false; return; }
  // Pick phrase based on level (intensity 0=L1, 0.33=L2, 0.67=L3)
  const phraseIdx = Math.min(Math.floor(gameMusicIntensity * 3), 2);
  const phrase = MAZE_NOTES[phraseIdx];
  const freq = phrase[mazeNoteIdx % phrase.length];
  // Tempo: starts slow 350ms, speeds up per level
  const tempo = Math.max(180, 350 - gameMusicIntensity * 170);
  const dur = tempo * 1.0;

  if (freq > 0) {
    // Echoey triangle for exploration feel
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    const vol = 0.04 + gameMusicIntensity * 0.03;
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.03);
    g.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.7, dur / 1000 * 0.25);
    osc.connect(g); g.connect(musicGain);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + dur / 1000 + 0.2);

    // Echo/delay effect ‚Äî faint repeat
    setTimeout(() => {
      if (!gameMusicPlaying || audioMuted) return;
      const osc2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = freq * 1.005; // very slight detune for shimmer
      g2.gain.value = 0.015;
      g2.gain.setTargetAtTime(0, audioCtx.currentTime + 0.1, 0.08);
      osc2.connect(g2); g2.connect(musicGain);
      osc2.start(audioCtx.currentTime);
      osc2.stop(audioCtx.currentTime + 0.2);
    }, tempo * 0.4);

    // Bass notes in later levels
    if (gameMusicIntensity > 0.3 && mazeNoteIdx % 4 === 0) {
      const ob = audioCtx.createOscillator();
      const gb = audioCtx.createGain();
      ob.type = 'sine';
      ob.frequency.value = freq * 0.5;
      gb.gain.value = 0.025;
      gb.gain.setTargetAtTime(0, audioCtx.currentTime + 0.15, 0.08);
      ob.connect(gb); gb.connect(musicGain);
      ob.start(audioCtx.currentTime);
      ob.stop(audioCtx.currentTime + 0.3);
    }

    // Chime harmony in level 3
    if (gameMusicIntensity > 0.6 && mazeNoteIdx % 2 === 0) {
      const oc = audioCtx.createOscillator();
      const gc = audioCtx.createGain();
      oc.type = 'sine';
      oc.frequency.value = freq * 2;
      gc.gain.value = 0.012;
      gc.gain.setTargetAtTime(0, audioCtx.currentTime + 0.06, 0.04);
      oc.connect(gc); gc.connect(musicGain);
      oc.start(audioCtx.currentTime);
      oc.stop(audioCtx.currentTime + 0.12);
    }
  }

  mazeNoteIdx++;
  if (mazeNoteIdx >= phrase.length) mazeNoteIdx = 0;
  gameMusicTimeout = setTimeout(playMazeMusicNote, tempo);
}

// --- Whack-a-Cat: dramatic, percussive tension ---
const WHACK_NOTES = [
  // D minor: tense, dramatic (short staccato hits)
  [294, 349, 294, 262, 294, 349, 440, 349],
  // Builds: chromatic tension
  [294, 311, 330, 349, 370, 392, 415, 440],
  // Climax: fast descending strikes
  [523, 494, 466, 440, 415, 392, 370, 349],
  // Frenzy: rapid alternating
  [440, 294, 523, 349, 440, 294, 587, 440],
];
let whackNoteIdx = 0, whackPhraseIdx = 0;

function startWhackMusic() {
  if (!audioCtx || audioMuted) return;
  gameMusicPlaying = true;
  gameMusicIntensity = 0;
  whackNoteIdx = 0;
  whackPhraseIdx = 0;
  playWhackMusicNote();
}

function playWhackMusicNote() {
  if (!gameMusicPlaying || audioMuted) { gameMusicPlaying = false; return; }
  const phrase = WHACK_NOTES[whackPhraseIdx % WHACK_NOTES.length];
  const freq = phrase[whackNoteIdx % phrase.length];
  // Tempo: 200ms ‚Üí 110ms as intensity rises
  const tempo = Math.max(110, 200 - gameMusicIntensity * 90);
  const dur = tempo * 0.5; // very short staccato

  // Lead: sharp square wave stabs
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;
  const vol = 0.035 + gameMusicIntensity * 0.025;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.setTargetAtTime(0, audioCtx.currentTime + dur / 1000 * 0.3, dur / 1000 * 0.1);
  osc.connect(g); g.connect(musicGain);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + dur / 1000 + 0.05);

  // Percussive hit on every 2nd note ‚Äî noise burst
  if (whackNoteIdx % 2 === 0) {
    const bufSize = audioCtx.sampleRate * 0.03;
    const noiseBuf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
    const noise = audioCtx.createBufferSource();
    const ng = audioCtx.createGain();
    noise.buffer = noiseBuf;
    ng.gain.setValueAtTime(0.04 + gameMusicIntensity * 0.03, audioCtx.currentTime);
    ng.gain.setTargetAtTime(0, audioCtx.currentTime + 0.015, 0.008);
    noise.connect(ng); ng.connect(musicGain);
    noise.start(audioCtx.currentTime);
  }

  // Deep bass throb every 4 notes
  if (whackNoteIdx % 4 === 0) {
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'sawtooth';
    ob.frequency.value = freq * 0.25;
    gb.gain.setValueAtTime(0.04, audioCtx.currentTime);
    gb.gain.setTargetAtTime(0, audioCtx.currentTime + 0.1, 0.04);
    ob.connect(gb); gb.connect(musicGain);
    ob.start(audioCtx.currentTime);
    ob.stop(audioCtx.currentTime + 0.2);
  }

  // Dissonant tension layer at high intensity
  if (gameMusicIntensity > 0.5 && whackNoteIdx % 3 === 0) {
    const ot = audioCtx.createOscillator();
    const gt = audioCtx.createGain();
    ot.type = 'sawtooth';
    ot.frequency.value = freq * 1.06; // slightly sharp = tension
    gt.gain.value = 0.015;
    gt.gain.setTargetAtTime(0, audioCtx.currentTime + 0.04, 0.02);
    ot.connect(gt); gt.connect(musicGain);
    ot.start(audioCtx.currentTime);
    ot.stop(audioCtx.currentTime + 0.08);
  }

  whackNoteIdx++;
  if (whackNoteIdx >= phrase.length) {
    whackNoteIdx = 0;
    whackPhraseIdx = Math.min(Math.floor(gameMusicIntensity * WHACK_NOTES.length), WHACK_NOTES.length - 1);
  }
  gameMusicTimeout = setTimeout(playWhackMusicNote, tempo);
}

// Wire up sound button and volume slider
document.getElementById('btn-sound').addEventListener('click', (e) => {
  toggleMute();
  e.stopPropagation();
  // Position volume popup near the button
  const btn = document.getElementById('btn-sound');
  const popup = document.getElementById('volume-popup');
  if (!audioMuted) {
    const rect = btn.getBoundingClientRect();
    const isLand = window.innerHeight <= 440 && window.innerWidth > window.innerHeight;
    if (isLand) {
      // Landscape: popup to the right of the sidebar button
      popup.style.top = rect.top + 'px';
      popup.style.left = (rect.right + 4) + 'px';
      popup.style.right = 'auto';
    } else {
      // Portrait/desktop: popup below the button
      popup.style.top = (rect.bottom + 4) + 'px';
      popup.style.right = (window.innerWidth - rect.right) + 'px';
      popup.style.left = 'auto';
    }
    popup.style.display = 'block';
    setTimeout(() => { popup.style.display = 'none'; }, 3000);
  } else {
    popup.style.display = 'none';
  }
});

document.getElementById('volume-slider').addEventListener('input', (e) => {
  setVolume(parseInt(e.target.value) / 100);
});

// ============================================================
// GAME STATE
// ============================================================
let state = {
  coins: CONFIG.startingCoins,
  currentRoom: 0,
  ownedItems: [],
  placedItems: [],
  miceState: {
    pip: { x: 120, y: 0, room: 0, action: 'idle', actionTimer: 0, dir: 1, frame: 0, animTimer: 0, happiness: 80, level: 'main-floor' },
    chai:  { x: 250, y: 0, room: 1, action: 'idle', actionTimer: 0, dir: -1, frame: 0, animTimer: 0, happiness: 80, level: 'main-floor' }
  },
  birthdayEventSeen: false,
  letterRead: false,
  lootCrumbsUsed: 0,
  totalCoinsEarned: 0,
  placementMode: null,
  removeMode: false,
  dragState: { active: false, itemId: null, screenX: 0, screenY: 0, fromPlaced: false, fromPlacedIdx: -1, isTouch: false },
  shopOpen: false,
  gameStarted: false,
  activeGoal: null,
  achievements: [],
  stats: { mischiefsWitnessed: 0, itemsPlaced: 0, gamesPlayed: { chase: 0, doomscroll: 0, maze: 0, whack: 0 }, goalsCompleted: 0 },
  photos: []
};

// ============================================================
// ACHIEVEMENTS
// ============================================================
const ACHIEVEMENTS = [
  // Mouse Care
  { id: 'first-place', icon: 'üè†', name: 'Touch Grass (Bedding)', hint: 'Place your first item', check: s => s.stats.itemsPlaced >= 1 },
  { id: 'interior-designer', icon: 'üé®', name: 'Interior Designer', hint: 'Place 10 items', check: s => s.stats.itemsPlaced >= 10 },
  { id: 'full-house', icon: 'üè°', name: 'Full House', hint: 'Have items in every room', check: s => {
    const rooms = new Set(s.placedItems.map(p => p.room));
    return rooms.size >= 4;
  }},
  { id: 'fed-watered', icon: 'üíö', name: 'Fed & Watered', hint: 'Both mice at 100% health', check: s => s.miceState.pip.happiness >= 100 && s.miceState.chai.happiness >= 100 },
  { id: 'neglectful', icon: 'üò∞', name: 'Neglectful Parent', hint: 'Let a mouse drop below 10%', check: s => s.miceState.pip.happiness < 10 || s.miceState.chai.happiness < 10 },

  // Mini-Games
  { id: 'gamer-mouse', icon: 'üéÆ', name: 'Gamer Mouse', hint: 'Play all 4 mini-games', check: s => s.stats.gamesPlayed.chase > 0 && s.stats.gamesPlayed.doomscroll > 0 && s.stats.gamesPlayed.maze > 0 && s.stats.gamesPlayed.whack > 0 },
  { id: 'pac-pro', icon: 'üïπÔ∏è', name: 'Pac Mouse Pro', hint: 'Clear all 3 maze levels', check: () => false, manual: true },
  { id: 'cat-bonker', icon: 'üî®', name: 'Cat Bonker 9000', hint: 'Whack 30 cats in one game', check: () => false, manual: true },
  { id: 'speed-runner', icon: 'üí®', name: 'Speed Runner', hint: 'Reach 500m in Cheese Chase', check: () => false, manual: true },
  { id: 'doomscroll-detox', icon: 'üì±', name: 'Doomscroll Detox', hint: 'Get 15+ likes, zero strikes', check: () => false, manual: true },

  // Economy
  { id: 'first-coin', icon: 'ü™ô', name: 'First Paycheck', hint: 'Earn your first coin', check: s => s.totalCoinsEarned > 0 },
  { id: 'hoarder', icon: 'üßÄ', name: 'Cheese Hoarder', hint: 'Have 100 coins saved', check: s => s.coins >= 100 },
  { id: 'big-spender', icon: 'üí∏', name: 'Big Spender', hint: 'Spend 200 total coins', check: s => (s.totalCoinsEarned - s.coins) >= 200 },
  { id: 'capitalism', icon: 'üè™', name: 'Capitalism', hint: 'Buy every shop item once', check: s => {
    const buyable = FURNITURE.filter(f => !f.exerciseRoom && f.id !== 'party-banner');
    return buyable.every(f => s.ownedItems.includes(f.id) || s.placedItems.some(p => p.itemId === f.id));
  }},

  // Social / Vibes
  { id: 'birthday', icon: 'üéÇ', name: 'Birthday Mode', hint: 'Place a birthday cake', check: s => s.placedItems.some(p => p.itemId === 'birthday-cake') },
  { id: 'cozy-certified', icon: 'üõãÔ∏è', name: 'Certified Cozy', hint: 'Place a hammock, bed & blanket', check: s => {
    const ids = s.placedItems.map(p => p.itemId);
    return ids.includes('hammock') && ids.includes('matchbox-bed') && (ids.includes('blanket-nest') || ids.includes('tissue-blanket'));
  }},
  { id: 'unhinged', icon: 'üòà', name: 'Unhinged Energy', hint: 'Witness 10 mischief events', check: s => s.stats.mischiefsWitnessed >= 10 },
  { id: 'goal-getter', icon: 'üéØ', name: 'Goal Getter', hint: 'Complete 5 mouse goals', check: s => s.stats.goalsCompleted >= 5 },
  { id: 'wheel-warrior', icon: 'üé°', name: 'Wheel Warrior', hint: 'Watch a mouse get flung off the wheel', check: () => false, manual: true },
  { id: 'influencer', icon: 'üì∏', name: 'Influencer', hint: 'Take 10 selfies', check: s => s.photos.length >= 10 },

  // Meta
  { id: 'slay', icon: 'üíÖ', name: 'Slay', hint: 'Earn 500 total coins', check: s => s.totalCoinsEarned >= 500 },
  { id: 'main-character', icon: 'üëë', name: 'Main Character Energy', hint: 'Unlock 15 achievements', check: s => s.achievements.length >= 15 },
  { id: 'completionist', icon: 'üèÜ', name: 'Completionist', hint: 'Unlock all other achievements', check: s => s.achievements.length >= ACHIEVEMENTS.length - 1 },
];

function checkAchievements() {
  let newlyUnlocked = false;
  for (const ach of ACHIEVEMENTS) {
    if (state.achievements.includes(ach.id)) continue;
    if (ach.manual) continue;
    if (ach.check(state)) {
      state.achievements.push(ach.id);
      showAchievementToast(ach);
      newlyUnlocked = true;
    }
  }
  if (newlyUnlocked) {
    // Re-check for meta achievements (main-character, completionist)
    for (const ach of ACHIEVEMENTS) {
      if (state.achievements.includes(ach.id) || ach.manual) continue;
      if (ach.check(state)) {
        state.achievements.push(ach.id);
        showAchievementToast(ach);
      }
    }
    saveGame();
  }
}

function unlockAchievement(id) {
  if (state.achievements.includes(id)) return;
  const ach = ACHIEVEMENTS.find(a => a.id === id);
  if (!ach) return;
  state.achievements.push(id);
  // Bonus coins for unlocking achievement
  const bonus = 5;
  state.coins += bonus;
  updateCoinDisplay();
  showAchievementToast(ach, bonus);
  checkAchievements(); // trigger meta checks
  saveGame();
}

function showAchievementToast(ach, bonus) {
  showToast(`üèÜ Achievement: ${ach.icon} ${ach.name}${bonus ? ' +' + bonus + 'üßÄ' : ''}`);
  sfxAchievement();
}

function sfxAchievement() {
  if (!audioCtx || audioMuted) return;
  // Triumphant chime: rising arpeggio
  const notes = [523, 659, 784, 1047];
  notes.forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0, audioCtx.currentTime + i * 0.1);
    g.gain.linearRampToValueAtTime(0.06, audioCtx.currentTime + i * 0.1 + 0.02);
    g.gain.setTargetAtTime(0, audioCtx.currentTime + i * 0.1 + 0.15, 0.08);
    osc.connect(g); g.connect(musicGain);
    osc.start(audioCtx.currentTime + i * 0.1);
    osc.stop(audioCtx.currentTime + i * 0.1 + 0.4);
  });
}

let trophyOpen = false;

function openTrophyCase() {
  if (trophyOpen) { closeTrophyFlyout(); return; }
  trophyOpen = true;
  if (state.shopOpen) closeShopFlyout();
  if (gamesOpen) closeGamesFlyout();
  if (albumOpen) closeAlbumFlyout();

  document.getElementById('trophy-subtitle').textContent =
    `${state.achievements.length} / ${ACHIEVEMENTS.length} unlocked`;

  let html = '<div style="display:grid;grid-template-columns:1fr;gap:6px;">';
  for (const ach of ACHIEVEMENTS) {
    const unlocked = state.achievements.includes(ach.id);
    if (unlocked) {
      html += `<div style="display:flex;align-items:center;gap:8px;padding:8px 10px;background:#2a1a0a;border-radius:6px;border:1px solid #5a3e28;">
        <span style="font-size:22px;flex-shrink:0;">${ach.icon}</span>
        <div><div style="color:#f5d68a;font-size:13px;font-weight:bold;">${ach.name}</div>
        <div style="color:#a89070;font-size:11px;">${ach.hint}</div></div>
      </div>`;
    } else {
      html += `<div style="display:flex;align-items:center;gap:8px;padding:8px 10px;background:#1a1008;border-radius:6px;border:1px solid #3d2b1a;opacity:0.6;">
        <span style="font-size:22px;flex-shrink:0;">üîí</span>
        <div><div style="color:#8a7a6a;font-size:13px;font-weight:bold;">???</div>
        <div style="color:#7a6a5a;font-size:11px;">${ach.hint}</div></div>
      </div>`;
    }
  }
  html += '</div>';

  document.getElementById('trophy-body').innerHTML = html;
  document.getElementById('trophy-flyout').classList.add('open');
  showBackdrop();
  document.getElementById('tray-toggle').classList.add('disabled');
}

function closeTrophyFlyout() {
  trophyOpen = false;
  document.getElementById('trophy-flyout').classList.remove('open');
  if (!state.shopOpen && !gamesOpen && !albumOpen) document.getElementById('tray-toggle').classList.remove('disabled');
  if (!trayOpen && !state.shopOpen && !gamesOpen && !albumOpen) hideBackdrop();
}
document.getElementById('trophy-flyout-close').addEventListener('click', closeTrophyFlyout);

// ============================================================
// MOUSE SELFIES üì∏
// ============================================================
const SELFIE_W = 200, SELFIE_H = 200;
const SELFIE_MAX = 10;

const SELFIE_FILTERS = [
  { name: 'cottagecore üåø', tint: 'rgba(180,220,160,0.12)', border: '#8B7355' },
  { name: 'golden hour ‚òÄÔ∏è', tint: 'rgba(255,200,80,0.15)', border: '#DAA520' },
  { name: 'dark academia üìö', tint: 'rgba(40,30,20,0.2)', border: '#5a3e28' },
  { name: 'Y2K üíø', tint: 'rgba(200,150,255,0.12)', border: '#cc88ff' },
  { name: 'lo-fi üéµ', tint: 'rgba(100,140,180,0.15)', border: '#6688aa' },
  { name: 'no filter üê≠', tint: 'rgba(0,0,0,0)', border: '#f5d68a' },
  { name: 'cozy vibes ‚ú®', tint: 'rgba(255,180,120,0.12)', border: '#e8a040' },
  { name: 'midnight üåô', tint: 'rgba(30,20,60,0.2)', border: '#8888cc' },
];

const SELFIE_CAPTIONS = {
  idle: ['no thoughts just vibes', 'literally just existing', 'main character energy ‚ú®', 'serving face üíÖ'],
  walking: ['on the move üêæ', 'steps goal: completed', 'exploring hours', 'adventure awaits'],
  zoomies: ['ZOOMIES üí®', 'can\'t stop won\'t stop', 'nyoom', 'speed demon mode'],
  sleeping: ['caught napping üò¥', 'do not disturb', 'beauty sleep era', 'snoozin & cruisin'],
  eating: ['snack break üßÄ', 'foodie mode activated', 'nom nom nom', 'eating my feelings'],
  grooming: ['spa day üíÖ', 'self care sunday', 'glow up in progress', 'beauty routine'],
  mischief: ['crime scene selfie üòà', 'chaos mode: ON', 'nothing to see here', 'caught in 4k'],
  yoga: ['namaste üßò', 'stretching goals', 'zen mode', 'inner peace achieved'],
  doomscrolling: ['doomscroll break üì±', 'one more post...', 'algorithm won today', 'screen time: yes'],
  wheeling: ['gym selfie üé°', 'leg day every day', 'cardio queen', 'fitness era'],
  climbing: ['rock climbing üßó', 'summit selfie', 'living on the edge', 'going up!'],
  hiding: ['you can\'t see me üëÄ', 'stealth mode', 'introvert hours', 'hiding spot: found'],
  default: ['we\'re literally icons', 'slay üíÖ', 'POV: mice being cute', 'living our best life üê≠', 'no notes', 'iconic behavior', 'this is our year']
};

const SELFIE_REACTIONS = {
  pip: ['omg wait let me pose', 'this is my good side üíÖ', 'another one for the gram', 'delete that rn', 'SLAY', 'ok this one\'s cute', '*poses aggressively*', 'we ate that up'],
  chai: ['wait I wasn\'t ready', 'do I look ok? ü•∫', 'one more one more', 'aesthetic üì∏', '*subtle pose*', 'tag me', 'my whiskers look weird', 'this is THE one']
};

function takeMouseSelfie() {
  if (cheeseChaseActive || mouseMazeActive || whackACatActive) return;

  const pip = state.miceState.pip;
  const chai = state.miceState.chai;

  // Pick caption based on current actions
  const actions = [pip.action, chai.action];
  let captionPool = SELFIE_CAPTIONS.default;
  for (const a of actions) {
    if (SELFIE_CAPTIONS[a]) { captionPool = SELFIE_CAPTIONS[a]; break; }
  }
  const caption = captionPool[Math.floor(Math.random() * captionPool.length)];

  // Photobomb chance (5%)
  const photobomb = Math.random() < 0.05;

  // Create offscreen canvas
  const sc = document.createElement('canvas');
  sc.width = SELFIE_W;
  sc.height = SELFIE_H;
  const sctx = sc.getContext('2d');

  // Smart zoom: find mice in current room and crop to them
  const miceInRoom = [];
  if (pip.room === state.currentRoom) {
    const py = pip.action === 'flung' ? pip.flingY : getMouseFloorY(pip);
    miceInRoom.push({ x: pip.x, y: py });
  }
  if (chai.room === state.currentRoom) {
    const cy2 = chai.action === 'flung' ? chai.flingY : getMouseFloorY(chai);
    miceInRoom.push({ x: chai.x, y: cy2 });
  }

  // Calculate crop region in game-canvas coordinates
  let srcX, srcY, srcW, srcH;
  if (miceInRoom.length > 0) {
    // Bounding box of mice (mice are ~28px wide, ~24px tall)
    const MW = 28, MH = 24;
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const m of miceInRoom) {
      minX = Math.min(minX, m.x);
      maxX = Math.max(maxX, m.x + MW);
      minY = Math.min(minY, m.y - MH);
      maxY = Math.max(maxY, m.y + 4);
    }
    // Add generous padding around mice
    const pad = 40;
    minX -= pad; minY -= pad; maxX += pad; maxY += pad;

    // Ensure aspect ratio matches SELFIE_W/SELFIE_H (1:1)
    const aspect = SELFIE_W / SELFIE_H;
    let cropW = maxX - minX;
    let cropH = maxY - minY;
    // Enforce minimum crop size so single mouse isn't absurdly zoomed
    const minCrop = 120;
    if (cropW < minCrop) { const d = minCrop - cropW; minX -= d / 2; cropW = minCrop; }
    if (cropH < minCrop) { const d = minCrop - cropH; minY -= d / 2; cropH = minCrop; }
    // Fix aspect ratio (square)
    if (cropW > cropH) {
      minY -= (cropW - cropH) / 2;
      cropH = cropW;
    } else {
      minX -= (cropH - cropW) / 2;
      cropW = cropH;
    }
    // Clamp to room bounds
    if (minX < 0) minX = 0;
    if (minY < ROOM_Y) minY = ROOM_Y;
    if (minX + cropW > GAME_W) minX = GAME_W - cropW;
    if (minY + cropH > ROOM_Y + ROOM_H) minY = ROOM_Y + ROOM_H - cropH;
    // Final clamp
    minX = Math.max(0, minX);
    minY = Math.max(ROOM_Y, minY);
    cropW = Math.min(cropW, GAME_W);
    cropH = Math.min(cropH, ROOM_H);
    srcX = minX; srcY = minY; srcW = cropW; srcH = cropH;
  } else {
    // No mice visible ‚Äî fall back to center square of room
    const side = Math.min(GAME_W, ROOM_H);
    srcX = (GAME_W - side) / 2; srcY = ROOM_Y + (ROOM_H - side) / 2; srcW = side; srcH = side;
  }

  // Draw cropped region (zoomed into mice)
  // Canvas pixels are scaled by devicePixelRatio, so multiply source coords
  const dpr = window.devicePixelRatio || 1;
  sctx.drawImage(canvas, srcX * dpr, srcY * dpr, srcW * dpr, srcH * dpr, 0, 0, SELFIE_W, SELFIE_H);

  // Photobomb: drawn into raw image so it persists
  if (photobomb) {
    sctx.font = '32px serif';
    sctx.fillText('üòº', SELFIE_W - 40, SELFIE_H - 8);
  }

  const rawDataUrl = sc.toDataURL('image/jpeg', 0.85);

  // Flash + sound + reactions
  selfieFlash = 500;
  sfxSelfie();

  const pipReact = SELFIE_REACTIONS.pip[Math.floor(Math.random() * SELFIE_REACTIONS.pip.length)];
  const chaiReact = SELFIE_REACTIONS.chai[Math.floor(Math.random() * SELFIE_REACTIONS.chai.length)];
  if (pip.room === state.currentRoom) {
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip');
    speechBubbles.push({ x: pip.x + 14, y: getMouseFloorY(pip) - 10, text: pipReact, timer: 2500, maxTimer: 2500, mouseKey: 'pip' });
  }
  setTimeout(() => {
    if (chai.room === state.currentRoom) {
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'chai');
      speechBubbles.push({ x: chai.x + 14, y: getMouseFloorY(chai) - 10, text: chaiReact, timer: 2500, maxTimer: 2500, mouseKey: 'chai' });
    }
  }, 800);

  // Open preview modal after brief delay for flash
  setTimeout(() => {
    _selfiePreviewFilterIdx = Math.floor(Math.random() * SELFIE_FILTERS.length);
    openSelfiePreview({
      rawData: rawDataUrl,
      caption: caption,
      room: ROOMS[state.currentRoom].name,
      pipAction: pip.action,
      chaiAction: chai.action,
      photobomb: photobomb,
      timestamp: Date.now()
    });
  }, 350);
}

let selfieFlash = 0;
let _selfiePreviewFilterIdx = 0;

function applyFilterToCanvas(rawDataUrl, filterIdx, caption) {
  const filter = SELFIE_FILTERS[filterIdx];
  const sc = document.createElement('canvas');
  sc.width = SELFIE_W; sc.height = SELFIE_H;
  const sctx = sc.getContext('2d');
  const img = new Image();
  return new Promise(resolve => {
    img.onload = () => {
      sctx.drawImage(img, 0, 0, SELFIE_W, SELFIE_H);
      if (filter.tint !== 'rgba(0,0,0,0)') {
        sctx.fillStyle = filter.tint;
        sctx.fillRect(0, 0, SELFIE_W, SELFIE_H);
      }
      // Vignette
      const r = SELFIE_W * 0.6;
      const vig = sctx.createRadialGradient(SELFIE_W / 2, SELFIE_H / 2, r * 0.4, SELFIE_W / 2, SELFIE_H / 2, r);
      vig.addColorStop(0, 'rgba(0,0,0,0)');
      vig.addColorStop(1, 'rgba(0,0,0,0.3)');
      sctx.fillStyle = vig;
      sctx.fillRect(0, 0, SELFIE_W, SELFIE_H);
      // Caption
      if (caption) {
        sctx.font = '10px monospace';
        const capW = Math.min(SELFIE_W - 16, sctx.measureText(caption).width + 16);
        sctx.fillStyle = 'rgba(0,0,0,0.6)';
        sctx.beginPath(); sctx.roundRect((SELFIE_W - capW) / 2, SELFIE_H - 24, capW, 18, 4); sctx.fill();
        sctx.fillStyle = '#fff'; sctx.textAlign = 'center';
        sctx.fillText(caption, SELFIE_W / 2, SELFIE_H - 10);
        sctx.textAlign = 'left';
      }
      // Frame border
      sctx.strokeStyle = filter.border; sctx.lineWidth = 3;
      sctx.strokeRect(1.5, 1.5, SELFIE_W - 3, SELFIE_H - 3);
      resolve(sc.toDataURL('image/jpeg', 0.85));
    };
    img.src = rawDataUrl;
  });
}

function openSelfiePreview(draft) {
  const container = document.getElementById('modal-container');
  const fi = _selfiePreviewFilterIdx;

  let html = '<div class="modal-overlay" onclick="if(event.target===this){_selfieDraft=null;closeModal()}">';
  html += '<div class="modal-content" style="max-width:380px;padding:10px 14px;">';
  html += `<p style="font-size:13px;margin:0 0 6px;color:#f5d68a;text-align:center;">\u{1f4f8} ${draft.caption}</p>`;
  // Side-by-side: preview left, filters right
  html += `<div style="display:flex;gap:8px;align-items:flex-start;">`;
  html += `<img id="selfie-preview-img" src="${draft.rawData}" style="width:210px;height:210px;object-fit:cover;border-radius:6px;border:3px solid ${SELFIE_FILTERS[fi].border};flex-shrink:0;" alt="Preview">`;
  // Right column: filters only
  html += `<div style="display:flex;flex-direction:column;gap:3px;min-width:0;">`;
  SELFIE_FILTERS.forEach((f, i) => {
    const sel = i === fi;
    html += `<button onclick="_selfiePreviewFilterIdx=${i};openSelfiePreview(_selfieDraft)" style="font-size:10px;padding:3px 6px;border-radius:6px;border:1.5px solid ${sel ? '#f5d68a' : '#3d2b1a'};background:${sel ? '#3d2b1a' : '#1a1008'};color:${sel ? '#f5d68a' : '#8a7a6a'};cursor:pointer;text-align:left;white-space:nowrap;">${sel ? '‚ñ∏ ' : ''}${f.name}</button>`;
  });
  html += `</div></div>`; // end right column + flex row
  // Action buttons ‚Äî full width under preview+filters
  html += `<div style="display:flex;gap:6px;margin-top:8px;">`;
  html += `<button class="close-btn" style="background:#2a5a2a;font-size:12px;padding:5px 0;flex:1;" onclick="saveSelfie()">\u{1f4be} Save</button>`;
  html += `<button id="selfie-copy-btn" class="close-btn" style="font-size:12px;padding:5px 0;flex:1;" onclick="copySelfieToClipboard()">\u{1f4cb} Copy</button>`;
  html += `</div>`;
  html += '</div></div>';

  window._selfieDraft = draft;
  container.innerHTML = html;

  applyFilterToCanvas(draft.rawData, fi, draft.caption).then(url => {
    const img = document.getElementById('selfie-preview-img');
    if (img) { img.src = url; img.style.borderColor = SELFIE_FILTERS[fi].border; }
  });
}

function saveSelfie() {
  const draft = window._selfieDraft;
  if (!draft) return;
  const fi = _selfiePreviewFilterIdx;
  applyFilterToCanvas(draft.rawData, fi, draft.caption).then(finalUrl => {
    const photo = {
      data: finalUrl,
      caption: draft.caption,
      filter: SELFIE_FILTERS[fi].name,
      room: draft.room,
      pipAction: draft.pipAction,
      chaiAction: draft.chaiAction,
      photobomb: draft.photobomb,
      timestamp: draft.timestamp
    };
    state.photos.unshift(photo);
    if (state.photos.length > SELFIE_MAX) state.photos.pop();
    if (state.photos.length >= 10) unlockAchievement('influencer');
    saveGame();
    window._selfieDraft = null;
    closeModal();
    showToast(draft.photobomb ? '\u{1f4f8} Saved! ...wait, is that a CAT?! \u{1f63c}' : `\u{1f4f8} Saved! "${draft.caption}"`);
  });
}

function copySelfieToClipboard() {
  const draft = window._selfieDraft;
  if (!draft) return;
  const btn = document.getElementById('selfie-copy-btn');
  const fi = _selfiePreviewFilterIdx;
  applyFilterToCanvas(draft.rawData, fi, draft.caption).then(url => {
    const img = new Image();
    img.onload = () => {
      const sc = document.createElement('canvas');
      sc.width = SELFIE_W; sc.height = SELFIE_H;
      sc.getContext('2d').drawImage(img, 0, 0);
      sc.toBlob(blob => {
        if (!blob) { showToast('\u274c Copy failed'); return; }
        navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]).then(
          () => {
            sfxCoinCollect();
            if (btn) { btn.style.background = '#2a5a2a'; setTimeout(() => { btn.style.background = ''; }, 400); }
          },
          () => showToast('\u274c Clipboard not available')
        );
      }, 'image/png');
    };
    img.src = url;
  });
}

function copyAlbumPhotoToClipboard(idx) {
  const photo = state.photos[idx];
  if (!photo) return;
  const img = new Image();
  img.onload = () => {
    const sc = document.createElement('canvas');
    sc.width = img.naturalWidth; sc.height = img.naturalHeight;
    sc.getContext('2d').drawImage(img, 0, 0);
    sc.toBlob(blob => {
      if (!blob) { showToast('\u274c Copy failed'); return; }
      navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]).then(
        () => showToast('\u{1f4cb} Copied to clipboard!'),
        () => showToast('\u274c Clipboard not available')
      );
    }, 'image/png');
  };
  img.src = photo.data;
}

function sfxSelfie() {
  if (!audioCtx || audioMuted) return;
  // Camera shutter: quick noise burst + high click
  const bufSize = audioCtx.sampleRate * 0.04;
  const noiseBuf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.4;
  const noise = audioCtx.createBufferSource();
  const ng = audioCtx.createGain();
  noise.buffer = noiseBuf;
  ng.gain.setValueAtTime(0.06, audioCtx.currentTime);
  ng.gain.setTargetAtTime(0, audioCtx.currentTime + 0.02, 0.01);
  noise.connect(ng); ng.connect(musicGain);
  noise.start(audioCtx.currentTime);
  // Click tone
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.value = 2000;
  g.gain.setValueAtTime(0.05, audioCtx.currentTime + 0.02);
  g.gain.setTargetAtTime(0, audioCtx.currentTime + 0.05, 0.01);
  osc.connect(g); g.connect(musicGain);
  osc.start(audioCtx.currentTime + 0.02);
  osc.stop(audioCtx.currentTime + 0.08);
}

let albumOpen = false;

function openPhotoAlbum() {
  if (albumOpen) { closeAlbumFlyout(); return; }
  albumOpen = true;
  if (state.shopOpen) closeShopFlyout();
  if (gamesOpen) closeGamesFlyout();
  if (trophyOpen) closeTrophyFlyout();

  document.getElementById('album-subtitle').textContent =
    `${state.photos.length} / ${SELFIE_MAX} photos`;

  let html = '';
  if (state.photos.length === 0) {
    html += '<p style="text-align:center;color:#7a6a5a;font-size:13px;padding:20px 0;">No photos yet! Tap üì∏ to take a selfie.</p>';
  } else {
    html += '<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;">';
    state.photos.forEach((photo, i) => {
      const date = new Date(photo.timestamp);
      const timeStr = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
      html += `<div style="cursor:pointer;border-radius:6px;overflow:hidden;border:2px solid #3d2b1a;background:#1a1008;transition:border-color 0.2s;" onclick="viewPhoto(${i})" onmouseover="this.style.borderColor='#f5d68a'" onmouseout="this.style.borderColor='#3d2b1a'">
        <img src="${photo.data}" style="width:100%;aspect-ratio:1;object-fit:cover;display:block;" alt="Selfie">
        <div style="padding:4px 6px;">
          <div style="color:#f5d68a;font-size:9px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${photo.caption}</div>
          <div style="color:#7a6a5a;font-size:8px;">${photo.room} ¬∑ ${timeStr}</div>
        </div>
      </div>`;
    });
    html += '</div>';
  }

  document.getElementById('album-body').innerHTML = html;
  document.getElementById('album-flyout').classList.add('open');
  showBackdrop();
  document.getElementById('tray-toggle').classList.add('disabled');
}

function closeAlbumFlyout() {
  albumOpen = false;
  document.getElementById('album-flyout').classList.remove('open');
  if (!state.shopOpen && !gamesOpen && !trophyOpen) document.getElementById('tray-toggle').classList.remove('disabled');
  if (!trayOpen && !state.shopOpen && !gamesOpen && !trophyOpen) hideBackdrop();
}
document.getElementById('album-flyout-close').addEventListener('click', closeAlbumFlyout);

function refreshAlbumBody() {
  document.getElementById('album-subtitle').textContent =
    `${state.photos.length} / ${SELFIE_MAX} photos`;
  let html = '';
  if (state.photos.length === 0) {
    html += '<p style="text-align:center;color:#7a6a5a;font-size:13px;padding:20px 0;">No photos yet! Tap üì∏ to take a selfie.</p>';
  } else {
    html += '<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;">';
    state.photos.forEach((photo, i) => {
      const date = new Date(photo.timestamp);
      const timeStr = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
      html += `<div style="cursor:pointer;border-radius:6px;overflow:hidden;border:2px solid #3d2b1a;background:#1a1008;transition:border-color 0.2s;" onclick="viewPhoto(${i})" onmouseover="this.style.borderColor='#f5d68a'" onmouseout="this.style.borderColor='#3d2b1a'">
        <img src="${photo.data}" style="width:100%;aspect-ratio:1;object-fit:cover;display:block;" alt="Selfie">
        <div style="padding:4px 6px;">
          <div style="color:#f5d68a;font-size:9px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${photo.caption}</div>
          <div style="color:#7a6a5a;font-size:8px;">${photo.room} ¬∑ ${timeStr}</div>
        </div>
      </div>`;
    });
    html += '</div>';
  }
  document.getElementById('album-body').innerHTML = html;
}

function viewPhoto(idx) {
  const photo = state.photos[idx];
  if (!photo) return;
  const date = new Date(photo.timestamp);
  const timeStr = date.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' }) + ' ' + date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
  const container = document.getElementById('modal-container');

  let html = '<div class="modal-overlay" onclick="if(event.target===this)closeModal()">';
  html += '<div class="modal-content" style="max-width:480px;text-align:center;">';
  html += `<h2 style="font-size:16px;">\u{1f4f8} ${photo.caption}</h2>`;
  html += `<img src="${photo.data}" style="width:100%;max-width:320px;aspect-ratio:1;object-fit:cover;border-radius:8px;border:3px solid #5a3e28;margin:10px auto;display:block;" alt="Selfie">`;
  html += `<p style="color:#a89070;font-size:11px;margin:4px 0;">\u{1f4cd} ${photo.room}${photo.filter ? ' \u00b7 ' + photo.filter : ''}</p>`;
  html += `<p style="color:#7a6a5a;font-size:10px;margin:2px 0;">\u{1f42d} Pip: ${photo.pipAction} \u00b7 Chai: ${photo.chaiAction}${photo.photobomb ? ' \u00b7 \u{1f63c} PHOTOBOMBED!' : ''}</p>`;
  html += `<p style="color:#5a4a3a;font-size:9px;margin:2px 0;">${timeStr}</p>`;
  html += `<div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">`;
  html += `<button class="close-btn" onclick="copyAlbumPhotoToClipboard(${idx})">\u{1f4cb} Copy</button>`;
  html += `<button id="del-photo-btn" class="close-btn" style="background:#5a2020;" onclick="confirmDeletePhoto(this,${idx})">\u{1f5d1}\ufe0f Delete</button>`;
  html += `</div>`;
  html += '</div></div>';
  container.innerHTML = html;
}

let _deletePhotoTimer = null;
function confirmDeletePhoto(btn, idx) {
  if (btn.dataset.armed === 'true') {
    clearTimeout(_deletePhotoTimer);
    state.photos.splice(idx, 1);
    saveGame();
    closeModal();
    refreshAlbumBody();
    return;
  }
  btn.dataset.armed = 'true';
  btn.textContent = 'Tap again to delete';
  btn.style.background = '#8a2020';
  _deletePhotoTimer = setTimeout(() => {
    btn.dataset.armed = '';
    btn.textContent = '\u{1f5d1}\ufe0f Delete';
    btn.style.background = '#5a2020';
  }, 3000);
}

// ============================================================
// FURNITURE CATALOG
// ============================================================
const FURNITURE = [
  { id: 'matchbox-bed', name: 'Matchbox Bed', icon: 'üõè', price: 10,
    desc: 'A cozy matchbox. Smells like sulfur and dreams.', w: 2, h: 1,
    color: '#8B4513', mouseBehavior: 'sleeping' },
  { id: 'thimble-cup', name: 'Thimble Cup', icon: '‚òï', price: 5,
    desc: "One thimble of coffee. It's a latte, actually.", w: 1, h: 1,
    color: '#C0C0C0', mouseBehavior: 'eating' },
  { id: 'bottlecap-plate', name: 'Bottle Cap Plate', icon: 'üçΩ', price: 5,
    desc: 'Fine dining. Michelin star pending.', w: 1, h: 1,
    color: '#FF6347', mouseBehavior: 'eating' },
  { id: 'fairy-lights', name: 'Fairy Lights', icon: '‚ú®', price: 15,
    desc: 'Aesthetic‚Ñ¢. Very cottagecore.', w: 3, h: 1,
    color: '#FFD700', mouseBehavior: null, wallMount: true },
  { id: 'tiny-laptop', name: 'Tiny Laptop', icon: 'üíª', price: 30,
    desc: 'For doomscrolling at 3am. No judgment.', w: 1, h: 1,
    color: '#708090', mouseBehavior: 'doomscrolling' },
  { id: 'yoga-mat', name: 'Yoga Mat', icon: 'üßò', price: 12,
    desc: 'Namaste in bed, actually.', w: 2, h: 1,
    color: '#9370DB', mouseBehavior: 'yoga' },
  { id: 'live-laugh-cheese', name: '"Live Laugh Cheese"', icon: 'üìú', price: 8,
    desc: 'The pinnacle of interior design.', w: 2, h: 1,
    color: '#FFF8DC', mouseBehavior: null, wallMount: true },
  { id: 'sourdough', name: 'Sourdough Starter', icon: 'üçû', price: 20,
    desc: "Started in 2020. Has a name. Don't ask.", w: 1, h: 1,
    color: '#DEB887', mouseBehavior: 'eating', servings: 6 },
  { id: 'ring-light', name: 'Ring Light', icon: 'üí°', price: 18,
    desc: 'Content creation station. Very influencer.', w: 1, h: 1,
    color: '#FFE4B5', mouseBehavior: null },
  { id: 'cardboard-couch', name: 'Cardboard Couch', icon: 'üõã', price: 15,
    desc: "It's giving... IKEA but make it rodent.", w: 2, h: 1,
    color: '#8FBC8F', mouseBehavior: 'idle' },
  { id: 'spool-table', name: 'Spool Table', icon: 'ü™ë', price: 10,
    desc: 'Upcycled. Sustainable. Cottagecore.', w: 1, h: 1,
    color: '#D2691E', mouseBehavior: null },
  { id: 'eraser-tv', name: 'Eraser TV', icon: 'üì∫', price: 20,
    desc: 'Only shows static but they love it.', w: 1, h: 1,
    color: '#2F4F4F', mouseBehavior: 'watching' },
  { id: 'ethernet-rope', name: 'Ethernet Jump Rope', icon: 'üîå', price: 10,
    desc: 'Cat5e for cardio. Technically still connected.', w: 1, h: 1,
    color: '#4682B4', mouseBehavior: 'playing' },
  { id: 'cork-stool', name: 'Cork Stool', icon: 'ü™ë', price: 6,
    desc: 'Wine night leftover. Reduce reuse re-sit.', w: 1, h: 1,
    color: '#BC8F8F', mouseBehavior: null },
  { id: 'tiny-plant', name: 'Tiny Plant', icon: 'ü™¥', price: 8,
    desc: "It's fake but we don't talk about that.", w: 1, h: 1,
    color: '#228B22', mouseBehavior: null },
  { id: 'disco-ball', name: 'Disco Ball', icon: 'ü™©', price: 22,
    desc: 'For when the zoomies hit at midnight.', w: 1, h: 1,
    color: '#E0E0E0', mouseBehavior: 'zoomies', wallMount: true },
  { id: 'among-us-bean', name: 'Sus Beanbag', icon: 'ü´ò', price: 15,
    desc: 'A bit sus but very comfy. Emergency nap.', w: 1, h: 1,
    color: '#EF4444', mouseBehavior: 'sleeping' },
  { id: 'cheese-wheel', name: 'Cheese Wheel', icon: 'üßÄ', price: 25,
    desc: 'The holy grail. The one cheese to rule them all.', w: 1, h: 1,
    color: '#FFD700', mouseBehavior: 'eating', servings: 4 },
  { id: 'cheese-wedge', name: 'Cheese Wedge', icon: 'üßÄ', price: 5,
    desc: 'A lil snack. Gone in three bites.', w: 1, h: 1,
    color: '#f0c040', mouseBehavior: 'eating', servings: 3, isFood: true },
  { id: 'blueberry-bowl', name: 'Blueberry Bowl', icon: 'ü´ê', price: 3,
    desc: 'Antioxidants! Five tiny berries of joy.', w: 1, h: 1,
    color: '#4a5ab0', mouseBehavior: 'eating', servings: 5, isFood: true },
  { id: 'stamp-painting', name: 'Stamp Painting', icon: 'üñº', price: 8,
    desc: 'Is it modern art? Is it a stamp? Yes.', w: 1, h: 1,
    color: '#DDA0DD', mouseBehavior: null, wallMount: true },
  { id: 'tiny-hoodie', name: 'Tiny Hoodie Rack', icon: 'üß•', price: 12,
    desc: 'For when the vibes are chilly.', w: 1, h: 1,
    color: '#4169E1', mouseBehavior: null },
  { id: 'hammock', name: 'Cozy Hammock', icon: 'üõèÔ∏è', price: 20,
    desc: 'Hangs under a shelf. The ultimate nap pod.', w: 3, h: 1,
    color: '#c9956b', mouseBehavior: 'sleeping', wallMount: true },
  { id: 'tp-tunnel', name: 'TP Tube Tunnel', icon: 'üßª', price: 8,
    desc: 'Hide and seek champion. Infinite entertainment.', w: 2, h: 1,
    color: '#e8dcc8', mouseBehavior: 'hiding' },
  { id: 'chew-stick', name: 'Chew Stick', icon: 'ü™µ', price: 6,
    desc: 'Anxiety coping mechanism. Very therapeutic.', w: 1, h: 1,
    color: '#a0764a', mouseBehavior: 'chewing' },
  { id: 'climbing-rope', name: 'Climbing Rope', icon: 'ü™¢', price: 15,
    desc: 'Vertical zoomies. Spider-mouse era.', w: 1, h: 3,
    color: '#c4a050', mouseBehavior: 'swinging', wallMount: true },
  // Birthday items (hidden until birthday event)
  { id: 'birthday-cake', name: 'Birthday Cake', icon: 'üéÇ', price: 0,
    desc: 'Happy 20th Nico & Rose! üéâ', w: 1, h: 1,
    color: '#FF69B4', mouseBehavior: 'eating', birthday: true },
  { id: 'party-banner', name: 'Party Banner', icon: 'üéâ', price: 0,
    desc: "It's giving... birthday.", w: 3, h: 1,
    color: '#FF1493', mouseBehavior: null, birthday: true, wallMount: true },
  { id: 'exercise-wheel', name: 'Exercise Wheel', icon: 'üé°', price: 0,
    desc: 'Cardio queen era. Spin to win.', w: 3, h: 3,
    color: '#708898', mouseBehavior: 'wheeling', exerciseRoom: true },
];

// ============================================================
// CANVAS SETUP ‚Äî 480x360 game coords, scaled to fit
// ============================================================
const canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
let GAME_W = 480;
const GAME_H = 360;
const BASE_GAME_W = 480; // default/portrait width
const GRID_SIZE = 24;
const SNAP_SIZE = 12; // finer placement grid (half-cell)
const ROOM_Y = 40;
const ROOM_H = 280;
let ROOM_W = GAME_W;
const FLOOR_H = 40;
let GRID_COLS = Math.floor((ROOM_W - 16) / GRID_SIZE);
const GRID_ROWS = Math.floor((ROOM_H - FLOOR_H - 30) / GRID_SIZE);
let SNAP_COLS = GRID_COLS * 2; // snap grid columns
const SNAP_ROWS = GRID_ROWS * 2; // snap grid rows
const GRID_OFFSET_X = 8;
const GRID_OFFSET_Y = ROOM_Y + 30;

// Recalculate derived layout values when GAME_W changes
function recalcLayout() {
  ROOM_W = GAME_W;
  GRID_COLS = Math.floor((ROOM_W - 16) / GRID_SIZE);
  SNAP_COLS = GRID_COLS * 2;
  try { updateRoomBounds(); } catch(e) { /* ROOMS/mz/wac not yet declared */ }
}

let scale = 1, offsetX = 0, offsetY = 0;

function resizeCanvas() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const isMobile = w <= 600;
  const isLandscape = h <= 440 && w > h;
  const hudEl = document.getElementById('hud');

  if (isLandscape) {
    // Landscape: HUD is a fixed 36px + 2px border strip on the left
    const hudW = (hudEl && hudEl.style.display !== 'none') ? 44 : 0;
    const availW = w - hudW;
    // Expand GAME_W to match screen aspect ratio, capped at 640
    const idealW = Math.round(GAME_H * availW / h);
    const newW = Math.max(BASE_GAME_W, Math.min(640, idealW));
    if (newW !== GAME_W) { GAME_W = newW; recalcLayout(); }
    scale = Math.min(availW / GAME_W, h / GAME_H);
    canvas.style.width = (GAME_W * scale) + 'px';
    canvas.style.height = (GAME_H * scale) + 'px';
    canvas.style.marginLeft = '0px';
    canvas.style.marginTop = '0px';
    offsetX = hudW;
    offsetY = 0;
  } else {
    // Portrait / desktop: reset to base width
    if (GAME_W !== BASE_GAME_W) { GAME_W = BASE_GAME_W; recalcLayout(); }
    // Portrait / desktop: HUD on top
    const hudH = (isMobile && hudEl && hudEl.style.display !== 'none') ? hudEl.offsetHeight : 0;
    const availH = h - hudH;
    scale = Math.min(w / GAME_W, availH / GAME_H);
    canvas.style.width = (GAME_W * scale) + 'px';
    canvas.style.height = (GAME_H * scale) + 'px';
    offsetX = (w - GAME_W * scale) / 2;
    offsetY = isMobile ? 0 : (h - GAME_H * scale) / 2;
    canvas.style.marginLeft = offsetX + 'px';
    canvas.style.marginTop = isMobile ? '0px' : offsetY + 'px';
  }
  const dpr = window.devicePixelRatio || 1;
  canvas.width = GAME_W * dpr;
  canvas.height = GAME_H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function screenToGame(sx, sy) {
  const rect = canvas.getBoundingClientRect();
  return { x: (sx - rect.left) / scale, y: (sy - rect.top) / scale };
}
function gameToGrid(gx, gy) {
  // Snap to half-cell (SNAP_SIZE) for finer placement precision
  return {
    col: Math.floor((gx - GRID_OFFSET_X) / SNAP_SIZE) / 2,
    row: Math.floor((gy - GRID_OFFSET_Y) / SNAP_SIZE) / 2
  };
}
function gridToGame(col, row) {
  return { x: GRID_OFFSET_X + col * GRID_SIZE, y: GRID_OFFSET_Y + row * GRID_SIZE };
}

// ============================================================
// TOAST
// ============================================================
let toastTimeout;
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => el.classList.remove('show'), 3000);
}

// ============================================================
// SAVE / LOAD
// ============================================================
function saveGame() {
  try {
    state.lastActiveTime = Date.now();
    localStorage.setItem('mouseHouseSave', JSON.stringify({
      coins: state.coins, ownedItems: state.ownedItems,
      placedItems: state.placedItems, currentRoom: state.currentRoom,
      miceState: state.miceState, birthdayEventSeen: state.birthdayEventSeen,
      letterRead: state.letterRead, lootCrumbsUsed: state.lootCrumbsUsed,
      totalCoinsEarned: state.totalCoinsEarned, activeGoal: state.activeGoal,
      achievements: state.achievements, stats: state.stats,
      photos: state.photos, lastActiveTime: state.lastActiveTime
    }));
  } catch (e) {}
}

function loadGame() {
  try {
    const d = JSON.parse(localStorage.getItem('mouseHouseSave'));
    if (d) {
      state.coins = d.coins ?? CONFIG.startingCoins;
      state.ownedItems = d.ownedItems ?? [];
      state.placedItems = d.placedItems ?? [];
      // Initialize servings on food items loaded from old saves
      state.placedItems.forEach(p => {
        const item = FURNITURE.find(f => f.id === p.itemId);
        if (item && item.servings && p.servings === undefined) p.servings = item.servings;
      });
      // Remove stale food items with 0 servings (from interrupted saves)
      state.placedItems = state.placedItems.filter(p => {
        const item = FURNITURE.find(f => f.id === p.itemId);
        return !(item && item.servings && p.servings !== undefined && p.servings <= 0);
      });
      state.currentRoom = d.currentRoom ?? 0;
      state.birthdayEventSeen = d.birthdayEventSeen ?? false;
      state.letterRead = d.letterRead ?? false;
      state.lootCrumbsUsed = d.lootCrumbsUsed ?? 0;
      state.totalCoinsEarned = d.totalCoinsEarned ?? 0;
      state.activeGoal = d.activeGoal ?? null;
      state.achievements = d.achievements ?? [];
      if (d.stats) Object.assign(state.stats, d.stats);
      state.photos = d.photos ?? [];
      if (d.miceState) {
        Object.assign(state.miceState.pip, d.miceState.pip || d.miceState.shadow || {});
        Object.assign(state.miceState.chai, d.miceState.chai || d.miceState.cloud || {});
        // Clear transient furniture state (not persisted across sessions)
        ['pip', 'chai'].forEach(k => {
          state.miceState[k].onFurniture = null;
          state.miceState[k].pendingFurniture = null;
        });
      }
      // Welcome back detection
      state.lastActiveTime = d.lastActiveTime ?? 0;
      if (state.lastActiveTime && Date.now() - state.lastActiveTime > 120000) {
        state._welcomeBack = true;
        state._absenceMinutes = Math.floor((Date.now() - state.lastActiveTime) / 60000);
      }
    }
  } catch (e) {}
}

function closeModal() { document.getElementById('modal-container').innerHTML = ''; }

function updateCoinDisplay() {
  document.getElementById('coin-display').textContent = state.coins;
  const flyoutCoins = document.getElementById('flyout-coin-display');
  if (flyoutCoins) flyoutCoins.textContent = state.coins;
}

// ============================================================
// ROOM TABS
// ============================================================
const ROOMS = [
  {
    name: 'Bedroom', icon: 'üõè',
    wallTop: '#5c4a6e', wallBot: '#4a3a5c', floor: '#6b5a50', floorAlt: '#5e4e44',
    baseboard: '#7a6a5a', ceiling: '#6e5a80', accent: '#8a70a0',
    windowNight: '#1a1a3e', windowGlow: '#2a2a5e', shelfColor: '#7a6a5a',
    // Window: left side to avoid loft on right
    window: { x: 60, y: ROOM_Y + 14, w: 58, h: 50 },
    // Shelves: left side only (right has the loft platform)
    shelves: [{ x: 20, y: ROOM_Y + 90, w: 70 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'loft', y: 175, xMin: 220, xMax: 460 }
    ],
    ramps: [
      { from: 'main-floor', to: 'loft', x1: 200, x2: 235, style: 'ladder' }
    ]
  },
  {
    name: 'Kitchen', icon: 'üç≥',
    wallTop: '#4a6e5a', wallBot: '#3a5c4a', floor: '#6b6050', floorAlt: '#5e5444',
    baseboard: '#7a6a5a', ceiling: '#5a8068', accent: '#70a08a',
    windowNight: '#1a2e1a', windowGlow: '#2a4e2a', shelfColor: '#8a7a60',
    // Window: right side, above counter area is clear
    window: { x: 340, y: ROOM_Y + 12, w: 72, h: 52 },
    // Shelves: right side only (left has counter platform)
    shelves: [{ x: ROOM_W - 110, y: ROOM_Y + 100, w: 80 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'counter', y: 190, xMin: 20, xMax: 230 }
    ],
    ramps: [
      { from: 'main-floor', to: 'counter', x1: 230, x2: 265, style: 'ramp' }
    ]
  },
  {
    name: 'Living Room', icon: 'üõã',
    wallTop: '#6e5a4a', wallBot: '#5c4a3a', floor: '#6b5a48', floorAlt: '#5e4e3e',
    baseboard: '#7a6a5a', ceiling: '#806a50', accent: '#a08a60',
    windowNight: '#2e1a1a', windowGlow: '#4e2a2a', shelfColor: '#7a6a50',
    // Window: centered-left, wide and short
    window: { x: 40, y: ROOM_Y + 18, w: 80, h: 44 },
    // Shelves: far right (box-shelf is center-left)
    shelves: [{ x: ROOM_W - 95, y: ROOM_Y + 85, w: 65 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'box-shelf', y: 195, xMin: 140, xMax: 350 }
    ],
    ramps: [
      { from: 'main-floor', to: 'box-shelf', x1: 120, x2: 155, style: 'ramp' }
    ]
  },
  {
    name: 'Exercise Room', icon: 'üèÉ',
    wallTop: '#4a5a6e', wallBot: '#3a4a5c', floor: '#5a6050', floorAlt: '#4e5444',
    baseboard: '#6a7a8a', ceiling: '#5a6a80', accent: '#6080a0',
    windowNight: '#1a1a2e', windowGlow: '#2a2a4e', shelfColor: '#6a7a8a',
    // Window: left side, tall narrow (gym-style)
    window: { x: 50, y: ROOM_Y + 10, w: 50, h: 60 },
    // Shelves: left side (perch is on the right)
    shelves: [{ x: 130, y: ROOM_Y + 95, w: 75 }, { x: 20, y: ROOM_Y + 130, w: 55 }],
    platforms: [
      { id: 'main-floor', y: 260, xMin: 10, xMax: 470 },
      { id: 'perch', y: 185, xMin: 340, xMax: 460 }
    ],
    ramps: [
      { from: 'main-floor', to: 'perch', x1: 318, x2: 350, style: 'ladder' }
    ]
  }
];

// Update room bounds when GAME_W changes (wider canvas in landscape)
// Right-edge-relative elements shift; left-anchored elements stay put.
function updateRoomBounds() {
  const W = GAME_W;
  // Bedroom (room 0) ‚Äî loft right-anchored, widens naturally
  ROOMS[0].platforms[0].xMax = W - 10;   // main-floor
  ROOMS[0].platforms[1].xMax = W - 20;   // loft
  // Extra shelf on wider rooms for visual balance
  ROOMS[0].shelves = W > 500
    ? [{ x: 20, y: ROOM_Y + 90, w: 70 }, { x: 140, y: ROOM_Y + 120, w: 55 }]
    : [{ x: 20, y: ROOM_Y + 90, w: 70 }];
  // Kitchen (room 1) ‚Äî counter scales proportionally, window right-anchored
  ROOMS[1].platforms[0].xMax = W - 10;   // main-floor
  ROOMS[1].platforms[1].xMax = Math.min(300, Math.round(W * 0.45)); // counter
  ROOMS[1].ramps[0].x1 = ROOMS[1].platforms[1].xMax;               // ramp follows counter
  ROOMS[1].ramps[0].x2 = ROOMS[1].platforms[1].xMax + 35;
  ROOMS[1].window = { x: W - 140, y: ROOM_Y + 12, w: 72, h: 52 };
  ROOMS[1].shelves = W > 500
    ? [{ x: W - 110, y: ROOM_Y + 100, w: 80 }, { x: Math.round(W * 0.4), y: ROOM_Y + 80, w: 60 }]
    : [{ x: W - 110, y: ROOM_Y + 100, w: 80 }];
  // Living Room (room 2) ‚Äî box-shelf scales proportionally, stays centered
  ROOMS[2].platforms[0].xMax = W - 10;   // main-floor
  ROOMS[2].platforms[1].xMin = Math.round(W * 0.25);  // box-shelf
  ROOMS[2].platforms[1].xMax = Math.round(W * 0.6);   // box-shelf
  ROOMS[2].ramps[0].x1 = ROOMS[2].platforms[1].xMin - 20; // ramp to box-shelf
  ROOMS[2].ramps[0].x2 = ROOMS[2].platforms[1].xMin + 15;
  ROOMS[2].shelves = W > 500
    ? [{ x: W - 95, y: ROOM_Y + 85, w: 65 }, { x: 20, y: ROOM_Y + 110, w: 60 }]
    : [{ x: W - 95, y: ROOM_Y + 85, w: 65 }];
  // Exercise Room (room 3) ‚Äî perch right-anchored, widens for more space
  ROOMS[3].platforms[0].xMax = W - 10;   // main-floor
  ROOMS[3].platforms[1].xMin = W - 160;  // perch (wider than before: was W-140)
  ROOMS[3].platforms[1].xMax = W - 20;   // perch
  ROOMS[3].ramps[0].x1 = W - 182;       // ladder to perch
  ROOMS[3].ramps[0].x2 = W - 150;
  ROOMS[3].shelves = W > 500
    ? [{ x: 130, y: ROOM_Y + 95, w: 75 }, { x: 20, y: ROOM_Y + 130, w: 55 }, { x: Math.round(W * 0.4), y: ROOM_Y + 110, w: 60 }]
    : [{ x: 130, y: ROOM_Y + 95, w: 75 }, { x: 20, y: ROOM_Y + 130, w: 55 }];
  // Re-center exercise wheel on current grid
  try {
    if (state && state.placedItems) {
      const wheel = state.placedItems.find(p => p.itemId === 'exercise-wheel');
      if (wheel) wheel.gridX = Math.floor(GRID_COLS / 2) - 1;
    }
  } catch(e) {}
  // Update mini-game offsets if active
  try {
    if (mz && mz.cols) mz.ox = Math.floor((W - mz.cols * mz.cellSize) / 2);
    if (wac && wac.holes) {
      const gapX = W / 4;
      wac.holes.forEach((h, i) => { h.x = gapX * ((i % 3) + 1); });
    }
  } catch(e) {}
}

// Apply room bounds for current GAME_W (handles landscape load)
updateRoomBounds();

// Ring layout helpers: rooms connect in a circle 0‚Üî1‚Üî2‚Üî3‚Üî0
function roomLeft(i)  { return (i - 1 + ROOMS.length) % ROOMS.length; }
function roomRight(i) { return (i + 1) % ROOMS.length; }
// Shortest ring direction from 'from' to 'to': -1 = left, +1 = right, 0 = same
function ringDirection(from, to) {
  if (from === to) return 0;
  const n = ROOMS.length;
  const rightDist = (to - from + n) % n;
  const leftDist  = (from - to + n) % n;
  return rightDist <= leftDist ? 1 : -1;
}
// Next room one step toward 'to' on the ring
function ringStepToward(from, to) {
  const dir = ringDirection(from, to);
  if (dir === 0) return from;
  return dir > 0 ? roomRight(from) : roomLeft(from);
}

// Determine which platform a placed furniture item is on
function getFurniturePlatform(roomIdx, placed) {
  const room = ROOMS[roomIdx];
  if (!room || !room.platforms || room.platforms.length <= 1) return 'main-floor';
  const itemDef = FURNITURE.find(f => f.id === placed.itemId);
  if (!itemDef) return 'main-floor';
  // Wall-mounts attach at top; regular items sit on bottom
  const refY = itemDef.wallMount
    ? GRID_OFFSET_Y + placed.gridY * GRID_SIZE
    : GRID_OFFSET_Y + placed.gridY * GRID_SIZE + itemDef.h * GRID_SIZE;
  let best = room.platforms[0];
  let bestDist = Math.abs(refY - best.y);
  for (const plat of room.platforms) {
    const d = Math.abs(refY - plat.y);
    if (d < bestDist) { best = plat; bestDist = d; }
  }
  return best.id;
}

function buildRoomTabs() {
  const tabsHTML =
    ROOMS.map((r, i) =>
      `<button class="${i === state.currentRoom ? 'active' : ''}" onclick="switchRoom(${i})">${r.icon}</button>`
    ).join('');
  document.getElementById('room-tabs').innerHTML = tabsHTML;
  const mobile = document.getElementById('room-tabs-mobile');
  if (mobile) mobile.innerHTML = tabsHTML;
}
// Room slide transition state
let roomTransition = { active: false, from: 0, to: 0, dir: 0, progress: 0, duration: 300 };

function switchRoom(i) {
  if (i === state.currentRoom) return;
  if (roomTransition.active) return; // ignore during animation
  const prevRoom = state.currentRoom;
  // Determine slide direction on the ring
  const dir = ringDirection(prevRoom, i);
  // Start slide animation
  roomTransition = { active: true, from: prevRoom, to: i, dir, progress: 0, duration: 300 };
  state.currentRoom = i;
  buildRoomTabs();
  saveGame();

  // "Caught in the act" ‚Äî if a mouse is alone in this room doing mischief/grooming/eating
  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    if (mouse.room !== i) return;
    const otherKey = key === 'pip' ? 'chai' : 'pip';
    const other = state.miceState[otherKey];
    const isAlone = other.room !== i;
    const caughtActions = ['mischief', 'eating', 'grooming', 'doomscrolling', 'hiding', 'chewing', 'swinging'];
    if (isAlone && caughtActions.includes(mouse.action) && Math.random() < 0.5) {
      // Freeze and look guilty
      const prevAction = mouse.action;
      mouse.action = 'idle';
      mouse.actionTimer = 2000;
      mouse._startled = true;
      mouse._startleTimer = 800;
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== key);
      const caughtQuotes = prevAction === 'mischief'
        ? ['...wasn\'t doing anything üòÖ', 'this isn\'t what it looks like', 'I was just... inspecting', 'you saw nothing üôà']
        : prevAction === 'doomscrolling'
        ? ['I wasn\'t on my phone!', '*closes 47 tabs*', 'just checking the weather üòÖ']
        : ['totally normal behavior', 'how long were you watching üëÄ', 'oh hi! üò≥'];
      speechBubbles.push({
        x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: caughtQuotes[Math.floor(Math.random() * caughtQuotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey: key
      });
    }
  });
}

// Draw a room and its mice at a given x-offset (used for slide transitions)
function drawRoomScene(roomIndex, offsetX) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(Math.max(0, offsetX), 0, GAME_W, GAME_H);
  ctx.clip();
  ctx.translate(offsetX, 0);
  drawRoom(roomIndex);
  // Draw mice in this room
  const pip = state.miceState.pip;
  const chai = state.miceState.chai;
  if (pip.room === roomIndex && pip.action !== 'wheeling' && !pip.onFurniture) {
    const fy = getMouseFloorY(pip);
    if (pip.action === 'flung') drawFlungMouse(pip, CONFIG.mice.pip);
    else drawMouse(pip.x, fy, CONFIG.mice.pip, pip.dir, pip.frame, pip.action, pip._startled, pip);
    drawPartyHat(pip.action === 'flung' ? pip.flingX : pip.x,
                 pip.action === 'flung' ? pip.flingY : fy, pip.action, pip.dir, CONFIG.mice.pip, roomIndex);
  }
  if (chai.room === roomIndex && chai.action !== 'wheeling' && !chai.onFurniture) {
    const fy = getMouseFloorY(chai);
    if (chai.action === 'flung') drawFlungMouse(chai, CONFIG.mice.chai);
    else drawMouse(chai.x, fy, CONFIG.mice.chai, chai.dir, chai.frame, chai.action, chai._startled, chai);
    drawPartyHat(chai.action === 'flung' ? chai.flingX : chai.x,
                 chai.action === 'flung' ? chai.flingY : fy, chai.action, chai.dir, CONFIG.mice.chai, roomIndex);
  }
  ctx.restore();
}

// ============================================================
// PARTICLES (dust motes, floating in rooms)
// ============================================================
let particles = [];
function initParticles() {
  for (let i = 0; i < 25; i++) {
    particles.push({
      x: Math.random() * GAME_W,
      y: ROOM_Y + Math.random() * ROOM_H,
      size: 0.8 + Math.random() * 1.5,
      speedX: (Math.random() - 0.5) * 0.12,
      speedY: -0.04 - Math.random() * 0.08,
      alpha: 0.12 + Math.random() * 0.18,
      phase: Math.random() * Math.PI * 2, // for sine drift
      sizePhase: Math.random() * Math.PI * 2 // for size pulsing
    });
  }
}
function updateParticles(dt) {
  const t = Date.now() / 1000;
  particles.forEach(p => {
    p.x += (p.speedX + Math.sin(t * 0.7 + p.phase) * 0.04) * dt * 0.06;
    p.y += p.speedY * dt * 0.06;
    if (p.y < ROOM_Y) { p.y = ROOM_Y + ROOM_H; p.x = Math.random() * GAME_W; }
    if (p.x < 0) p.x = GAME_W;
    if (p.x > GAME_W) p.x = 0;
  });
}
function drawParticles() {
  const t = Date.now() / 1000;
  particles.forEach(p => {
    const pulsedSize = p.size + Math.sin(t * 1.5 + p.sizePhase) * 0.3;
    // Glow brighter near window light (check if in light cone area)
    const room = ROOMS[state.currentRoom];
    const win = room.window || { x: GAME_W / 2 - 34, y: ROOM_Y + 16, w: 68, h: 56 };
    const distToLight = Math.abs(p.x - (win.x + win.w / 2)) / GAME_W;
    const glowBoost = Math.max(0, 1 - distToLight * 3) * 0.15;
    const alpha = Math.min(0.45, p.alpha + glowBoost);
    // Radial gradient for luminous look
    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, pulsedSize * 2);
    grad.addColorStop(0, `rgba(255, 245, 220, ${alpha})`);
    grad.addColorStop(1, `rgba(255, 240, 210, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(p.x, p.y, pulsedSize * 2, 0, Math.PI * 2);
    ctx.fill();
  });
}

// ============================================================
// ROOM RENDERING
// ============================================================
function drawRoom(roomIndex) {
  const room = ROOMS[roomIndex];
  const t = Date.now() / 1000;

  // -- Top bar --
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, ROOM_Y);

  // -- Wall gradient (top to bottom) --
  const wallGrad = ctx.createLinearGradient(0, ROOM_Y, 0, ROOM_Y + ROOM_H - FLOOR_H);
  wallGrad.addColorStop(0, room.wallTop);
  wallGrad.addColorStop(1, room.wallBot);
  ctx.fillStyle = wallGrad;
  ctx.fillRect(0, ROOM_Y, ROOM_W, ROOM_H - FLOOR_H);

  // -- Subtle wall texture (soft horizontal lines) --
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  for (let y = ROOM_Y + 8; y < ROOM_Y + ROOM_H - FLOOR_H; y += 12) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(ROOM_W, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1.0;

  // -- Wall stipple texture (scattered tiny dots for grain) --
  ctx.fillStyle = 'rgba(0,0,0,0.03)';
  for (let i = 0; i < 60; i++) {
    // Deterministic positions based on room index for consistency
    const sx = ((i * 137 + roomIndex * 53) % 467) / 467 * ROOM_W;
    const sy = ROOM_Y + ((i * 89 + roomIndex * 31) % 239) / 239 * (ROOM_H - FLOOR_H);
    ctx.fillRect(sx, sy, 1, 1);
  }

  // -- Corner vignettes (darken edges for depth) --
  const vigL = ctx.createLinearGradient(0, 0, 60, 0);
  vigL.addColorStop(0, 'rgba(0,0,0,0.12)');
  vigL.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = vigL;
  ctx.fillRect(0, ROOM_Y, 60, ROOM_H - FLOOR_H);
  const vigR = ctx.createLinearGradient(ROOM_W, 0, ROOM_W - 60, 0);
  vigR.addColorStop(0, 'rgba(0,0,0,0.12)');
  vigR.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = vigR;
  ctx.fillRect(ROOM_W - 60, ROOM_Y, 60, ROOM_H - FLOOR_H);
  // Top corner darkening
  const vigT = ctx.createLinearGradient(0, ROOM_Y, 0, ROOM_Y + 40);
  vigT.addColorStop(0, 'rgba(0,0,0,0.08)');
  vigT.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = vigT;
  ctx.fillRect(0, ROOM_Y, ROOM_W, 40);

  // -- Window with night sky ‚Äî parallax layers --
  const win = room.window || { x: GAME_W / 2 - 34, y: ROOM_Y + 16, w: 68, h: 56 };
  const winX = win.x;
  const winY = win.y;
  const winW = win.w, winH = win.h;
  // Window recess shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(winX - 3, winY - 3, winW + 6, winH + 6);
  // Night sky base
  ctx.fillStyle = room.windowNight;
  ctx.fillRect(winX, winY, winW, winH);

  // Parallax offset based on average mouse position
  const pipInRoom = state.miceState.pip.room === roomIndex;
  const chaiInRoom = state.miceState.chai.room === roomIndex;
  let avgMX = GAME_W / 2;
  if (pipInRoom && chaiInRoom) avgMX = (state.miceState.pip.x + state.miceState.chai.x) / 2;
  else if (pipInRoom) avgMX = state.miceState.pip.x;
  else if (chaiInRoom) avgMX = state.miceState.chai.x;
  const pxOffset = (avgMX / GAME_W - 0.5) * 6; // ¬±3px shift

  // Clip to window frame for parallax content
  ctx.save();
  ctx.beginPath();
  ctx.rect(winX, winY, winW, winH);
  ctx.clip();

  // Layer 1: Distant stars (slow parallax 0.2x)
  const distStars = [
    [0.08,0.12],[0.18,0.55],[0.32,0.08],[0.42,0.38],[0.55,0.22],[0.68,0.62],
    [0.78,0.15],[0.88,0.45],[0.95,0.28],[0.12,0.72],[0.62,0.82],[0.38,0.68],
    [0.25,0.3],[0.72,0.4],[0.48,0.55],[0.85,0.7]
  ];
  distStars.forEach(([sx, sy], i) => {
    const twinkle = 0.3 + 0.5 * Math.abs(Math.sin(t * 0.8 + i * 2.3));
    ctx.globalAlpha = twinkle;
    ctx.fillStyle = i % 5 === 0 ? '#ffe8b0' : '#fffde0';
    const sz = i % 4 === 0 ? 1.5 : 0.8;
    ctx.beginPath();
    ctx.arc(winX + sx * winW + pxOffset * 0.2, winY + sy * winH, sz, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1.0;

  // Layer 2: Skyline silhouette (medium parallax 0.5x)
  ctx.fillStyle = 'rgba(15,10,30,0.6)';
  const skyY = winY + winH * 0.65;
  const skyOff = pxOffset * 0.5;
  ctx.beginPath();
  ctx.moveTo(winX - 5 + skyOff, winY + winH);
  // Varied building shapes
  const bldgs = [0, 0.12, 0.2, 0.28, 0.38, 0.48, 0.55, 0.65, 0.75, 0.85, 0.95, 1.05];
  const bHts =  [8, 18,   12,  22,   10,   26,   14,   20,   8,    16,   12,   6];
  bldgs.forEach((bx, i) => {
    const x = winX + bx * winW + skyOff;
    ctx.lineTo(x, skyY - bHts[i]);
    ctx.lineTo(x + winW * 0.06, skyY - bHts[i]);
  });
  ctx.lineTo(winX + winW + 5 + skyOff, winY + winH);
  ctx.closePath();
  ctx.fill();
  // Tiny lit windows in buildings
  ctx.fillStyle = 'rgba(255,220,100,0.4)';
  bldgs.forEach((bx, i) => {
    if (bHts[i] > 14 && Math.sin(t * 0.3 + i) > -0.3) {
      const x = winX + bx * winW + skyOff + winW * 0.015;
      ctx.fillRect(x, skyY - bHts[i] + 4, 2, 2);
      if (bHts[i] > 18) ctx.fillRect(x + 4, skyY - bHts[i] + 8, 2, 2);
    }
  });

  // Layer 3: Moon and close stars (full parallax 1x ‚Äî existing)
  // Moon glow
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = room.windowGlow;
  ctx.beginPath();
  ctx.arc(winX + winW - 14 + pxOffset, winY + 14, 18, 0, Math.PI * 2);
  ctx.fill();
  // Moon
  ctx.fillStyle = '#eee8d0';
  ctx.beginPath();
  ctx.arc(winX + winW - 14 + pxOffset, winY + 14, 7, 0, Math.PI * 2);
  ctx.fill();
  // Moon crescent shadow
  ctx.fillStyle = room.windowNight;
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.arc(winX + winW - 12 + pxOffset, winY + 13, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1.0;

  // Close twinkling stars
  const closeStars = [
    [0.15, 0.2], [0.3, 0.45], [0.5, 0.12], [0.7, 0.35], [0.85, 0.25],
    [0.25, 0.32], [0.6, 0.52]
  ];
  closeStars.forEach(([sx, sy], i) => {
    const twinkle = 0.5 + 0.5 * Math.abs(Math.sin(t * 1.8 + i * 1.7));
    ctx.globalAlpha = twinkle;
    ctx.fillStyle = '#fffde0';
    const sz = i % 3 === 0 ? 2 : 1.2;
    ctx.beginPath();
    ctx.arc(winX + sx * winW + pxOffset, winY + sy * winH, sz, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1.0;

  ctx.restore(); // end window clip
  // Window panes (cross)
  ctx.strokeStyle = '#8a7a60';
  ctx.lineWidth = 3;
  ctx.strokeRect(winX, winY, winW, winH);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(winX + winW / 2, winY);
  ctx.lineTo(winX + winW / 2, winY + winH);
  ctx.moveTo(winX, winY + winH / 2);
  ctx.lineTo(winX + winW, winY + winH / 2);
  ctx.stroke();
  // Window sill
  ctx.fillStyle = '#8a7a60';
  ctx.fillRect(winX - 6, winY + winH, winW + 12, 5);
  // Tiny curtains
  ctx.fillStyle = room.accent;
  ctx.globalAlpha = 0.4;
  ctx.fillRect(winX - 2, winY, 8, winH);
  ctx.fillRect(winX + winW - 6, winY, 8, winH);
  ctx.globalAlpha = 1.0;

  // -- Moonlight cone (light spilling from window onto floor) --
  const floorY = ROOM_Y + ROOM_H - FLOOR_H;
  const lightCenterX = winX + winW / 2;
  const coneSpread = winW * 0.8;
  const moonGrad = ctx.createLinearGradient(0, winY + winH, 0, floorY);
  moonGrad.addColorStop(0, 'rgba(180,200,255,0.06)');
  moonGrad.addColorStop(0.6, 'rgba(180,200,255,0.03)');
  moonGrad.addColorStop(1, 'rgba(180,200,255,0)');
  ctx.fillStyle = moonGrad;
  ctx.beginPath();
  ctx.moveTo(winX, winY + winH);
  ctx.lineTo(lightCenterX - coneSpread, floorY);
  ctx.lineTo(lightCenterX + coneSpread, floorY);
  ctx.lineTo(winX + winW, winY + winH);
  ctx.closePath();
  ctx.fill();
  // Floor light patch
  ctx.fillStyle = 'rgba(180,200,255,0.025)';
  ctx.beginPath();
  ctx.ellipse(lightCenterX, floorY + 4, coneSpread * 0.7, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // -- Wall shelves (per-room positions) --
  const shelves = room.shelves || [
    { x: 20, y: ROOM_Y + ROOM_H - FLOOR_H - 80, w: 80 },
    { x: ROOM_W - 100, y: ROOM_Y + ROOM_H - FLOOR_H - 80, w: 80 }
  ];
  shelves.forEach(shelf => {
    ctx.fillStyle = room.shelfColor;
    ctx.fillRect(shelf.x, shelf.y, shelf.w, 4);
    // Shelf brackets
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(shelf.x + 10, shelf.y + 4, 3, 10);
    ctx.fillRect(shelf.x + shelf.w - 13, shelf.y + 4, 3, 10);
  });

  // -- Warm light glow from above (ambient lamp effect) --
  const lampGrad = ctx.createRadialGradient(GAME_W / 2, ROOM_Y + 4, 10, GAME_W / 2, ROOM_Y + 60, 200);
  lampGrad.addColorStop(0, 'rgba(255, 220, 150, 0.08)');
  lampGrad.addColorStop(1, 'rgba(255, 220, 150, 0)');
  ctx.fillStyle = lampGrad;
  ctx.fillRect(0, ROOM_Y, GAME_W, ROOM_H - FLOOR_H);

  // -- Baseboard --
  ctx.fillStyle = room.baseboard;
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H - 5, ROOM_W, 5);
  // Baseboard shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H - 6, ROOM_W, 1);

  // -- Floor --
  ctx.fillStyle = room.floor;
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H, ROOM_W, FLOOR_H);
  // Floor boards
  ctx.strokeStyle = room.floorAlt;
  ctx.lineWidth = 1;
  for (let fx = 0; fx < ROOM_W; fx += 36) {
    ctx.beginPath();
    ctx.moveTo(fx, ROOM_Y + ROOM_H - FLOOR_H);
    ctx.lineTo(fx, ROOM_Y + ROOM_H);
    ctx.stroke();
  }
  // Floor highlight
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(0, ROOM_Y + ROOM_H - FLOOR_H, ROOM_W, 2);

  // -- Ceiling trim --
  ctx.fillStyle = room.ceiling;
  ctx.fillRect(0, ROOM_Y, ROOM_W, 5);
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(0, ROOM_Y + 5, ROOM_W, 1);

  // -- Dollhouse frame edges (left & right walls) --
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(0, ROOM_Y, 4, ROOM_H);
  ctx.fillRect(ROOM_W - 4, ROOM_Y, 4, ROOM_H);
  // Inner wall shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(4, ROOM_Y, 6, ROOM_H);
  ctx.fillRect(ROOM_W - 10, ROOM_Y, 6, ROOM_H);

  // -- Dust particles --
  drawParticles();

  // -- Platforms & Ramps --
  if (room.platforms) {
    room.platforms.forEach(plat => {
      if (plat.id === 'main-floor') return; // main floor already drawn
      const pw = plat.xMax - plat.xMin;

      // Darkened wall behind platform (alcove depth effect)
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fillRect(plat.xMin, plat.y - 30, pw, 30);

      // Platform shadow
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fillRect(plat.xMin + 2, plat.y + 6, pw, 4);

      // Platform surface (wooden plank)
      const platGrad = ctx.createLinearGradient(0, plat.y, 0, plat.y + 6);
      platGrad.addColorStop(0, room.shelfColor);
      platGrad.addColorStop(1, room.baseboard);
      ctx.fillStyle = platGrad;
      ctx.fillRect(plat.xMin, plat.y, pw, 6);

      // Plank lines
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 0.5;
      for (let px = plat.xMin + 30; px < plat.xMax; px += 30) {
        ctx.beginPath();
        ctx.moveTo(px, plat.y);
        ctx.lineTo(px, plat.y + 6);
        ctx.stroke();
      }

      // Top highlight
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(plat.xMin, plat.y, pw, 1);

      // Bottom edge shadow
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(plat.xMin, plat.y + 5, pw, 1);

      // Support brackets
      const bracketW = 4;
      const bracketH = 14;
      const bracketColor = room.baseboard;
      const bracketPositions = [plat.xMin + 10, plat.xMax - 14];
      if (pw > 150) bracketPositions.push(plat.xMin + Math.floor(pw / 2));
      bracketPositions.forEach(bx => {
        // Vertical bracket
        ctx.fillStyle = bracketColor;
        ctx.fillRect(bx, plat.y + 6, bracketW, bracketH);
        // Diagonal brace
        ctx.strokeStyle = bracketColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bx + bracketW, plat.y + 6);
        ctx.lineTo(bx + bracketW + 8, plat.y + 6 + bracketH);
        ctx.stroke();
      });
    });

    // Draw ramps
    if (room.ramps) {
      room.ramps.forEach(ramp => {
        const fromPlat = room.platforms.find(p => p.id === ramp.from);
        const toPlat = room.platforms.find(p => p.id === ramp.to);
        if (!fromPlat || !toPlat) return;

        const y1 = fromPlat.y;
        const y2 = toPlat.y;
        const rampW = ramp.x2 - ramp.x1;

        if (ramp.style === 'ladder') {
          // Ladder: two rails with rungs
          const railL = ramp.x1 + 2;
          const railR = ramp.x1 + rampW - 2;
          const railColor = '#8a7a60';

          // Rails
          ctx.strokeStyle = railColor;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(railL, y1); ctx.lineTo(railL, y2 + 6);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(railR, y1); ctx.lineTo(railR, y2 + 6);
          ctx.stroke();

          // Rungs
          const numRungs = Math.floor(Math.abs(y1 - y2) / 14);
          ctx.strokeStyle = '#9a8a70';
          ctx.lineWidth = 2;
          for (let i = 1; i <= numRungs; i++) {
            const ry = y2 + 6 + (i / (numRungs + 1)) * (y1 - y2 - 6);
            ctx.beginPath();
            ctx.moveTo(railL + 1, ry);
            ctx.lineTo(railR - 1, ry);
            ctx.stroke();
          }

          // Rail highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(railL + 1, y1); ctx.lineTo(railL + 1, y2 + 6);
          ctx.stroke();
        } else {
          // Ramp: angled plank
          ctx.save();

          // Ramp shadow
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.beginPath();
          ctx.moveTo(ramp.x1 + 2, y1 + 2);
          ctx.lineTo(ramp.x2 + 2, y2 + 8);
          ctx.lineTo(ramp.x2 + 2, y2 + 14);
          ctx.lineTo(ramp.x1 + 2, y1 + 8);
          ctx.closePath();
          ctx.fill();

          // Ramp surface
          const rampGrad = ctx.createLinearGradient(ramp.x1, y1, ramp.x2, y2);
          rampGrad.addColorStop(0, room.shelfColor);
          rampGrad.addColorStop(1, room.baseboard);
          ctx.fillStyle = rampGrad;
          ctx.beginPath();
          ctx.moveTo(ramp.x1, y1);
          ctx.lineTo(ramp.x2, y2 + 6);
          ctx.lineTo(ramp.x2, y2 + 12);
          ctx.lineTo(ramp.x1, y1 + 6);
          ctx.closePath();
          ctx.fill();

          // Cross-grip lines on ramp
          ctx.strokeStyle = 'rgba(0,0,0,0.12)';
          ctx.lineWidth = 1;
          const steps = Math.floor(rampW / 8);
          for (let i = 1; i < steps; i++) {
            const frac = i / steps;
            const rx = ramp.x1 + frac * rampW;
            const ry = y1 + frac * (y2 + 6 - y1);
            ctx.beginPath();
            ctx.moveTo(rx, ry);
            ctx.lineTo(rx, ry + 6);
            ctx.stroke();
          }

          // Top edge highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.12)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(ramp.x1, y1);
          ctx.lineTo(ramp.x2, y2 + 6);
          ctx.stroke();

          ctx.restore();
        }
      });
    }
  }

  // -- Draw micro-event bug --
  drawMicroEventBug(roomIndex);

  // -- Draw placed furniture for this room --
  const roomItems = state.placedItems.filter(p => p.room === roomIndex);
  roomItems.forEach(placed => {
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (!item) return;

    // Furniture shadow (before drawing item)
    const fpos = gridToGame(placed.gridX, placed.gridY);
    const fw = item.w * GRID_SIZE;
    const fh = item.h * GRID_SIZE;
    if (!item.wallMount) {
      // Shadow offset slightly toward window light source
      const shadowOff = (fpos.x < winX + winW / 2) ? 3 : -3;
      ctx.fillStyle = 'rgba(0,0,0,0.07)';
      ctx.beginPath();
      ctx.ellipse(fpos.x + fw / 2 + shadowOff, fpos.y + fh + 1, fw / 2 + 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw the item
    if (item.id === 'exercise-wheel') {
      drawExerciseWheel(placed);
    } else {
      drawFurnitureItem(item, placed.gridX, placed.gridY, placed);
    }

    // Ambient glow for light-emitting furniture
    if (item.id === 'fairy-lights') {
      // Warm twinkling glow along the item width
      for (let li = 0; li < 5; li++) {
        const lx = fpos.x + (li + 0.5) * fw / 5;
        const ly = fpos.y + fh / 2;
        const flicker = 0.4 + 0.6 * Math.abs(Math.sin(t * 3 + li * 1.4));
        const glow = ctx.createRadialGradient(lx, ly, 0, lx, ly, 14);
        glow.addColorStop(0, `rgba(255, 210, 80, ${0.08 * flicker})`);
        glow.addColorStop(1, 'rgba(255, 210, 80, 0)');
        ctx.fillStyle = glow;
        ctx.fillRect(lx - 14, ly - 14, 28, 28);
      }
    } else if (item.id === 'ring-light') {
      const glow = ctx.createRadialGradient(fpos.x + fw / 2, fpos.y + fh / 2, 2, fpos.x + fw / 2, fpos.y + fh / 2, 20);
      glow.addColorStop(0, 'rgba(255, 250, 240, 0.1)');
      glow.addColorStop(1, 'rgba(255, 250, 240, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(fpos.x - 8, fpos.y - 8, fw + 16, fh + 16);
    } else if (item.id === 'eraser-tv') {
      const tvFlicker = 0.5 + 0.5 * Math.sin(t * 8 + Math.sin(t * 3) * 2);
      const glow = ctx.createRadialGradient(fpos.x + fw / 2, fpos.y + fh / 2, 1, fpos.x + fw / 2, fpos.y + fh / 2, 18);
      glow.addColorStop(0, `rgba(100, 180, 255, ${0.06 * tvFlicker})`);
      glow.addColorStop(1, 'rgba(100, 180, 255, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(fpos.x - 8, fpos.y - 8, fw + 16, fh + 16);
    } else if (item.id === 'tiny-laptop') {
      const glow = ctx.createRadialGradient(fpos.x + fw / 2, fpos.y + 2, 1, fpos.x + fw / 2, fpos.y + 2, 14);
      glow.addColorStop(0, 'rgba(120, 200, 255, 0.06)');
      glow.addColorStop(1, 'rgba(120, 200, 255, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(fpos.x - 6, fpos.y - 6, fw + 12, fh + 12);
    } else if (item.id === 'disco-ball') {
      // Rotating sparkle beams
      for (let bi = 0; bi < 4; bi++) {
        const angle = t * 1.5 + bi * Math.PI / 2;
        const bx = fpos.x + fw / 2 + Math.cos(angle) * 20;
        const by = fpos.y + fh / 2 + Math.sin(angle) * 15;
        ctx.fillStyle = `rgba(255,255,255,${0.04 + 0.03 * Math.sin(t * 4 + bi)})`;
        ctx.beginPath();
        ctx.arc(bx, by, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  });

  // -- Grid overlay in placement/drag mode --
  if (state.placementMode || state.removeMode || state.dragState.active) {
    ctx.strokeStyle = 'rgba(245,214,138,0.12)';
    ctx.lineWidth = 0.5;
    for (let r = 0; r < SNAP_ROWS; r++) {
      for (let c = 0; c < SNAP_COLS; c++) {
        const pos = gridToGame(c / 2, r / 2);
        ctx.strokeRect(pos.x, pos.y, SNAP_SIZE, SNAP_SIZE);
      }
    }
  }

  // -- Drag ghost preview --
  if (state.dragState.active) {
    const ds = state.dragState;
    const dragItem = FURNITURE.find(f => f.id === ds.itemId);
    if (dragItem) {
      const gPos = screenToGame(ds.screenX, ds.screenY + dragOffsetY());
      // Center the item on cursor
      const centerOffX = (dragItem.w * GRID_SIZE) / 2;
      const centerOffY = (dragItem.h * GRID_SIZE) / 2;
      const grid = gameToGrid(gPos.x - centerOffX + SNAP_SIZE / 2, gPos.y - centerOffY + SNAP_SIZE / 2);
      const excludeIdx = ds.fromPlaced ? ds.fromPlacedIdx : undefined;
      const valid = isPlacementValid(ds.itemId, grid.col, grid.row, excludeIdx);
      ctx.save();
      ctx.globalAlpha = 0.5;
      if (!valid) {
        // Red tint for invalid position
        ctx.globalAlpha = 0.4;
      }
      // Draw at snapped grid position
      const snapPos = gridToGame(grid.col, grid.row);
      if (dragItem.id !== 'exercise-wheel') {
        drawFurnitureItem(dragItem, grid.col, grid.row);
      }
      if (!valid) {
        // Red overlay
        ctx.fillStyle = 'rgba(255,50,50,0.3)';
        ctx.fillRect(snapPos.x, snapPos.y, dragItem.w * GRID_SIZE, dragItem.h * GRID_SIZE);
      }
      ctx.restore();
    }
  }

  // -- Room name label drawn on top bar instead (see game loop) --
  ctx.textBaseline = 'alphabetic';

  // -- Bottom bar --
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, ROOM_Y + ROOM_H, GAME_W, GAME_H - ROOM_Y - ROOM_H);
}

// ============================================================
// FURNITURE RENDERING
// ============================================================
function drawFurnitureItem(item, gx, gy, placedRef) {
  const pos = gridToGame(gx, gy);
  const w = item.w * GRID_SIZE;
  const h = item.h * GRID_SIZE;
  const x = pos.x, y = pos.y;
  const t = Date.now() / 1000;

  // Parse item.color into r,g,b for shade derivation
  const _cc = item.color;
  const _pr = parseInt(_cc.slice(1,3),16), _pg = parseInt(_cc.slice(3,5),16), _pb = parseInt(_cc.slice(5,7),16);
  const lighter = `rgb(${Math.min(_pr+40,255)},${Math.min(_pg+40,255)},${Math.min(_pb+40,255)})`;
  const darker  = `rgb(${Math.max(_pr-40,0)},${Math.max(_pg-40,0)},${Math.max(_pb-40,0)})`;
  const darkest = `rgb(${Math.max(_pr-70,0)},${Math.max(_pg-70,0)},${Math.max(_pb-70,0)})`;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.beginPath();
  ctx.roundRect(x + 2, y + 2, w, h, 3);
  ctx.fill();

  switch (item.id) {

  case 'matchbox-bed': { // 2x1 48x24
    // Matchbox body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x, y+4, 48, 20, 2); ctx.fill();
    ctx.fillStyle = darker;
    ctx.fillRect(x+1, y+22, 46, 2); // bottom edge
    // Matchbox inner tray
    ctx.fillStyle = lighter;
    ctx.fillRect(x+3, y+6, 42, 14);
    // Pillow
    ctx.fillStyle = '#f0eee8';
    ctx.beginPath(); ctx.roundRect(x+5, y+8, 10, 8, 2); ctx.fill();
    ctx.fillStyle = '#ddd';
    ctx.fillRect(x+6, y+12, 8, 1);
    // Blanket/quilt
    ctx.fillStyle = '#6ba36b';
    ctx.beginPath(); ctx.roundRect(x+17, y+7, 26, 12, 2); ctx.fill();
    ctx.fillStyle = '#5a8f5a';
    ctx.fillRect(x+17, y+13, 26, 1);
    ctx.fillRect(x+29, y+7, 1, 12);
    // Striker strip on side
    ctx.fillStyle = '#3a2510';
    ctx.fillRect(x+1, y+8, 2, 12);
    break;
  }

  case 'thimble-cup': { // 1x1 24x24
    // Thimble body (tapered)
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+6, y+22); ctx.lineTo(x+4, y+8);
    ctx.quadraticCurveTo(x+12, y+3, x+20, y+8);
    ctx.lineTo(x+18, y+22); ctx.closePath(); ctx.fill();
    // Highlight
    ctx.fillStyle = lighter;
    ctx.fillRect(x+8, y+8, 3, 12);
    // Dimple dots near top
    ctx.fillStyle = darker;
    for (let r = 0; r < 2; r++) for (let c = 0; c < 4; c++) {
      ctx.fillRect(x+7+c*3, y+6+r*3, 1, 1);
    }
    // Rim
    ctx.fillStyle = darkest;
    ctx.fillRect(x+4, y+7, 16, 1);
    // Base
    ctx.fillStyle = darker;
    ctx.fillRect(x+6, y+22, 12, 2);
    // Steam wisps
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 2; i++) {
      const sx = x+10+i*5, sy = y+3;
      const off = Math.sin(t*2+i*2)*2;
      ctx.beginPath(); ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(sx+off, sy-4, sx-off, sy-7);
      ctx.stroke();
    }
    break;
  }

  case 'bottlecap-plate': { // 1x1 24x24
    const cx = x+12, cy = y+14;
    // Crimped edge
    ctx.fillStyle = item.color;
    ctx.beginPath();
    for (let i = 0; i < 16; i++) {
      const a = (i/16)*Math.PI*2, r = i%2===0 ? 10 : 8.5;
      const px = cx+Math.cos(a)*r, py = cy+Math.sin(a)*r;
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill();
    // Inner flat area
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.fill();
    // Food crumbs
    ctx.fillStyle = '#c89040';
    ctx.fillRect(cx-2, cy-1, 2, 2);
    ctx.fillRect(cx+2, cy+1, 1, 1);
    ctx.fillRect(cx-1, cy+3, 2, 1);
    break;
  }

  case 'fairy-lights': { // 3x1 72x24
    // Wire
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+2, y+10);
    for (let i = 0; i < 72; i += 4) {
      ctx.lineTo(x+i, y+10 + Math.sin(i*0.15)*3);
    }
    ctx.stroke();
    // Bulbs
    const colors = ['#ff4444','#44ff44','#4488ff','#ffdd00','#ff88ff','#00ffcc','#ffaa00','#88aaff'];
    for (let i = 0; i < 8; i++) {
      const bx = x+6+i*8.5, by = y+10+Math.sin((6+i*8.5)*0.15)*3;
      const twinkle = 0.5 + 0.5*Math.sin(t*4 + i*1.7);
      ctx.globalAlpha = 0.4 + twinkle*0.6;
      ctx.fillStyle = colors[i];
      ctx.beginPath(); ctx.arc(bx, by+2, 2.5, 0, Math.PI*2); ctx.fill();
      // Glow around bulb
      ctx.globalAlpha = twinkle*0.25;
      ctx.beginPath(); ctx.arc(bx, by+2, 5, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
    // Overall glow
    const glow = ctx.createRadialGradient(x+36, y+12, 4, x+36, y+12, 40);
    glow.addColorStop(0, 'rgba(255,240,180,0.12)');
    glow.addColorStop(1, 'rgba(255,240,180,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-10, y-10, 92, 44);
    break;
  }

  case 'tiny-laptop': { // 1x1 24x24
    // Base/keyboard
    ctx.fillStyle = darker;
    ctx.fillRect(x+3, y+15, 18, 7);
    ctx.fillStyle = darkest;
    ctx.fillRect(x+5, y+17, 14, 3); // keyboard area
    // Tiny key dots
    ctx.fillStyle = '#555';
    for (let r = 0; r < 2; r++) for (let c = 0; c < 5; c++)
      ctx.fillRect(x+6+c*3, y+17+r*2, 2, 1);
    // Screen (tilted back)
    ctx.fillStyle = item.color;
    ctx.fillRect(x+3, y+4, 18, 12);
    // Screen content
    ctx.fillStyle = '#1a2a4a';
    ctx.fillRect(x+5, y+5, 14, 9);
    // Blue glow on screen
    ctx.fillStyle = '#4488cc';
    ctx.fillRect(x+6, y+7, 12, 2);
    ctx.fillStyle = '#335577';
    ctx.fillRect(x+6, y+10, 8, 1);
    ctx.fillRect(x+6, y+12, 10, 1);
    // Hinge
    ctx.fillStyle = darkest;
    ctx.fillRect(x+3, y+15, 18, 1);
    break;
  }

  case 'yoga-mat': { // 2x1 48x24
    // Flat mat
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+2, y+14, 40, 8, 2); ctx.fill();
    // Stripe
    ctx.fillStyle = lighter;
    ctx.fillRect(x+4, y+17, 36, 2);
    // Rolled curl at right end
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.arc(x+43, y+18, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(x+43, y+18, 2.5, 0, Math.PI*2); ctx.fill();
    // Mat thickness shadow
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(x+2, y+21, 40, 2);
    break;
  }

  case 'live-laugh-cheese': { // 2x1 48x24
    // Frame
    ctx.fillStyle = '#a08050';
    ctx.beginPath(); ctx.roundRect(x+2, y+3, 44, 18, 2); ctx.fill();
    // Inner
    ctx.fillStyle = item.color;
    ctx.fillRect(x+4, y+5, 40, 14);
    // Text "LLL"
    ctx.fillStyle = '#8B7355';
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('LLL', x+24, y+12);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    // Small cheese doodle
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(x+37, y+14, 4, 3);
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+38, y+15, 1, 1);
    break;
  }

  case 'sourdough': { // 1x1 24x24
    // Jar
    ctx.fillStyle = '#a09080';
    ctx.fillRect(x+5, y+10, 14, 12);
    ctx.fillStyle = '#8a7a6a';
    ctx.fillRect(x+5, y+10, 14, 2); // rim
    // Dough blob rising out
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+6, y+12);
    ctx.quadraticCurveTo(x+8, y+5, x+12, y+5);
    ctx.quadraticCurveTo(x+16, y+4, x+18, y+12);
    ctx.closePath(); ctx.fill();
    // Bubbles
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(x+10, y+8, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+14, y+7, 1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+12, y+10, 1, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'ring-light': { // 1x1 24x24
    const cx = x+12, cy = y+10;
    // Stand
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cx, cy+6); ctx.lineTo(cx, y+22); ctx.stroke();
    ctx.fillStyle = '#555';
    ctx.fillRect(cx-4, y+21, 8, 2);
    // Ring
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.stroke();
    // Bright white glow
    ctx.strokeStyle = 'rgba(255,255,230,0.5)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.stroke();
    // Overall glow
    const glow = ctx.createRadialGradient(cx, cy, 4, cx, cy, 20);
    glow.addColorStop(0, 'rgba(255,250,220,0.15)');
    glow.addColorStop(1, 'rgba(255,250,220,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-8, y-8, 40, 40);
    break;
  }

  case 'cardboard-couch': { // 2x1 48x24
    // Main body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+2, y+6, 44, 16, 2); ctx.fill();
    // Armrests
    ctx.fillStyle = darker;
    ctx.fillRect(x+2, y+4, 6, 18);
    ctx.fillRect(x+40, y+4, 6, 18);
    // Seat cushion line
    ctx.fillStyle = lighter;
    ctx.fillRect(x+9, y+10, 30, 2);
    // Corrugated cardboard lines
    ctx.strokeStyle = darker;
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 6; i++) {
      const ly = y+8+i*2.5;
      ctx.beginPath(); ctx.moveTo(x+9, ly);
      for (let lx = 0; lx < 30; lx += 3) {
        ctx.lineTo(x+9+lx+1.5, ly + (lx%6===0?1:-1));
      }
      ctx.stroke();
    }
    // Bottom edge
    ctx.fillStyle = darkest;
    ctx.fillRect(x+2, y+21, 44, 2);
    break;
  }

  case 'spool-table': { // 1x1 24x24
    const cx = x+12;
    // Top disc
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.ellipse(cx, y+7, 10, 4, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.ellipse(cx, y+6, 8, 3, 0, 0, Math.PI*2); ctx.fill();
    // Center hole
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(cx, y+6, 2, 0, Math.PI*2); ctx.fill();
    // Narrow body
    ctx.fillStyle = item.color;
    ctx.fillRect(cx-4, y+7, 8, 10);
    // Thread wrapping hints
    ctx.fillStyle = '#dda0dd';
    ctx.fillRect(cx-4, y+9, 8, 2);
    ctx.fillRect(cx-4, y+13, 8, 2);
    // Base disc
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.ellipse(cx, y+18, 10, 4, 0, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'eraser-tv': { // 1x1 24x24
    // Antenna
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+9, y+7); ctx.lineTo(x+6, y+2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+15, y+7); ctx.lineTo(x+18, y+2); ctx.stroke();
    // TV body (eraser shape)
    ctx.fillStyle = '#e8a0a8';
    ctx.beginPath(); ctx.roundRect(x+3, y+7, 18, 14, 2); ctx.fill();
    // Eraser band at bottom
    ctx.fillStyle = '#3050a0';
    ctx.fillRect(x+3, y+17, 18, 4);
    // Screen
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(x+5, y+8, 14, 8);
    // Static lines
    ctx.fillStyle = '#445';
    const staticOff = Math.floor(t * 8) % 4;
    for (let i = 0; i < 4; i++) {
      const sy = y+9+((i*2+staticOff)%8);
      if (sy < y+16) ctx.fillRect(x+5, sy, 14, 1);
    }
    // Screen flicker
    ctx.fillStyle = `rgba(150,180,200,${0.05+0.05*Math.sin(t*10)})`;
    ctx.fillRect(x+5, y+8, 14, 8);
    break;
  }

  case 'ethernet-rope': { // 1x1 24x24
    // Coiled cable
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x+12, y+14, 6, 0.3, Math.PI*1.8); ctx.stroke();
    ctx.beginPath();
    ctx.arc(x+12, y+14, 3.5, 0.8, Math.PI*1.5); ctx.stroke();
    // RJ45 connector end
    ctx.fillStyle = '#ccc';
    ctx.fillRect(x+17, y+8, 4, 6);
    ctx.fillStyle = '#aaa';
    ctx.fillRect(x+18, y+9, 2, 4);
    // Clip on connector
    ctx.fillStyle = '#ddd';
    ctx.fillRect(x+18, y+7, 2, 2);
    // Cable coming off connector
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x+19, y+14); ctx.lineTo(x+18, y+17); ctx.stroke();
    break;
  }

  case 'cork-stool': { // 1x1 24x24
    // Cork body (upright cylinder)
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+6, y+5, 12, 17, 3); ctx.fill();
    // Lighter front face
    ctx.fillStyle = lighter;
    ctx.fillRect(x+8, y+7, 8, 13);
    // Dot texture
    ctx.fillStyle = darker;
    for (let r = 0; r < 4; r++) for (let c = 0; c < 3; c++) {
      ctx.fillRect(x+8+c*3, y+8+r*3.5, 1, 1);
    }
    // Top
    ctx.fillStyle = lighter;
    ctx.beginPath(); ctx.ellipse(x+12, y+6, 6, 2.5, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = darker;
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.ellipse(x+12, y+6, 6, 2.5, 0, 0, Math.PI*2); ctx.stroke();
    break;
  }

  case 'tiny-plant': { // 1x1 24x24
    // Pot (trapezoid)
    ctx.fillStyle = '#b5651d';
    ctx.beginPath();
    ctx.moveTo(x+6, y+13); ctx.lineTo(x+8, y+22);
    ctx.lineTo(x+16, y+22); ctx.lineTo(x+18, y+13);
    ctx.closePath(); ctx.fill();
    // Pot rim
    ctx.fillStyle = '#c97a3a';
    ctx.fillRect(x+5, y+12, 14, 2);
    // Soil
    ctx.fillStyle = '#4a3520';
    ctx.beginPath(); ctx.ellipse(x+12, y+13, 6, 2, 0, 0, Math.PI*2); ctx.fill();
    // Leaves
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.ellipse(x+10, y+8, 3, 5, -0.3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#1e7a1e';
    ctx.beginPath(); ctx.ellipse(x+14, y+9, 2.5, 4, 0.3, 0, Math.PI*2); ctx.fill();
    // Tiny stem
    ctx.strokeStyle = '#2d5a1e';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+12, y+13); ctx.lineTo(x+12, y+8); ctx.stroke();
    break;
  }

  case 'disco-ball': { // 1x1 24x24
    const cx = x+12, cy = y+12;
    // String at top
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx, y+1); ctx.lineTo(cx, y+5); ctx.stroke();
    // Ball body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.arc(cx, cy, 7, 0, Math.PI*2); ctx.fill();
    // Faceted mirror tiles
    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        const tx = cx + c*3, ty = cy + r*3;
        if ((tx-cx)**2+(ty-cy)**2 < 49) {
          const shimmer = 0.3 + 0.7*Math.sin(t*3 + r*2.1 + c*1.7);
          ctx.fillStyle = `rgba(255,255,255,${shimmer*0.6})`;
          ctx.fillRect(tx-1, ty-1, 2.5, 2.5);
        }
      }
    }
    // Sparkle reflections scattered
    for (let i = 0; i < 4; i++) {
      const sa = t*2 + i*1.57;
      const sr = 10 + Math.sin(t*1.3+i)*2;
      const sx = cx + Math.cos(sa)*sr, sy = cy + Math.sin(sa)*sr;
      if (sx > x && sx < x+24 && sy > y && sy < y+24) {
        ctx.fillStyle = `rgba(255,255,200,${0.4+0.4*Math.sin(t*5+i)})`;
        ctx.fillRect(sx-1, sy-1, 2, 2);
      }
    }
    // Glow
    const glow = ctx.createRadialGradient(cx, cy, 3, cx, cy, 18);
    glow.addColorStop(0, 'rgba(255,240,180,0.12)');
    glow.addColorStop(1, 'rgba(255,240,180,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x-8, y-8, 40, 40);
    break;
  }

  case 'among-us-bean': { // 1x1 24x24
    // Body (bean shape)
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+8, y+5);
    ctx.quadraticCurveTo(x+18, y+3, x+18, y+10);
    ctx.lineTo(x+18, y+16);
    ctx.quadraticCurveTo(x+18, y+21, x+15, y+21);
    ctx.lineTo(x+14, y+17);
    ctx.lineTo(x+10, y+17);
    ctx.lineTo(x+9, y+21);
    ctx.quadraticCurveTo(x+6, y+21, x+6, y+16);
    ctx.lineTo(x+6, y+10);
    ctx.quadraticCurveTo(x+6, y+5, x+8, y+5);
    ctx.closePath(); ctx.fill();
    // Visor
    ctx.fillStyle = '#87CEEB';
    ctx.beginPath();
    ctx.moveTo(x+7, y+7);
    ctx.quadraticCurveTo(x+7, y+12, x+12, y+12);
    ctx.quadraticCurveTo(x+17, y+12, x+17, y+9);
    ctx.quadraticCurveTo(x+17, y+6, x+12, y+6);
    ctx.quadraticCurveTo(x+7, y+6, x+7, y+7);
    ctx.closePath(); ctx.fill();
    // Visor shine
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillRect(x+9, y+7, 3, 2);
    // Backpack bump
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.roundRect(x+17, y+10, 4, 7, 1);
    ctx.fill();
    break;
  }

  case 'cheese-wheel': { // 1x1 24x24
    // Wedge shape (3D-ish)
    // Top face
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+4, y+8); ctx.lineTo(x+20, y+8);
    ctx.lineTo(x+20, y+14); ctx.lineTo(x+4, y+14);
    ctx.closePath(); ctx.fill();
    // Front face (darker wedge)
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.moveTo(x+4, y+14); ctx.lineTo(x+20, y+14);
    ctx.lineTo(x+18, y+21); ctx.lineTo(x+6, y+21);
    ctx.closePath(); ctx.fill();
    // Side face
    ctx.fillStyle = darkest;
    ctx.beginPath();
    ctx.moveTo(x+20, y+8); ctx.lineTo(x+22, y+10);
    ctx.lineTo(x+20, y+16); ctx.lineTo(x+20, y+14);
    ctx.closePath(); ctx.fill();
    // Holes
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.arc(x+10, y+11, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+16, y+10, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = darkest;
    ctx.beginPath(); ctx.arc(x+9, y+17, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+15, y+17, 1, 0, Math.PI*2); ctx.fill();
    // Rind edge
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+4, y+7, 16, 1);
    break;
  }

  case 'cheese-wedge': { // 1x1 24x24
    // Servings visual ‚Äî fade/shrink as eaten
    const placed = placedRef;
    const serv = placed && placed.servings !== undefined ? placed.servings : 3;
    const servFrac = serv / 3;
    const sw = Math.max(0.4, servFrac);
    ctx.save();
    ctx.translate(x + 12, y + 20);
    ctx.scale(sw, sw);
    ctx.translate(-(x + 12), -(y + 20));
    // Wedge triangle
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+4, y+20); ctx.lineTo(x+12, y+6); ctx.lineTo(x+20, y+20);
    ctx.closePath(); ctx.fill();
    // Rind
    ctx.fillStyle = '#daa520';
    ctx.fillRect(x+4, y+19, 16, 2);
    // Holes
    ctx.fillStyle = '#c89020';
    ctx.beginPath(); ctx.arc(x+10, y+15, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+14, y+12, 1, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    // Serving dots
    if (serv < 3) {
      for (let i = 0; i < serv; i++) {
        ctx.fillStyle = '#f0c040';
        ctx.beginPath(); ctx.arc(x + 8 + i * 4, y + 3, 1.5, 0, Math.PI*2); ctx.fill();
      }
    }
    break;
  }

  case 'blueberry-bowl': { // 1x1 24x24
    const placed = placedRef;
    const serv = placed && placed.servings !== undefined ? placed.servings : 5;
    // Bowl
    ctx.fillStyle = '#8a7a6a';
    ctx.beginPath();
    ctx.moveTo(x+4, y+12); ctx.quadraticCurveTo(x+4, y+22, x+12, y+22);
    ctx.quadraticCurveTo(x+20, y+22, x+20, y+12);
    ctx.lineTo(x+4, y+12);
    ctx.closePath(); ctx.fill();
    // Bowl rim
    ctx.fillStyle = '#9a8a7a';
    ctx.fillRect(x+3, y+11, 18, 2);
    // Berries (show remaining servings)
    const berryPositions = [[8,15],[14,15],[11,13],[7,17],[15,17]];
    for (let i = 0; i < Math.min(serv, 5); i++) {
      const bp = berryPositions[i];
      ctx.fillStyle = item.color;
      ctx.beginPath(); ctx.arc(x+bp[0], y+bp[1], 2.5, 0, Math.PI*2); ctx.fill();
      // Berry highlight
      ctx.fillStyle = '#7a8ad0';
      ctx.beginPath(); ctx.arc(x+bp[0]-0.5, y+bp[1]-0.5, 1, 0, Math.PI*2); ctx.fill();
    }
    break;
  }

  case 'stamp-painting': { // 1x1 24x24
    // Frame
    ctx.fillStyle = '#8B7355';
    ctx.beginPath(); ctx.roundRect(x+2, y+3, 20, 18, 1); ctx.fill();
    // Inner canvas
    ctx.fillStyle = '#faf0e6';
    ctx.fillRect(x+4, y+5, 16, 14);
    // Colorful abstract splotches
    ctx.fillStyle = '#e04060';
    ctx.beginPath(); ctx.arc(x+8, y+10, 3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#4080e0';
    ctx.beginPath(); ctx.arc(x+15, y+13, 2.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#40c060';
    ctx.fillRect(x+11, y+7, 4, 4);
    ctx.fillStyle = '#e0c040';
    ctx.beginPath(); ctx.arc(x+8, y+15, 2, 0, Math.PI*2); ctx.fill();
    break;
  }

  case 'tiny-hoodie': { // 1x1 24x24
    // Hook
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+12, y+2); ctx.lineTo(x+12, y+5);
    ctx.arc(x+12, y+4, 2, -Math.PI/2, Math.PI/2);
    ctx.stroke();
    // Body
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+5, y+7, 14, 13, 2); ctx.fill();
    // Hood bump
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.arc(x+12, y+7, 5, Math.PI, 0); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(x+12, y+7, 3.5, Math.PI, 0); ctx.fill();
    // Sleeves
    ctx.fillStyle = darker;
    ctx.fillRect(x+3, y+9, 3, 7);
    ctx.fillRect(x+18, y+9, 3, 7);
    // Front pocket
    ctx.fillStyle = darkest;
    ctx.fillRect(x+8, y+15, 8, 3);
    // Drawstrings
    ctx.strokeStyle = lighter;
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(x+10, y+8); ctx.lineTo(x+10, y+11); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+14, y+8); ctx.lineTo(x+14, y+11); ctx.stroke();
    break;
  }

  case 'birthday-cake': { // 1x1 24x24
    // Bottom layer
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x+4, y+14, 16, 8, 2); ctx.fill();
    // Frosting drips
    ctx.fillStyle = lighter;
    ctx.fillRect(x+4, y+14, 16, 3);
    ctx.fillRect(x+6, y+17, 2, 2);
    ctx.fillRect(x+14, y+17, 2, 2);
    // Top layer
    ctx.fillStyle = darker;
    ctx.beginPath(); ctx.roundRect(x+6, y+10, 12, 5, 1); ctx.fill();
    ctx.fillStyle = item.color;
    ctx.fillRect(x+6, y+10, 12, 2);
    // Candle
    ctx.fillStyle = '#fff';
    ctx.fillRect(x+11, y+4, 2, 6);
    // Flame
    const flicker = Math.sin(t*8)*0.5;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.ellipse(x+12, y+3+flicker, 1.5, 2.5, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#ffdd00';
    ctx.beginPath();
    ctx.ellipse(x+12, y+3+flicker, 0.8, 1.5, 0, 0, Math.PI*2);
    ctx.fill();
    break;
  }

  case 'party-banner': { // 3x1 72x24
    // String
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+2, y+6);
    ctx.quadraticCurveTo(x+36, y+10, x+70, y+6);
    ctx.stroke();
    // Pennant flags
    const flagColors = ['#ff4466','#44bbff','#ffcc00','#66dd66','#ff88dd','#ff8844','#aa88ff','#44ffcc'];
    for (let i = 0; i < 8; i++) {
      const fx = x+6+i*8;
      const fy = y+6 + Math.sin((fx-x)/72*Math.PI)*4;
      ctx.fillStyle = flagColors[i % flagColors.length];
      ctx.beginPath();
      ctx.moveTo(fx-3, fy); ctx.lineTo(fx+3, fy);
      ctx.lineTo(fx, fy+10);
      ctx.closePath(); ctx.fill();
    }
    break;
  }

  case 'hammock': { // 3x1 72x24 ‚Äî hangs under a shelf
    const placed = placedRef;
    const t2 = Date.now() / 1000;
    const sway = Math.sin(t2 * 1.2) * 1.5;
    // Check if any mice are sleeping in this hammock
    const miceInHammock = [];
    ['pip', 'chai'].forEach(key => {
      const m = state.miceState[key];
      if (m.onFurniture === placed && m.action === 'sleeping') miceInHammock.push(key);
    });
    const heavierSway = miceInHammock.length > 0 ? sway * 1.8 + Math.sin(t2 * 0.6) * 1 : sway;
    // Rope ties from top corners down to fabric
    ctx.strokeStyle = '#a08040';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x+4, y); ctx.lineTo(x+10, y+8); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+68, y); ctx.lineTo(x+62, y+8); ctx.stroke();
    // Hammock fabric back (behind mice)
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.moveTo(x+8, y+7);
    ctx.quadraticCurveTo(x+36, y+18 + heavierSway, x+64, y+7);
    ctx.lineTo(x+64, y+11);
    ctx.quadraticCurveTo(x+36, y+22 + heavierSway, x+8, y+11);
    ctx.closePath();
    ctx.fill();
    // Fabric stripes
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 0.8;
    for (let si = 0; si < 3; si++) {
      const sx = x + 22 + si * 12;
      ctx.beginPath();
      ctx.moveTo(sx, y+9 + heavierSway*0.3);
      ctx.lineTo(sx, y+17 + heavierSway*0.7);
      ctx.stroke();
    }
    // Draw mice nestled in the hammock
    if (miceInHammock.length > 0) {
      const sagY = y + 12 + heavierSway;
      ctx.save();
      ctx.beginPath();
      ctx.rect(x+6, y-2, 60, 28 + Math.abs(heavierSway));
      ctx.clip();
      miceInHammock.forEach((key, idx) => {
        const cfg = CONFIG.mice[key];
        const offsetX = miceInHammock.length === 2 ? (idx === 0 ? -10 : 10) : 0;
        const mx = x + 26 + offsetX;
        const my = sagY - 6;
        drawMouse(mx, my, cfg, idx === 0 ? 1 : -1, 0, 'sleeping', false, state.miceState[key]);
      });
      ctx.restore();
    }
    // Front edge of hammock (drawn over mice)
    ctx.strokeStyle = darker;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+8, y+9);
    ctx.quadraticCurveTo(x+36, y+20 + heavierSway, x+64, y+9);
    ctx.stroke();
    // Second rope layer for depth
    ctx.strokeStyle = 'rgba(160,128,64,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+6, y+1); ctx.lineTo(x+11, y+9); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+66, y+1); ctx.lineTo(x+61, y+9); ctx.stroke();
    break;
  }

  case 'tp-tunnel': { // 2x1 48x24
    // Outer tube
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.ellipse(x+24, y+13, 22, 10, 0, 0, Math.PI*2);
    ctx.fill();
    // Inner tube (dark opening)
    ctx.fillStyle = '#3a2a1a';
    ctx.beginPath();
    ctx.ellipse(x+24, y+13, 16, 7, 0, 0, Math.PI*2);
    ctx.fill();
    // Cardboard texture lines
    ctx.strokeStyle = 'rgba(160,130,90,0.3)';
    ctx.lineWidth = 0.5;
    for (let ri = 0; ri < 6; ri++) {
      ctx.beginPath();
      ctx.moveTo(x+6+ri*7, y+4);
      ctx.lineTo(x+6+ri*7, y+22);
      ctx.stroke();
    }
    // Highlight on top
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.ellipse(x+24, y+8, 18, 4, 0, 0, Math.PI);
    ctx.fill();
    // Torn edges
    ctx.fillStyle = darker;
    const edgeY = y+13;
    for (let ei = 0; ei < 3; ei++) {
      ctx.fillRect(x+4+ei*4, edgeY+7, 2, 1);
      ctx.fillRect(x+38+ei*4, edgeY+7, 2, 1);
    }
    break;
  }

  case 'chew-stick': { // 1x1 24x24
    // Stick body (diagonal)
    ctx.save();
    ctx.translate(x+12, y+12);
    ctx.rotate(-0.3);
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.roundRect(-10, -4, 20, 8, 2);
    ctx.fill();
    // Wood grain
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 0.5;
    for (let gi = 0; gi < 4; gi++) {
      ctx.beginPath();
      ctx.moveTo(-8+gi*5, -3);
      ctx.lineTo(-8+gi*5, 3);
      ctx.stroke();
    }
    // Bark texture
    ctx.fillStyle = darker;
    ctx.fillRect(-10, -4, 3, 8);
    ctx.fillRect(7, -4, 3, 8);
    // Chew marks (bite marks on one end)
    ctx.fillStyle = lighter;
    ctx.fillRect(8, -2, 2, 1.5);
    ctx.fillRect(8, 1, 2, 1.5);
    ctx.restore();
    // Small wood chips scattered
    ctx.fillStyle = lighter;
    ctx.fillRect(x+16, y+20, 2, 1);
    ctx.fillRect(x+6, y+19, 1.5, 1.5);
    break;
  }

  case 'climbing-rope': { // 1x3 24x72 ‚Äî wall-mounted rope
    const placed = placedRef;
    const t2 = Date.now() / 1000;
    // Check for mice on this rope
    const miceOnRope = [];
    ['pip', 'chai'].forEach(key => {
      const m = state.miceState[key];
      if (m.onFurniture === placed && m.action === 'swinging') miceOnRope.push(key);
    });
    const weightSway = miceOnRope.length > 0 ? Math.sin(t2 * 1.5) * 3 : Math.sin(t2 * 0.8) * 1.5;
    // Anchor point (hook/bracket at top)
    ctx.fillStyle = '#888';
    ctx.beginPath();
    ctx.arc(x+12, y+3, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#666';
    ctx.fillRect(x+10, y+0, 4, 5);
    // Rope body (braided, extends full 72px height)
    const ropeLen = 64;
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 3.5;
    ctx.beginPath();
    ctx.moveTo(x+12, y+6);
    for (let ri = 0; ri <= 12; ri++) {
      const ry = y+6 + ri * (ropeLen/12);
      const rx = x+12 + Math.sin(ri*0.7)*1.5 + weightSway*(ri/12);
      ctx.lineTo(rx, ry);
    }
    ctx.stroke();
    // Rope detail (twist/cross-hatch pattern)
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    for (let ki = 0; ki < 10; ki++) {
      const ky = y+10 + ki*6;
      const kOffset = weightSway*(ki/10);
      ctx.beginPath();
      ctx.moveTo(x+10 + kOffset, ky);
      ctx.lineTo(x+14 + kOffset, ky+3);
      ctx.stroke();
    }
    // Draw mice clinging to the rope
    miceOnRope.forEach((key, idx) => {
      const cfg = CONFIG.mice[key];
      // Animate climbing position along the rope
      const climbCycle = Math.sin(t2 * 0.8 + idx * Math.PI) * 0.3 + 0.5;
      const climbY = y + 10 + climbCycle * (ropeLen - 30);
      const climbSwayX = weightSway * (climbCycle * 0.8 + 0.2);
      const mx = x + 12 + climbSwayX - 14;
      const my = climbY - 10;
      ctx.save();
      ctx.translate(x + 12 + climbSwayX, climbY);
      ctx.rotate(weightSway * 0.02);
      ctx.translate(-(x + 12 + climbSwayX), -climbY);
      const climbFrame = Math.floor(t2 * 3) % 4;
      drawMouse(mx, my, cfg, 1, climbFrame, 'walking');
      ctx.restore();
      // Paw grip marks on rope
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(x+10 + climbSwayX, climbY - 2, 4, 2);
      ctx.fillRect(x+10 + climbSwayX, climbY + 8, 4, 2);
    });
    // Knot at bottom
    ctx.fillStyle = item.color;
    const knotY = y + ropeLen + 4 + weightSway;
    ctx.beginPath();
    ctx.arc(x+12 + weightSway, knotY, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = darker;
    ctx.beginPath();
    ctx.arc(x+12 + weightSway, knotY, 2.5, 0, Math.PI*2);
    ctx.fill();
    // Frayed end
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 0.8;
    for (let fi = 0; fi < 3; fi++) {
      ctx.beginPath();
      ctx.moveTo(x+12 + weightSway + (fi-1)*2, knotY + 4);
      ctx.lineTo(x+12 + weightSway + (fi-1)*3, knotY + 8 + Math.sin(t2*2+fi)*1);
      ctx.stroke();
    }
    break;
  }

  default: {
    // Fallback: colored rect + emoji (for unknown items)
    ctx.fillStyle = item.color;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(x+2, y+1, w-4, 3);
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(x+1, y+h-2, w-2, 2);
    const iconSize = Math.min(w, h) - 4;
    ctx.font = `${iconSize}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(item.icon, x + w/2, y + h/2 + 1);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    break;
  }

  } // end switch
}

// ============================================================
// EXERCISE WHEEL SYSTEM
// ============================================================
let wheelState = {
  angle: 0,        // current rotation angle
  speed: 0,        // spin speed (rad/frame)
  miceOn: [],      // keys of mice currently on the wheel ('pip', 'chai')
  flingTimer: 0,   // cooldown before another fling can happen
  flingTarget: null // mouse key being flung
};

function getWheelPlacement() {
  return state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === state.currentRoom);
}

function getWheelCenter(placed) {
  const pos = gridToGame(placed.gridX, placed.gridY);
  const w = 3 * GRID_SIZE; // wheel is 3x3 grid
  const h = 3 * GRID_SIZE;
  return { x: pos.x + w / 2, y: pos.y + h / 2 };
}

function drawExerciseWheel(placed) {
  const center = getWheelCenter(placed);
  const radius = 32;
  const t = Date.now() / 1000;

  // Wheel stand / frame
  ctx.fillStyle = '#5a4a3a';
  ctx.fillRect(center.x - 3, center.y + radius - 4, 6, 12);
  // Base feet
  ctx.fillRect(center.x - 14, center.y + radius + 6, 28, 4);
  ctx.fillStyle = '#4a3a2a';
  ctx.fillRect(center.x - 12, center.y + radius + 8, 24, 3);

  // Axle shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(center.x, center.y + radius + 8, 18, 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Outer wheel ring
  ctx.strokeStyle = '#8a9aaa';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  ctx.stroke();

  // Inner wheel ring (running surface)
  ctx.strokeStyle = '#6a7a8a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius - 5, 0, Math.PI * 2);
  ctx.stroke();

  // Spokes (rotate with wheel)
  ctx.strokeStyle = 'rgba(138,154,170,0.5)';
  ctx.lineWidth = 1.5;
  const numSpokes = 8;
  for (let i = 0; i < numSpokes; i++) {
    const a = wheelState.angle + (i / numSpokes) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(center.x + Math.cos(a) * 6, center.y + Math.sin(a) * 6);
    ctx.lineTo(center.x + Math.cos(a) * (radius - 2), center.y + Math.sin(a) * (radius - 2));
    ctx.stroke();
  }

  // Hub (center axle)
  ctx.fillStyle = '#aabbcc';
  ctx.beginPath();
  ctx.arc(center.x, center.y, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#8a9aaa';
  ctx.beginPath();
  ctx.arc(center.x, center.y, 3, 0, Math.PI * 2);
  ctx.fill();

  // Running treads on inner surface (rotating marks)
  ctx.fillStyle = 'rgba(90,100,110,0.3)';
  for (let i = 0; i < 16; i++) {
    const a = wheelState.angle + (i / 16) * Math.PI * 2;
    const tx = center.x + Math.cos(a) * (radius - 3);
    const ty = center.y + Math.sin(a) * (radius - 3);
    ctx.fillRect(tx - 1, ty - 1, 2, 2);
  }

  // Draw mice on the wheel
  wheelState.miceOn.forEach((mouseKey, idx) => {
    const mouse = state.miceState[mouseKey];
    const cfg = CONFIG.mice[mouseKey];
    if (mouse.action !== 'wheeling') return;

    // Mouse runs at bottom-inside of wheel, offset by wheel rotation
    // The mouse stays at roughly the bottom but the wheel rotates around it
    const mouseAngle = Math.PI / 2 + Math.sin(t * 3) * 0.15; // slight bobbing
    const runRadius = radius - 14;
    const mx = center.x + Math.cos(mouseAngle) * runRadius - 14;
    const my = center.y + Math.sin(mouseAngle) * runRadius - 20;

    // Running legs animation synced to wheel speed
    const runFrame = Math.floor(t * 8 * Math.max(1, wheelState.speed * 8)) % 4;
    drawMouse(mx, my, cfg, 1, runFrame, 'walking');
  });

  // Metallic sheen on wheel (top highlight)
  ctx.strokeStyle = 'rgba(200,220,240,0.2)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, radius, -Math.PI * 0.7, -Math.PI * 0.3);
  ctx.stroke();
}

function updateExerciseWheel(dt) {
  // Find wheel in exercise room (room 3)
  const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel');
  if (!wheelPlaced) return;

  // Update fling cooldown
  if (wheelState.flingTimer > 0) wheelState.flingTimer -= dt;

  // Check which mice are on the wheel
  const onWheel = [];
  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    if (mouse.action === 'wheeling' && mouse.room === wheelPlaced.room) {
      onWheel.push(key);
    }
  });
  wheelState.miceOn = onWheel;

  // Update wheel speed based on mice running
  if (onWheel.length > 0) {
    const targetSpeed = onWheel.length === 1 ? 0.04 : 0.08; // faster with two mice
    wheelState.speed += (targetSpeed - wheelState.speed) * 0.02;
  } else {
    // Slow down gradually
    wheelState.speed *= 0.98;
    if (wheelState.speed < 0.001) wheelState.speed = 0;
  }

  wheelState.angle += wheelState.speed * dt * 0.06;

  // Two-mouse interaction: one gets flung off!
  if (onWheel.length === 2 && wheelState.flingTimer <= 0 && Math.random() < 0.0008 * dt) {
    const flingKey = Math.random() < 0.5 ? onWheel[0] : onWheel[1];
    const stayKey = flingKey === onWheel[0] ? onWheel[1] : onWheel[0];
    flingMouseOffWheel(flingKey, stayKey, wheelPlaced);
  }

  // Occasional wheel squeak sound
  if (onWheel.length > 0 && Math.random() < 0.001 * dt) {
    sfxWheelSpin();
  }
}

function flingMouseOffWheel(flingKey, stayKey, wheelPlaced) {
  const mouse = state.miceState[flingKey];
  const center = getWheelCenter(wheelPlaced);

  // Fling the mouse!
  mouse.action = 'flung';
  mouse.actionTimer = 2500;
  unlockAchievement('wheel-warrior');
  mouse.flingVX = (Math.random() < 0.5 ? -1 : 1) * (2 + Math.random() * 2);
  mouse.flingVY = -(3 + Math.random() * 2);
  mouse.flingX = center.x - 14;
  mouse.flingY = center.y + 10;
  mouse.flingBounced = false;

  wheelState.flingTimer = 12000; // cooldown before next fling
  wheelState.speed *= 1.5; // wheel speeds up from the fling

  sfxWheelFling();

  // Flung mouse reaction
  const flingQuotes = [
    'YEET üòµ‚Äçüí´', 'I\'m flying!! üí´', 'was not ready', 'AAAA', 
    'parkour??', 'didn\'t sign up for this', '10/10 landing', 'ow',
    'that was on purpose actually', 'wheeeee! ...ow'
  ];
  speechBubbles.push({
    x: mouse.flingX + 14, y: mouse.flingY - 10,
    text: flingQuotes[Math.floor(Math.random() * flingQuotes.length)],
    timer: 3000, maxTimer: 3000, mouseKey: flingKey
  });

  // Staying mouse reaction (delayed)
  setTimeout(() => {
    const stayQuotes = [
      'lmaooo üòÇ', 'skill issue', 'MY wheel now', 'byeee üëã',
      'should\'ve held on', 'couldn\'t be me', 'ratio + flung'
    ];
    speechBubbles.push({
      x: state.miceState[stayKey].x + 14, y: getMouseFloorY(state.miceState[stayKey]) - 10,
      text: stayQuotes[Math.floor(Math.random() * stayQuotes.length)],
      timer: 3000, maxTimer: 3000, mouseKey: stayKey
    });
  }, 800);

  // Floating stars around flung mouse
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      spawnFloatingEffect(
        mouse.flingX + 14 + (Math.random() - 0.5) * 30,
        mouse.flingY + (Math.random() - 0.5) * 20,
        ['‚≠ê', 'üí´', 'üòµ‚Äçüí´', '‚ú®', 'üí•'][i]
      );
    }, i * 100 + 200);
  }
}

function updateFlungMouse(mouse, dt) {
  if (mouse.action !== 'flung') return false;

  const gravity = 0.008 * dt;
  mouse.flingVY += gravity;
  mouse.flingX += mouse.flingVX * dt * 0.06;
  mouse.flingY += mouse.flingVY * dt * 0.06;

  // Bounce off floor (flung mice land on main floor)
  const floorY = getMouseFloorY({ room: mouse.room, level: 'main-floor' });
  if (mouse.flingY >= floorY && !mouse.flingBounced) {
    mouse.flingBounced = true;
    mouse.flingVY = -Math.abs(mouse.flingVY) * 0.4;
    mouse.flingVX *= 0.5;
    // Small bounce sound
    sfxSqueak();
  }

  // Settle on floor
  if (mouse.flingBounced && mouse.flingY >= floorY) {
    mouse.flingY = floorY;
    mouse.x = Math.max(15, Math.min(ROOM_W - 45, mouse.flingX));
    mouse.action = 'idle';
    mouse.level = 'main-floor';
    mouse.actionTimer = 3000 + Math.random() * 2000;
    mouse.dir = Math.random() < 0.5 ? 1 : -1;
    return false;
  }

  // Bounce off walls
  if (mouse.flingX < 15) { mouse.flingX = 15; mouse.flingVX = Math.abs(mouse.flingVX) * 0.5; }
  if (mouse.flingX > ROOM_W - 45) { mouse.flingX = ROOM_W - 45; mouse.flingVX = -Math.abs(mouse.flingVX) * 0.5; }

  return true; // still flying
}

function drawFlungMouse(mouse, cfg) {
  if (mouse.action !== 'flung') return;
  const t = Date.now() / 1000;

  // Tumbling rotation
  const tumble = t * 8;

  ctx.save();
  const cx = mouse.flingX + 14;
  const cy = mouse.flingY + 10;
  ctx.translate(cx, cy);
  ctx.rotate(Math.sin(tumble) * 0.5);
  ctx.translate(-cx, -cy);

  drawMouse(mouse.flingX, mouse.flingY, cfg, 1, 0, 'idle');

  // Dizzy stars orbiting
  if (mouse.flingBounced) {
    const starR = 12;
    for (let i = 0; i < 3; i++) {
      const sa = t * 4 + (i / 3) * Math.PI * 2;
      ctx.font = '8px serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚≠ê', cx + Math.cos(sa) * starR, cy - 12 + Math.sin(sa) * 4);
    }
    ctx.textAlign = 'left';
  }

  ctx.restore();
}

// ============================================================
// EXERCISE ROOM SETUP (auto-place wheel)
// ============================================================
function ensureExerciseRoomSetup() {
  // Auto-place the exercise wheel in the exercise room if not already placed
  const hasWheel = state.placedItems.some(p => p.itemId === 'exercise-wheel');
  if (!hasWheel) {
    if (!state.ownedItems.includes('exercise-wheel')) {
      state.ownedItems.push('exercise-wheel');
    }
    // Place wheel centered in exercise room (room 3)
    state.placedItems.push({
      itemId: 'exercise-wheel', room: 3,
      gridX: Math.floor(GRID_COLS / 2) - 1, gridY: GRID_ROWS - 3
    });
    saveGame();
  }
}

// ============================================================
// FURNITURE PLACEMENT & REMOVAL
// ============================================================
function startPlacement(itemId) {
  state.placementMode = itemId;
  state.removeMode = false;
  // Auto-open tray if not already open
  if (!trayOpen) {
    autoTrayOpened = true;
    openTray();
  }
  highlightTrayItem(itemId);
  // On mobile, close shop flyout so canvas is visible for placement
  const isMobile = window.innerWidth <= 600 || (window.innerHeight <= 440 && window.innerWidth > window.innerHeight);
  if (isMobile && state.shopOpen) {
    // Close flyout without canceling the placement we just started
    state.shopOpen = false;
    document.getElementById('shop-flyout').classList.remove('open');
  }
}

function cancelPlacement() {
  state.placementMode = null;
  state.removeMode = false;
  state.dragState = { active: false, itemId: null, screenX: 0, screenY: 0, fromPlaced: false, fromPlacedIdx: -1, isTouch: false };
  document.getElementById('trash-zone').classList.remove('visible', 'hover');
  // Auto-close tray if it was auto-opened for placement
  if (autoTrayOpened && trayOpen) {
    closeTray();
  }
}

function toggleRemoveMode() {
  // No longer used as a separate mode ‚Äî kept as no-op for compatibility
}

function isPlacementValid(itemId, col, row, excludeIdx) {
  const item = FURNITURE.find(f => f.id === itemId);
  if (!item) return false;
  if (col < 0 || row < 0 || col + item.w > GRID_COLS || row + item.h > GRID_ROWS) return false;
  const overlaps = state.placedItems.some((p, idx) => {
    if (excludeIdx !== undefined && idx === excludeIdx) return false;
    if (p.room !== state.currentRoom) return false;
    const pi = FURNITURE.find(f => f.id === p.itemId);
    if (!pi) return false;
    return !(col + item.w <= p.gridX || p.gridX + pi.w <= col ||
             row + item.h <= p.gridY || p.gridY + pi.h <= row);
  });
  return !overlaps;
}

function handlePlacementClick(gx, gy) {
  const grid = gameToGrid(gx, gy);
  if (grid.col < 0 || grid.col >= GRID_COLS || grid.row < 0 || grid.row >= GRID_ROWS) return;

  if (state.removeMode) {
    const idx = state.placedItems.findIndex(p => {
      if (p.room !== state.currentRoom) return false;
      const it = FURNITURE.find(f => f.id === p.itemId);
      if (!it) return false;
      return grid.col >= p.gridX && grid.col < p.gridX + it.w &&
             grid.row >= p.gridY && grid.row < p.gridY + it.h;
    });
    if (idx >= 0) {
      const removed = state.placedItems[idx];
      const item = FURNITURE.find(f => f.id === removed.itemId);
      if (item?.exerciseRoom) {
        showToast("Can't remove the wheel! üé° The mice would riot.");
        return;
      }
      state.placedItems.splice(idx, 1);
      showToast(`Removed ${item?.name || 'item'} üóë`);
      saveGame();
    }
    return;
  }

  const item = FURNITURE.find(f => f.id === state.placementMode);
  if (!item) return;

  if (!isPlacementValid(item.id, grid.col, grid.row)) {
    showToast("Doesn't fit there! üê≠");
    return;
  }

  const placedEntry = {
    itemId: item.id, room: state.currentRoom,
    gridX: grid.col, gridY: grid.row
  };
  if (item.servings) placedEntry.servings = item.servings;
  state.placedItems.push(placedEntry);

  sfxPlace();
  showToast(`Placed ${item.icon} ${item.name}!`);
  cancelPlacement();
  addHappiness(3);
  state.stats.itemsPlaced++;
  checkAchievements();
  saveGame();
  refreshShopFlyout();
  refreshItemTray();
  reactToNewFurniture(item);
}

function reactToNewFurniture(item) {
  const placed = state.placedItems[state.placedItems.length - 1];
  const targetPos = gridToGame(placed.gridX, placed.gridY);

  ['pip', 'chai'].forEach(key => {
    const mouse = state.miceState[key];
    // Skip mice in non-interruptible states
    if (mouse.action === 'wheeling' || mouse.action === 'flung' || mouse.action === 'climbing' || mouse.onFurniture) return;

    if (mouse.room === state.currentRoom) {
      // Same room: walk over and try it out
      mouse.pendingClimb = null;
      mouse.pendingRoomChange = null;
      mouse.level = 'main-floor';
      mouse.action = 'walking';
      mouse.targetX = targetPos.x + (key === 'pip' ? -10 : 20);
      mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
      mouse.actionTimer = 6000;
      setTimeout(() => {
        if (mouse.room === state.currentRoom) {
          const curiosity = ['ooh what\'s this? üëÄ', 'new thing! üéâ', '*sniff sniff*',
            'is this for me?!', 'fancy ‚ú®', 'dibs!', 'must investigate üîç',
            'MINE', 'oooh shiny', '*inspects carefully*'][Math.floor(Math.random() * 10)];
          speechBubbles = speechBubbles.filter(b => b.mouseKey !== key);
          speechBubbles.push({
            x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
            text: curiosity, timer: 2500, maxTimer: 2500, mouseKey: key
          });
          // Try out the item's behavior if it has one
          if (item.mouseBehavior && item.mouseBehavior !== 'eating') {
            mouse.action = item.mouseBehavior;
            mouse.actionTimer = 3000 + Math.random() * 2000;
          }
        }
      }, 2000);
    } else {
      // Different room: head toward this room to check it out
      const nextRoom = ringStepToward(mouse.room, state.currentRoom);
      const exitDir = nextRoom === roomRight(mouse.room) ? 1 : -1;
      const exitX = exitDir > 0 ? ROOM_W - 5 : 5;
      mouse.pendingClimb = null;
      mouse.pendingRoomChange = null;
      mouse.level = 'main-floor';
      mouse.action = 'walking';
      mouse.targetX = exitX;
      mouse.dir = exitDir;
      mouse.actionTimer = 12000;
      mouse.pendingRoomChange = { newRoom: nextRoom, exitDir };
    }
  });
}

// ============================================================
// SHOP FLYOUT PANEL
// ============================================================
let trayOpen = false;
let autoTrayOpened = false;

function openTray() {
  trayOpen = true;
  const tray = document.getElementById('item-tray');
  const btn = document.getElementById('tray-toggle');
  refreshItemTray();
  tray.classList.add('open');
  btn.classList.add('open');
  btn.querySelector('span').style.transform = 'rotate(90deg)';
  requestAnimationFrame(() => {
    btn.style.bottom = tray.offsetHeight + 'px';
  });
  if (!state.shopOpen && !gamesOpen && !albumOpen && !trophyOpen) showBackdrop();
}

function closeTray() {
  trayOpen = false;
  autoTrayOpened = false;
  const tray = document.getElementById('item-tray');
  const btn = document.getElementById('tray-toggle');
  tray.classList.remove('open');
  btn.classList.remove('open');
  btn.querySelector('span').style.transform = 'rotate(-90deg)';
  btn.style.bottom = '';
  cancelPlacement();
  if (!state.shopOpen && !gamesOpen && !albumOpen && !trophyOpen) hideBackdrop();
}

function toggleTray() {
  if (cheeseChaseActive || whackACatActive || mouseMazeActive || dsActive) return;
  if (state.shopOpen || gamesOpen || albumOpen || trophyOpen) return;
  if (trayOpen) {
    closeTray();
  } else {
    autoTrayOpened = false;
    openTray();
  }
}

document.getElementById('tray-toggle').addEventListener('click', toggleTray);

function syncTrayToggle() {
  const btn = document.getElementById('tray-toggle');
  const tray = document.getElementById('item-tray');
  const isOpen = tray.classList.contains('open');
  if (isOpen) {
    btn.classList.add('open');
    btn.querySelector('span').style.transform = 'rotate(90deg)';
    requestAnimationFrame(() => { btn.style.bottom = tray.offsetHeight + 'px'; });
  } else {
    btn.classList.remove('open');
    btn.querySelector('span').style.transform = 'rotate(-90deg)';
    btn.style.bottom = '';
  }
}

function showBackdrop() { document.getElementById('flyout-backdrop').classList.add('visible'); }
function hideBackdrop() { document.getElementById('flyout-backdrop').classList.remove('visible'); }
// Light-dismiss: tapping backdrop closes any open flyout or tray
document.getElementById('flyout-backdrop').addEventListener('click', () => {
  if (state.shopOpen) closeShopFlyout();
  if (gamesOpen) closeGamesFlyout();
  if (albumOpen) closeAlbumFlyout();
  if (trophyOpen) closeTrophyFlyout();
  if (trayOpen) closeTray();
});

function openShop() {
  if (state.shopOpen) { closeShopFlyout(); return; }
  state.shopOpen = true;
  const flyout = document.getElementById('shop-flyout');
  if (gamesOpen) closeGamesFlyout();
  if (albumOpen) closeAlbumFlyout();
  if (trophyOpen) closeTrophyFlyout();
  refreshShopFlyout();
  refreshItemTray();
  flyout.classList.add('open');
  showBackdrop();
  document.getElementById('tray-toggle').classList.add('disabled');
}

function closeShopFlyout() {
  state.shopOpen = false;
  document.getElementById('shop-flyout').classList.remove('open');
  cancelPlacement();
  if (!gamesOpen && !albumOpen && !trophyOpen) document.getElementById('tray-toggle').classList.remove('disabled');
  if (!trayOpen && !gamesOpen && !albumOpen && !trophyOpen) hideBackdrop();
}

function refreshShopFlyout() {
  const owned = new Set(state.ownedItems);
  const container = document.getElementById('flyout-items');
  document.getElementById('flyout-coin-display').textContent = state.coins;
  let html = '';
  FURNITURE.forEach(item => {
    if (item.birthday && !state.birthdayEventSeen) return;
    if (item.exerciseRoom) return;
    const isOwned = owned.has(item.id);
    const isConsumable = !!item.servings;
    const canAfford = state.coins >= item.price;
    const label = isConsumable
      ? (canAfford ? 'üßÄ ' + item.price : 'üßÄ ' + item.price)
      : (isOwned ? '‚úÖ Owned' : (item.price === 0 ? 'üéÅ Free!' : 'üßÄ ' + item.price));
    const cls = isConsumable
      ? (!canAfford ? 'cant-afford' : '')
      : (isOwned ? 'owned' : (!canAfford ? 'cant-afford' : ''));
    html += `<div class="flyout-item ${cls}" data-item-id="${item.id}">
      <div class="fi-icon">${item.icon}</div>
      <div class="fi-name">${item.name}${isConsumable ? ' üîÑ' : ''}</div>
      <div class="fi-price">${label}</div>
    </div>`;
  });
  container.innerHTML = html;
  // Attach click handlers
  container.querySelectorAll('.flyout-item').forEach(el => {
    el.addEventListener('click', () => {
      const id = el.dataset.itemId;
      const item = FURNITURE.find(f => f.id === id);
      const isOwned = state.ownedItems.includes(id);
      const isConsumable = item && !!item.servings;
      if (isConsumable) {
        // Food items: always buy a fresh one (re-purchasable)
        if (item && state.coins >= item.price) {
          buyItem(id);
          startPlacement(id);
        }
      } else if (isOwned) {
        startPlacement(id);
        showToast('Drag from the tray below to place! üëá');
      } else {
        if (item && state.coins >= item.price) {
          buyItem(id);
        }
      }
    });
  });
  // Update loot info
  const lootInfo = document.getElementById('flyout-loot-info');
  lootInfo.textContent = state.lootCrumbsUsed > 0
    ? `Opened ${state.lootCrumbsUsed} times. Totally not addictive.`
    : 'Ironic gacha. Always free. No regrets.';
}

function refreshItemTray() {
  const tray = document.getElementById('item-tray');
  const owned = new Set(state.ownedItems);
  let html = '';
  FURNITURE.forEach(item => {
    if (!owned.has(item.id)) return;
    if (item.exerciseRoom) return;
    if (item.birthday && !state.birthdayEventSeen) return;
    const isActive = state.placementMode === item.id;
    html += `<div class="tray-item ${isActive ? 'active' : ''}" data-item-id="${item.id}">
      <div class="ti-icon">${item.icon}</div>
      <div class="ti-name">${item.name}</div>
    </div>`;
  });
  tray.innerHTML = html;
  // Re-sync chevron position after tray content changes height
  if (tray.classList.contains('open')) {
    requestAnimationFrame(() => {
      const btn = document.getElementById('tray-toggle');
      btn.style.bottom = tray.offsetHeight + 'px';
    });
  }
}

function highlightTrayItem(itemId) {
  document.querySelectorAll('.tray-item').forEach(el => {
    el.classList.toggle('active', el.dataset.itemId === itemId);
  });
  // Scroll tray item into view
  const active = document.querySelector(`.tray-item[data-item-id="${itemId}"]`);
  if (active) active.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
}

// ============================================================
// DRAG & DROP PLACEMENT SYSTEM
// ============================================================
const TOUCH_DRAG_OFFSET_Y = -60; // px ‚Äî shift drop target above fingertip on touch

function startDrag(itemId, sx, sy, fromPlaced, fromPlacedIdx, isTouch) {
  state.dragState = {
    active: true, itemId, screenX: sx, screenY: sy,
    fromPlaced: !!fromPlaced, fromPlacedIdx: fromPlacedIdx ?? -1,
    isTouch: !!isTouch
  };
  state.placementMode = itemId;
  document.getElementById('trash-zone').classList.add('visible');
}

function dragOffsetY() {
  return state.dragState.isTouch ? TOUCH_DRAG_OFFSET_Y : 0;
}

function updateDrag(sx, sy) {
  if (!state.dragState.active) return;
  state.dragState.screenX = sx;
  state.dragState.screenY = sy;
  // Check trash zone hover (use raw position for trash since it's under the finger)
  const trashEl = document.getElementById('trash-zone');
  const trashRect = trashEl.getBoundingClientRect();
  const inTrash = sx >= trashRect.left && sx <= trashRect.right &&
                  sy >= trashRect.top && sy <= trashRect.bottom;
  trashEl.classList.toggle('hover', inTrash);
}

function endDrag(sx, sy) {
  if (!state.dragState.active) return;
  const ds = state.dragState;

  // Check if dropped on trash zone
  const trashEl = document.getElementById('trash-zone');
  const trashRect = trashEl.getBoundingClientRect();
  const inTrash = sx >= trashRect.left && sx <= trashRect.right &&
                  sy >= trashRect.top && sy <= trashRect.bottom;

  if (inTrash && ds.fromPlaced && ds.fromPlacedIdx >= 0) {
    const removed = state.placedItems[ds.fromPlacedIdx];
    const item = FURNITURE.find(f => f.id === removed?.itemId);
    if (item?.exerciseRoom) {
      showToast("Can't remove the wheel! üé° The mice would riot.");
    } else if (removed) {
      state.placedItems.splice(ds.fromPlacedIdx, 1);
      showToast(`Removed ${item?.name || 'item'} üóë`);
      saveGame();
      refreshShopFlyout();
      refreshItemTray();
    }
    cancelPlacement();
    return;
  }

  // Try to place on canvas (apply touch offset so drop matches ghost preview)
  const pos = screenToGame(sx, sy + dragOffsetY());
  const item = FURNITURE.find(f => f.id === ds.itemId);
  if (!item) { cancelPlacement(); return; }
  // Use same centering as ghost preview
  const centerOffX = (item.w * GRID_SIZE) / 2;
  const centerOffY = (item.h * GRID_SIZE) / 2;
  const grid = gameToGrid(pos.x - centerOffX + SNAP_SIZE / 2, pos.y - centerOffY + SNAP_SIZE / 2);

  const excludeIdx = ds.fromPlaced ? ds.fromPlacedIdx : undefined;
  if (isPlacementValid(ds.itemId, grid.col, grid.row, excludeIdx)) {
    if (ds.fromPlaced && ds.fromPlacedIdx >= 0) {
      // Repositioning ‚Äî update existing entry
      state.placedItems[ds.fromPlacedIdx].gridX = grid.col;
      state.placedItems[ds.fromPlacedIdx].gridY = grid.row;
      sfxPlace();
      showToast(`Moved ${item.icon} ${item.name}!`);
    } else {
      // New placement
      const newEntry = {
        itemId: item.id, room: state.currentRoom,
        gridX: grid.col, gridY: grid.row
      };
      if (item.servings) newEntry.servings = item.servings;
      state.placedItems.push(newEntry);
      sfxPlace();
      showToast(`Placed ${item.icon} ${item.name}!`);
      addHappiness(3);
      state.stats.itemsPlaced++;
      reactToNewFurniture(item);
    }
    saveGame();
    refreshShopFlyout();
    refreshItemTray();
  } else {
    if (ds.fromPlaced) {
      // Repositioning failed ‚Äî item stays where it was (already still in array)
      showToast("Can't place there! üê≠");
    }
    // New placement from tray ‚Äî just cancel, item returns to tray
  }
  cancelPlacement();
}

function findPlacedItemAt(gx, gy) {
  const grid = gameToGrid(gx, gy);
  const idx = state.placedItems.findIndex(p => {
    if (p.room !== state.currentRoom) return false;
    const it = FURNITURE.find(f => f.id === p.itemId);
    if (!it) return false;
    return grid.col >= p.gridX && grid.col < p.gridX + it.w &&
           grid.row >= p.gridY && grid.row < p.gridY + it.h;
  });
  return idx;
}

// Wire up flyout buttons
document.getElementById('flyout-close-btn').addEventListener('click', closeShopFlyout);
document.getElementById('games-flyout-close').addEventListener('click', closeGamesFlyout);
document.getElementById('flyout-loot-btn').addEventListener('click', () => {
  lootCrumbs();
});

// Wire up tray drag events (delegated)
(function setupTrayDrag() {
  const tray = document.getElementById('item-tray');
  const DRAG_THRESHOLD = 10; // px before deciding scroll vs drag
  let pendingTouch = null; // { itemId, startX, startY, identifier }

  tray.addEventListener('mousedown', e => {
    const tile = e.target.closest('.tray-item');
    if (!tile) return;
    e.preventDefault();
    startDrag(tile.dataset.itemId, e.clientX, e.clientY, false, -1);
  });

  tray.addEventListener('touchstart', e => {
    const tile = e.target.closest('.tray-item');
    if (!tile) return;
    // Don't preventDefault yet ‚Äî let browser scroll if horizontal
    const t = e.touches[0];
    pendingTouch = {
      itemId: tile.dataset.itemId,
      startX: t.clientX,
      startY: t.clientY,
      identifier: t.identifier
    };
  }, { passive: true });

  tray.addEventListener('touchmove', e => {
    if (!pendingTouch) return;
    const t = Array.from(e.touches).find(tt => tt.identifier === pendingTouch.identifier);
    if (!t) return;
    const dx = Math.abs(t.clientX - pendingTouch.startX);
    const dy = t.clientY - pendingTouch.startY; // negative = finger moving up
    const ady = Math.abs(dy);
    if (ady > DRAG_THRESHOLD && dy < 0 && ady > dx) {
      // Upward drag (toward canvas) ‚Äî start item drag
      e.preventDefault();
      startDrag(pendingTouch.itemId, t.clientX, t.clientY, false, -1, true);
      pendingTouch = null;
    } else if (dx > DRAG_THRESHOLD || (ady > DRAG_THRESHOLD && dy > 0)) {
      // Horizontal swipe or downward scroll ‚Äî let browser handle
      pendingTouch = null;
    }
  }, { passive: false });

  tray.addEventListener('touchend', e => {
    if (!pendingTouch) return;
    // Touch ended without crossing threshold ‚Äî treat as tap to select
    const t = e.changedTouches[0];
    if (t && t.identifier === pendingTouch.identifier) {
      startPlacement(pendingTouch.itemId);
    }
    pendingTouch = null;
  }, { passive: true });

  tray.addEventListener('touchcancel', () => { pendingTouch = null; });
})();

// Horizontal mouse-wheel scrolling for the item tray (desktop)
document.getElementById('item-tray').addEventListener('wheel', e => {
  const tray = document.getElementById('item-tray');
  if (tray.scrollWidth > tray.clientWidth) {
    e.preventDefault();
    tray.scrollLeft += e.deltaY;
  }
}, { passive: false });

// Global mouse/touch move & up for drag
document.addEventListener('mousemove', e => {
  if (state.dragState.active) {
    e.preventDefault();
    updateDrag(e.clientX, e.clientY);
  }
});
document.addEventListener('touchmove', e => {
  if (state.dragState.active) {
    e.preventDefault();
    updateDrag(e.touches[0].clientX, e.touches[0].clientY);
  }
}, { passive: false });
document.addEventListener('mouseup', e => {
  if (state.dragState.active) {
    endDrag(e.clientX, e.clientY);
  }
});
document.addEventListener('touchend', e => {
  if (state.dragState.active) {
    const t = e.changedTouches[0];
    endDrag(t.clientX, t.clientY);
  }
});

function buyItem(itemId) {
  const item = FURNITURE.find(f => f.id === itemId);
  if (!item || state.coins < item.price) return;
  state.coins -= item.price;
  state.ownedItems.push(itemId);
  sfxBuy();
  updateCoinDisplay();
  saveGame();
  showToast(`Bought ${item.icon} ${item.name}! ${item.desc}`);
  refreshShopFlyout();
  refreshItemTray();
}

function lootCrumbs() {
  const unowned = FURNITURE.filter(f => !state.ownedItems.includes(f.id) && !f.birthday && !f.exerciseRoom);
  if (unowned.length === 0) {
    showToast('You own everything! Go touch grass. üå±');
    return;
  }
  const item = unowned[Math.floor(Math.random() * unowned.length)];
  state.ownedItems.push(item.id);
  state.lootCrumbsUsed++;
  sfxBuy();
  saveGame();
  showToast(`üéÅ Loot Crumb opened! You got: ${item.icon} ${item.name}!`);
  refreshShopFlyout();
  refreshItemTray();
}

// Wire up HUD buttons
document.getElementById('btn-shop').addEventListener('click', openShop);
document.getElementById('btn-games').addEventListener('click', openMinigames);
document.getElementById('btn-letter').addEventListener('click', openLetter);

// Exit button ‚Äî return to title screen
function exitToTitle() {
  saveGame();
  if (musicPlaying) stopMusic();
  state.gameStarted = false;
  document.getElementById('hud').style.display = 'none';
  document.getElementById('tray-toggle').style.display = 'none';
  document.getElementById('title-screen').style.display = 'flex';
  if (state.shopOpen) closeShopFlyout();
  if (gamesOpen) closeGamesFlyout();
  if (albumOpen) closeAlbumFlyout();
  if (trophyOpen) closeTrophyFlyout();
  if (trayOpen) closeTray();
  const om = document.getElementById('overflow-menu');
  if (om) om.classList.remove('open');
  hideBackdrop();
}
document.getElementById('btn-exit').addEventListener('click', exitToTitle);

// Overflow menu toggle (no longer used ‚Äî all buttons visible)
function toggleOverflowMenu() {
  const menu = document.getElementById('overflow-menu');
  if (!menu) return;
  const isOpen = menu.classList.contains('open');
  if (isOpen) {
    menu.classList.remove('open');
    hideBackdrop();
  } else {
    menu.classList.add('open');
    showBackdrop();
  }
}
// Close overflow when backdrop is tapped
document.getElementById('flyout-backdrop').addEventListener('click', () => {
  const menu = document.getElementById('overflow-menu');
  if (menu && menu.classList.contains('open')) {
    menu.classList.remove('open');
    hideBackdrop();
  }
});

// ============================================================
// MINI-GAME MENU (flyout)
// ============================================================
let gamesOpen = false;

function openMinigames() {
  if (gamesOpen) { closeGamesFlyout(); return; }
  gamesOpen = true;
  if (state.shopOpen) closeShopFlyout();
  if (albumOpen) closeAlbumFlyout();
  if (trophyOpen) closeTrophyFlyout();
  document.getElementById('games-flyout').classList.add('open');
  showBackdrop();
  document.getElementById('tray-toggle').classList.add('disabled');
}

function closeGamesFlyout() {
  gamesOpen = false;
  document.getElementById('games-flyout').classList.remove('open');
  if (!state.shopOpen && !albumOpen && !trophyOpen) document.getElementById('tray-toggle').classList.remove('disabled');
  if (!trayOpen && !state.shopOpen && !albumOpen && !trophyOpen) hideBackdrop();
}

// ============================================================
// CHEESE CHASE MINI-GAME
// ============================================================
let cheeseChaseActive = false;
let cc = {};
let ccInputY = null;

function startCheeseChase() {
  closeModal();
  closeGamesFlyout();
  if (trayOpen) closeTray();
  document.getElementById('tray-toggle').style.display = 'none';
  cheeseChaseActive = true;
  ccInputY = null;
  stopMusic();
  startChaseMusic();
  cc = {
    mouseY: GAME_H / 2,
    mouseVelY: 0,
    score: 0,
    obstacles: [],
    cheeses: [],
    blueberries: [],
    powerups: [],
    spawnTimer: 0,
    speed: 1.8,
    distance: 0,
    gameOver: false,
    bgStars: [],
    bgFloor: [],
    milestones: [],
    milestoneNext: 100,
    nearMisses: [],
    activePower: null,
    powerTimer: 0,
    heldKeys: { up: false, down: false },
    shieldFlash: 0,
    combo: 0,
    comboTimer: 0
  };
  for (let i = 0; i < 25; i++) {
    cc.bgStars.push({ x: Math.random() * GAME_W, y: Math.random() * GAME_H, s: 1 + Math.random() });
  }
  const floorTiles = Math.ceil(GAME_W / 40) + 1;
  for (let i = 0; i < floorTiles; i++) {
    cc.bgFloor.push({ x: i * 40, w: 38 + Math.random() * 4 });
  }
}

function updateCheeseChase(dt) {
  if (!cheeseChaseActive || cc.gameOver) return;

  cc.distance += cc.speed;
  cc.speed = 1.8 + cc.distance / 4000;
  gameMusicIntensity = Math.min(1, cc.distance / 8000);
  cc.spawnTimer -= dt;

  if (cc.comboTimer > 0) { cc.comboTimer -= dt; if (cc.comboTimer <= 0) cc.combo = 0; }
  if (cc.activePower) { cc.powerTimer -= dt; if (cc.powerTimer <= 0) cc.activePower = null; }
  if (cc.shieldFlash > 0) cc.shieldFlash -= dt;

  // Input: keyboard held keys override mouse/touch
  const kSpeed = 3.5;
  if (cc.heldKeys.up) cc.mouseVelY = -kSpeed;
  else if (cc.heldKeys.down) cc.mouseVelY = kSpeed;
  else if (ccInputY !== null) cc.mouseVelY = (ccInputY - cc.mouseY) * 0.12;
  else cc.mouseVelY *= 0.85;
  cc.mouseY += cc.mouseVelY;
  cc.mouseY = Math.max(18, Math.min(GAME_H - 18, cc.mouseY));

  // Distance milestones
  const distM = Math.floor(cc.distance / 10);
  if (distM >= cc.milestoneNext) {
    const labels = { 100:'100m! üî•', 250:'250m! üí®', 500:'500m! üèÜ', 750:'750m! üåü', 1000:'1000m! üëë', 1500:'1500m! üê≠üí™' };
    cc.milestones.push({ text: labels[cc.milestoneNext] || `${cc.milestoneNext}m! ‚≠ê`, timer: 2000, y: GAME_H / 2 - 40 });
    if (cc.milestoneNext < 500) cc.milestoneNext += 150;
    else if (cc.milestoneNext < 1000) cc.milestoneNext += 250;
    else cc.milestoneNext += 500;
  }
  cc.milestones.forEach(m => m.timer -= dt);
  cc.milestones = cc.milestones.filter(m => m.timer > 0);

  // Spawning
  if (cc.spawnTimer <= 0) {
    cc.spawnTimer = Math.max(180, 500 + Math.random() * 500 - Math.min(cc.distance / 50, 200));
    const roll = Math.random();
    if (roll < 0.30) {
      cc.cheeses.push({ x: GAME_W + 10, y: 30 + Math.random() * (GAME_H - 60), size: 14 });
    } else if (roll < 0.40) {
      cc.blueberries.push({ x: GAME_W + 10, y: 30 + Math.random() * (GAME_H - 60), bob: Math.random() * Math.PI * 2 });
    } else if (roll < 0.44 && !cc.activePower) {
      cc.powerups.push({ x: GAME_W + 10, y: 30 + Math.random() * (GAME_H - 60), type: Math.random() < 0.5 ? 'coffee' : 'magnet' });
    } else {
      spawnCCObstacle();
    }
  }

  // Move everything left
  const spd = cc.speed;
  cc.obstacles.forEach(o => { o.x -= spd; if (o.type === 'broom') o.sweepY = Math.sin(Date.now() / 300 + o.phase) * o.sweepAmp; if (o.type === 'puddle') o.ripple = (o.ripple || 0) + dt * 0.003; });
  cc.cheeses.forEach(c => c.x -= spd);
  cc.blueberries.forEach(b => { b.x -= spd; b.bob += dt * 0.004; });
  cc.powerups.forEach(p => p.x -= spd);
  cc.obstacles = cc.obstacles.filter(o => o.x > -60);
  cc.cheeses = cc.cheeses.filter(c => c.x > -20);
  cc.blueberries = cc.blueberries.filter(b => b.x > -20);
  cc.powerups = cc.powerups.filter(p => p.x > -20);

  // Magnet pull
  if (cc.activePower === 'magnet') {
    [...cc.cheeses, ...cc.blueberries].forEach(c => {
      const dx = 45 - c.x, dy = cc.mouseY - c.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 80 && dist > 2) { const pull = 2.5 / dist; c.x += dx * pull; c.y += dy * pull; }
    });
  }

  // Collision
  const mBox = { x: 35, y: cc.mouseY - 9, w: 24, h: 18 };

  cc.cheeses = cc.cheeses.filter(c => {
    if (boxOverlap(mBox, { x: c.x - 7, y: c.y - 7, w: 14, h: 14 })) {
      cc.combo++; cc.comboTimer = 1500;
      const pts = cc.combo >= 5 ? 3 : cc.combo >= 3 ? 2 : 1;
      cc.score += pts; sfxCheeseCollect();
      spawnFloatingEffect(c.x, c.y, pts > 1 ? `üßÄ√ó${pts}` : '‚ú®');
      return false;
    }
    return true;
  });

  cc.blueberries = cc.blueberries.filter(b => {
    if (boxOverlap(mBox, { x: b.x - 8, y: b.y - 8, w: 16, h: 16 })) {
      cc.combo++; cc.comboTimer = 1500;
      const pts = cc.combo >= 5 ? 5 : 3;
      cc.score += pts; sfxCheeseCollect();
      spawnFloatingEffect(b.x, b.y, `ü´ê+${pts}`);
      return false;
    }
    return true;
  });

  cc.powerups = cc.powerups.filter(p => {
    if (boxOverlap(mBox, { x: p.x - 8, y: p.y - 8, w: 16, h: 16 })) {
      cc.activePower = p.type;
      cc.powerTimer = p.type === 'coffee' ? 4000 : 5000;
      sfxCheeseCollect();
      spawnFloatingEffect(p.x, p.y, p.type === 'coffee' ? '‚òï SHIELD!' : 'üß≤ MAGNET!');
      return false;
    }
    return true;
  });

  for (const o of cc.obstacles) {
    const oBox = getCCObstacleBox(o);
    if (boxOverlap(mBox, oBox)) {
      if (cc.activePower === 'coffee') {
        cc.shieldFlash = 300;
        spawnFloatingEffect(o.x, cc.mouseY, 'üí•');
        o.x = -100;
      } else { cc.gameOver = true; sfxCrash(); break; }
    }
    // Near-miss
    if (!o.nearMissScored && o.x < 35 && o.x > 20) {
      const vertDist = Math.min(Math.abs(cc.mouseY - oBox.y), Math.abs(cc.mouseY - (oBox.y + oBox.h)));
      if (vertDist < 18 && !boxOverlap(mBox, oBox)) {
        o.nearMissScored = true; cc.score += 2;
        cc.nearMisses.push({ timer: 1200 });
        spawnFloatingEffect(50, cc.mouseY - 15, 'üòé+2');
      }
    }
  }

  cc.nearMisses.forEach(n => n.timer -= dt);
  cc.nearMisses = cc.nearMisses.filter(n => n.timer > 0);

  // Scroll floor boards
  cc.bgFloor.forEach(f => { f.x -= spd * 0.8; if (f.x < -45) f.x += Math.max(14, Math.ceil(GAME_W / 40) + 1) * 40; });
}

function spawnCCObstacle() {
  const distM = cc.distance / 10;
  const types = ['trap', 'cat'];
  if (distM > 80) types.push('broom');
  if (distM > 150) types.push('vacuum');
  if (distM > 50) types.push('puddle');
  const type = types[Math.floor(Math.random() * types.length)];
  const canMid = distM > 120;
  let y, h, w;
  switch (type) {
    case 'cat': h = 35 + Math.random() * 25; w = 28;
      y = (canMid && Math.random() < 0.3) ? 30 + Math.random() * (GAME_H - h - 60) : (Math.random() < 0.5 ? 0 : GAME_H - h); break;
    case 'trap': h = 25 + Math.random() * 50; w = 18;
      y = (canMid && Math.random() < 0.3) ? 30 + Math.random() * (GAME_H - h - 60) : (Math.random() < 0.5 ? 0 : GAME_H - h); break;
    case 'broom': h = 12; w = 50 + Math.random() * 30; y = 20 + Math.random() * (GAME_H - 60); break;
    case 'vacuum': h = 40; w = 45; y = Math.random() < 0.5 ? 5 : GAME_H - h - 5; break;
    case 'puddle': h = 16; w = 35 + Math.random() * 20; y = 20 + Math.random() * (GAME_H - 50); break;
  }
  cc.obstacles.push({ x: GAME_W + 10, y, w, h, type, phase: Math.random() * Math.PI * 2, sweepY: 0, sweepAmp: 20 + Math.random() * 25 });
}

function getCCObstacleBox(o) {
  if (o.type === 'broom') return { x: o.x, y: o.y + (o.sweepY || 0) - 6, w: o.w, h: o.h + 6 };
  return { x: o.x, y: o.y, w: o.w, h: o.h };
}

function boxOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

function drawCheeseChase() {
  if (!cheeseChaseActive) return;
  const t = Date.now() / 1000;

  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // Scrolling background dots
  cc.bgStars.forEach(s => {
    const sx = ((s.x - cc.distance * 0.2) % GAME_W + GAME_W) % GAME_W;
    ctx.fillStyle = 'rgba(245,214,138,0.15)';
    ctx.fillRect(sx, s.y, s.s, s.s);
  });

  // Floor boards
  ctx.fillStyle = '#2a1a0a';
  ctx.fillRect(0, GAME_H - 14, GAME_W, 14);
  cc.bgFloor.forEach(f => {
    ctx.fillStyle = '#3d2b1a';
    ctx.fillRect(f.x, GAME_H - 12, f.w, 10);
    ctx.fillStyle = '#2a1a0a';
    ctx.fillRect(f.x + f.w, GAME_H - 12, 2, 10);
  });
  ctx.fillStyle = '#5a3e28';
  ctx.fillRect(0, GAME_H - 16, GAME_W, 3);
  ctx.fillStyle = '#5a3e28';
  ctx.fillRect(0, 26, GAME_W, 3);
  ctx.fillStyle = '#3d2b1a';
  ctx.fillRect(0, 0, GAME_W, 5);

  // Obstacles
  cc.obstacles.forEach(o => {
    switch (o.type) {
      case 'cat': drawCCCat(o); break;
      case 'trap': drawCCTrap(o); break;
      case 'broom': drawCCBroom(o); break;
      case 'vacuum': drawCCVacuum(o); break;
      case 'puddle': drawCCPuddle(o); break;
    }
  });

  // Power-ups
  cc.powerups.forEach(p => {
    const bob = Math.sin(t * 3 + p.x * 0.1) * 3;
    ctx.fillStyle = p.type === 'coffee' ? 'rgba(255,180,80,0.2)' : 'rgba(80,180,255,0.2)';
    ctx.beginPath(); ctx.arc(p.x, p.y + bob, 14, 0, Math.PI * 2); ctx.fill();
    ctx.font = '16px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(p.type === 'coffee' ? '‚òï' : 'üß≤', p.x, p.y + bob);
    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  });

  // Cheese
  cc.cheeses.forEach(c => {
    ctx.fillStyle = 'rgba(255,215,0,0.15)';
    ctx.beginPath(); ctx.arc(c.x, c.y, 12, 0, Math.PI * 2); ctx.fill();
    ctx.font = '14px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('üßÄ', c.x, c.y);
    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  });

  // Blueberries
  cc.blueberries.forEach(b => {
    const bob = Math.sin(b.bob) * 3;
    ctx.fillStyle = 'rgba(100,100,255,0.2)';
    ctx.beginPath(); ctx.arc(b.x, b.y + bob, 12, 0, Math.PI * 2); ctx.fill();
    ctx.font = '14px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('ü´ê', b.x, b.y + bob);
    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  });

  // Player mouse with power-up effects
  const mFrame = Math.floor(cc.distance / 15) % 4;
  if (cc.activePower === 'coffee') {
    const pulse = 0.3 + Math.sin(t * 6) * 0.15;
    ctx.fillStyle = `rgba(255,180,60,${pulse})`;
    ctx.beginPath(); ctx.arc(47, cc.mouseY, 18, 0, Math.PI * 2); ctx.fill();
  }
  if (cc.activePower === 'magnet') {
    ctx.strokeStyle = `rgba(80,180,255,${0.3 + Math.sin(t * 5) * 0.15})`;
    ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.arc(47, cc.mouseY, 22 + Math.sin(t * 3) * 5, 0, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([]);
  }
  if (cc.shieldFlash > 0) {
    ctx.fillStyle = `rgba(255,200,60,${cc.shieldFlash / 300 * 0.4})`;
    ctx.fillRect(0, 0, GAME_W, GAME_H);
  }
  drawMouse(35, cc.mouseY - 10, CONFIG.mice.pip, 1, mFrame, 'walking');

  drawFloatingEffects();

  // Distance milestones
  cc.milestones.forEach(m => {
    const alpha = Math.min(1, m.timer / 500);
    const scale = m.timer > 1500 ? 1 + (2000 - m.timer) / 500 * 0.3 : 1.3;
    ctx.save(); ctx.globalAlpha = alpha;
    ctx.font = `${Math.floor(18 * scale)}px monospace`;
    ctx.fillStyle = '#f5d68a'; ctx.textAlign = 'center';
    ctx.fillText(m.text, GAME_W / 2, m.y);
    ctx.textAlign = 'left'; ctx.restore();
  });

  // Near miss flashes
  cc.nearMisses.forEach(n => {
    const alpha = n.timer / 1200;
    ctx.fillStyle = `rgba(100,255,100,${alpha * 0.3})`;
    ctx.fillRect(0, 0, GAME_W, 3);
    ctx.fillRect(0, GAME_H - 3, GAME_W, 3);
  });

  // HUD
  ctx.fillStyle = 'rgba(26,15,5,0.7)';
  ctx.fillRect(0, 0, GAME_W, 28);
  ctx.fillStyle = '#f5d68a';
  ctx.font = '11px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`‚≠ê${cc.score}`, 10, 19);
  if (cc.combo >= 3) { ctx.fillStyle = '#ffaa44'; ctx.fillText(`√ó${cc.combo}`, 55, 19); }
  ctx.fillStyle = '#f5d68a'; ctx.textAlign = 'center';
  ctx.fillText('CHEESE CHASE', GAME_W / 2, 12);
  ctx.fillStyle = '#a89070'; ctx.font = '10px monospace';
  ctx.fillText(`${Math.floor(cc.distance / 10)}m`, GAME_W / 2, 23);
  ctx.textAlign = 'right'; ctx.fillStyle = '#f5d68a'; ctx.font = '11px monospace';
  ctx.fillText(`‚ö°${cc.speed.toFixed(1)}x`, GAME_W - 50, 19);
  if (cc.activePower) {
    const pIcon = cc.activePower === 'coffee' ? '‚òï' : 'üß≤';
    const pSec = Math.ceil(cc.powerTimer / 1000);
    const blink = cc.powerTimer < 1500 && Math.floor(Date.now() / 200) % 2;
    if (!blink) ctx.fillText(`${pIcon}${pSec}s`, GAME_W - 50, 10);
  }
  // EXIT button
  ctx.fillStyle = 'rgba(180,100,100,0.7)';
  ctx.beginPath(); ctx.roundRect(GAME_W - 42, 4, 36, 18, 4); ctx.fill();
  ctx.fillStyle = '#fdd'; ctx.font = '10px monospace';
  ctx.fillText('EXIT', GAME_W - 24, 16);
  ctx.textAlign = 'left';

  // Game over overlay
  if (cc.gameOver) {
    ctx.fillStyle = 'rgba(26,15,5,0.8)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.fillStyle = '#f5d68a'; ctx.font = '28px monospace'; ctx.textAlign = 'center';
    ctx.fillText('ü™§ CAUGHT!', GAME_W / 2, GAME_H / 2 - 35);
    ctx.font = '14px monospace'; ctx.fillStyle = '#e8d5b5';
    ctx.fillText(`‚≠ê ${cc.score}  |  ${Math.floor(cc.distance / 10)}m`, GAME_W / 2, GAME_H / 2);
    const earned = cc.score * 2;
    ctx.fillStyle = '#f5d68a'; ctx.font = '16px monospace';
    ctx.fillText(`Earned: üßÄ ${earned} coins!`, GAME_W / 2, GAME_H / 2 + 25);
    ctx.fillStyle = '#a89070'; ctx.font = '12px monospace';
    ctx.fillText('press any key or tap to continue', GAME_W / 2, GAME_H / 2 + 55);
    ctx.textAlign = 'left';
  }
}

// --- Obstacle drawing helpers ---

function drawCCCat(o) {
  ctx.fillStyle = '#5a3020';
  ctx.beginPath(); ctx.roundRect(o.x, o.y, o.w, o.h, 4); ctx.fill();
  if (o.y === 0) { ctx.fillRect(o.x + 4, o.y + o.h - 2, 6, 8); ctx.fillRect(o.x + o.w - 10, o.y + o.h - 2, 6, 8); }
  else { ctx.fillRect(o.x + 4, o.y - 6, 6, 8); ctx.fillRect(o.x + o.w - 10, o.y - 6, 6, 8); }
  const eyeY = o.y === 0 ? o.y + o.h - 12 : o.y + 10;
  ctx.fillStyle = '#44ee44';
  ctx.beginPath(); ctx.ellipse(o.x + 8, eyeY, 2.5, 3, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(o.x + o.w - 8, eyeY, 2.5, 3, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1a0f05';
  ctx.fillRect(o.x + 7, eyeY - 2, 1.5, 4);
  ctx.fillRect(o.x + o.w - 9, eyeY - 2, 1.5, 4);
}

function drawCCTrap(o) {
  ctx.fillStyle = '#8B6914';
  ctx.fillRect(o.x, o.y, o.w, o.h);
  ctx.fillStyle = '#a08030';
  ctx.fillRect(o.x + 2, o.y + 2, o.w - 4, 4);
  ctx.strokeStyle = '#c0a050'; ctx.lineWidth = 1.5;
  const springBase = o.y === 0 ? o.y + o.h : o.y;
  ctx.beginPath();
  for (let i = 0; i < o.h; i += 6) {
    const sx = o.x + o.w / 2 + (i % 12 === 0 ? -4 : 4);
    ctx.lineTo(sx, springBase + (o.y === 0 ? -i : i));
  }
  ctx.stroke();
  ctx.font = '10px serif'; ctx.textAlign = 'center';
  ctx.fillText('‚ö†Ô∏è', o.x + o.w / 2, o.y + o.h / 2 + 4);
  ctx.textAlign = 'left';
}

function drawCCBroom(o) {
  const sy = o.y + (o.sweepY || 0);
  ctx.fillStyle = '#8B7355';
  ctx.fillRect(o.x + o.w - 6, sy - 30, 5, 30);
  ctx.fillStyle = '#DAA520';
  ctx.beginPath(); ctx.roundRect(o.x, sy - 4, o.w - 5, o.h, 2); ctx.fill();
  ctx.strokeStyle = '#B8860B'; ctx.lineWidth = 0.8;
  for (let i = 4; i < o.w - 8; i += 5) {
    ctx.beginPath(); ctx.moveTo(o.x + i, sy - 3); ctx.lineTo(o.x + i, sy + o.h - 2); ctx.stroke();
  }
  ctx.strokeStyle = 'rgba(218,165,32,0.3)'; ctx.lineWidth = 1;
  for (let i = 0; i < 3; i++) {
    ctx.beginPath(); ctx.moveTo(o.x - 8 - i * 6, sy + 2 + i * 3); ctx.lineTo(o.x - 2, sy + o.h / 2); ctx.stroke();
  }
}

function drawCCVacuum(o) {
  ctx.fillStyle = '#cc3333';
  ctx.beginPath(); ctx.roundRect(o.x, o.y, o.w, o.h, 8); ctx.fill();
  ctx.fillStyle = '#aa2222';
  ctx.fillRect(o.x + 5, o.y + o.h / 2 - 3, o.w - 10, 6);
  ctx.fillStyle = '#666';
  ctx.fillRect(o.x - 12, o.y + o.h / 2 - 5, 14, 10);
  ctx.fillStyle = '#444';
  ctx.fillRect(o.x - 15, o.y + o.h / 2 - 3, 5, 6);
  const st = Date.now() / 150;
  ctx.strokeStyle = 'rgba(200,200,200,0.3)'; ctx.lineWidth = 1;
  for (let i = 0; i < 4; i++) {
    const lx = o.x - 20 - ((st + i * 5) % 20);
    ctx.beginPath();
    ctx.moveTo(lx, o.y + o.h / 2 - 4); ctx.lineTo(lx - 4, o.y + o.h / 2); ctx.lineTo(lx, o.y + o.h / 2 + 4);
    ctx.stroke();
  }
  ctx.fillStyle = '#333';
  ctx.beginPath(); ctx.arc(o.x + 10, o.y + o.h, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(o.x + o.w - 10, o.y + o.h, 4, 0, Math.PI * 2); ctx.fill();
}

function drawCCPuddle(o) {
  const r = o.ripple || 0;
  ctx.fillStyle = 'rgba(80,140,220,0.35)';
  ctx.beginPath(); ctx.ellipse(o.x + o.w / 2, o.y + o.h / 2, o.w / 2, o.h / 2 + 2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = 'rgba(120,180,255,0.25)'; ctx.lineWidth = 0.8;
  for (let i = 0; i < 2; i++) {
    const rr = ((r + i * 0.5) % 1) * o.w / 2;
    ctx.beginPath(); ctx.ellipse(o.x + o.w / 2, o.y + o.h / 2, rr, rr * 0.5, 0, 0, Math.PI * 2); ctx.stroke();
  }
  ctx.fillStyle = 'rgba(200,230,255,0.3)';
  ctx.beginPath(); ctx.ellipse(o.x + o.w / 2 - 4, o.y + o.h / 2 - 2, 4, 2, -0.3, 0, Math.PI * 2); ctx.fill();
}

function endCheeseChase() {
  stopGameMusic();
  const earned = cc.score * 2;
  state.coins += earned;
  state.totalCoinsEarned += earned;
  addHappiness(5);
  updateCoinDisplay();
  state.stats.gamesPlayed.chase++;
  if (Math.floor(cc.distance / 10) >= 500) unlockAchievement('speed-runner');
  checkAchievements();
  saveGame();
  cheeseChaseActive = false;
  document.getElementById('tray-toggle').style.display = 'flex';
  startMusic();
  sfxCoinCollect();
  spawnCoinEffect(earned, GAME_W / 2, GAME_H / 2 - 20);
  showToast(`Cheese Chase: earned üßÄ ${earned} coins!`);
}

function handleCCInput(sx, sy) {
  const pos = screenToGame(sx, sy);
  if (pos.x >= GAME_W - 42 && pos.x <= GAME_W - 6 && pos.y >= 4 && pos.y <= 22) {
    endCheeseChase(); return;
  }
  if (cc.gameOver) { endCheeseChase(); return; }
  ccInputY = pos.y;
}

// ============================================================
// DOOMSCROLL MINI-GAME
// ============================================================
const DOOMSCROLL_POSTS = [
  // Good posts ‚Äî like these!
  { text: 'mice are literally the best pets no cap üê≠', good: true, user: '@mousewhisperer' },
  { text: 'just found the BIGGEST cheese wheel at Costco', good: true, user: '@cheeseenthusiast' },
  { text: 'my mouse learned to high five today ü•∫', good: true, user: '@tinypaws' },
  { text: 'cheese board appreciation post üßÄ‚ú®', good: true, user: '@cheeseboard_daily' },
  { text: 'reminder: you are loved and valid üíõ', good: true, user: '@wholesomemouse' },
  { text: `${CONFIG.mice.pip.name} and ${CONFIG.mice.chai.name} fan account üê≠üê≠`, good: true, user: '@mouse_stan' },
  { text: 'POV: the mouse found the cheese stash', good: true, user: '@mousemoments' },
  { text: 'tiny mouse in a tiny hat. that\'s it. that\'s the post.', good: true, user: '@tinyhat' },
  { text: 'cozy mouse house tour üè†üê≠ (it\'s perfect)', good: true, user: '@cozymouse' },
  { text: 'petition to make mice the national animal', good: true, user: '@mouseactivist' },
  { text: 'just watched a mouse do yoga and now I believe in god', good: true, user: '@spiritual_mouse' },
  { text: 'normalize napping 14 hours a day (I am a mouse)', good: true, user: '@sleepymouse' },
  { text: 'cheese is just milk that believed in itself üßÄ', good: true, user: '@deepcheese' },
  // Bad posts ‚Äî skip these!
  { text: 'actually, mice are mid', good: false, user: '@wrongopinions' },
  { text: 'hot take: cheese is overrated', good: false, user: '@controversialcarl' },
  { text: 'reply guys assemble ü§ì‚òùÔ∏è', good: false, user: '@replyguy47' },
  { text: 'imagine not having a sigma grindset in 2026', good: false, user: '@sigmagrinder' },
  { text: 'I mass-followed 10,000 accounts for clout', good: false, user: '@followback' },
  { text: 'this u? ü§®üì∏', good: false, user: '@exposed' },
  { text: 'I did my own research (watched 2 youtube videos)', good: false, user: '@truthseeker99' },
  { text: 'brand account trying to be relatable: slay bestie', good: false, user: '@megacorp_official' },
  { text: 'ratio + L + no cheese', good: false, user: '@ratioenjoyer' },
  { text: 'who asked? (I am very lonely)', good: false, user: '@whoasked' },
  { text: 'wake up at 4am or you\'re a failure (I am unwell)', good: false, user: '@hustleculture' },
  { text: 'my toxic trait is thinking I\'m the main character', good: false, user: '@toxicmain' },
  { text: 'vibe check: you failed. rip bozo.', good: false, user: '@vibechecker' },
];

let dsActive = false;
let ds = {};

function startDoomscroll() {
  closeModal();
  closeGamesFlyout();
  if (trayOpen) closeTray();
  document.getElementById('tray-toggle').style.display = 'none';
  dsActive = true;
  stopMusic();
  startLofiMusic();
  const shuffled = [...DOOMSCROLL_POSTS].sort(() => Math.random() - 0.5);
  ds = {
    posts: shuffled.slice(0, 10),
    current: 0,
    score: 0,
    strikes: 0,
    maxStrikes: 3,
    finished: false,
    feedback: null
  };
  renderDoomscroll();
}

function renderDoomscroll() {
  if (!dsActive) return;
  const container = document.getElementById('modal-container');

  if (ds.finished) {
    const earned = ds.score * 3;
    state.coins += earned;
    state.totalCoinsEarned += earned;
    addHappiness(4);
    updateCoinDisplay();
    spawnCoinEffect(earned);
    sfxCoinCollect();
    state.stats.gamesPlayed.doomscroll++;
    if (ds.score >= 15 && ds.strikes === 0) unlockAchievement('doomscroll-detox');
    checkAchievements();
    saveGame();

    container.innerHTML = `<div class="modal-overlay">
      <div class="modal-content" style="min-width:300px;max-width:420px;">
        <h2>üì± Doomscroll Complete!</h2>
        <p style="text-align:center;font-size:15px;color:#f5d68a;margin:14px 0;">
          Good posts liked: ${ds.score} ‚úÖ<br>
          Cringe posts liked: ${ds.strikes} üò¨<br><br>
          <span style="font-size:18px;">Earned: üßÄ ${earned} cheese coins!</span>
        </p>
        <p style="text-align:center;color:#a89070;font-size:11px;">
          ${ds.strikes === 0 ? 'Perfect feed! Your algorithm is immaculate.' :
            ds.strikes >= 3 ? 'Touch grass immediately. üå±' :
            'Not bad, but maybe log off for a bit.'}
        </p>
        <button class="close-btn" onclick="dsActive=false;stopGameMusic();startMusic();document.getElementById('tray-toggle').style.display='flex';closeModal()">Nice</button>
      </div>
    </div>`;
    return;
  }

  const post = ds.posts[ds.current];
  const strikeDisplay = '‚ùå'.repeat(ds.strikes) + '‚¨ú'.repeat(ds.maxStrikes - ds.strikes);

  container.innerHTML = `<div class="modal-overlay">
    <div class="modal-content" style="min-width:300px;max-width:440px;">
      <h2>üì± Doomscroll</h2>
      <p style="text-align:center;color:#a89070;font-size:11px;margin-bottom:6px;">
        Post ${ds.current + 1} of ${ds.posts.length} &nbsp;|&nbsp; üßÄ ${ds.score * 3} earned &nbsp;|&nbsp; ${strikeDisplay}
      </p>
      ${ds.feedback ? `<p style="text-align:center;font-size:13px;margin:6px 0;color:${ds.feedback.color};">${ds.feedback.text}</p>` : ''}
      <div class="doomscroll-post" style="margin:14px 0;">
        <div class="post-user">${post.user}</div>
        <div class="post-text" style="font-size:14px;margin-top:6px;">${post.text}</div>
      </div>
      <div style="display:flex;gap:10px;justify-content:center;margin-top:10px;">
        <button class="minigame-btn" onclick="doomscrollAction(true)" style="width:42%;">
          ‚ù§Ô∏è Like
        </button>
        <button class="minigame-btn" onclick="doomscrollAction(false)" style="width:42%;">
          ‚è≠ Skip
        </button>
      </div>
      <p style="text-align:center;color:#6b5030;font-size:10px;margin-top:8px;">
        Like the good posts. Skip the cringe. 3 strikes = game over.
      </p>
    </div>
  </div>`;
}

function doomscrollAction(liked) {
  const post = ds.posts[ds.current];

  if (liked && post.good) {
    ds.score++;
    ds.feedback = { text: '‚úÖ Based! +3 üßÄ', color: '#7bc67e' };
    sfxGoodLike();
  } else if (liked && !post.good) {
    ds.strikes++;
    ds.feedback = { text: 'üò¨ Yikes, you liked cringe!', color: '#e06050' };
    sfxBadLike();
  } else if (!liked && post.good) {
    ds.feedback = { text: 'üò¢ You skipped a good one!', color: '#e8a040' };
    sfxUIClick();
  } else {
    ds.feedback = { text: 'üëç Good skip, that was cringe', color: '#7bc67e' };
    sfxGoodLike();
  }

  ds.current++;
  gameMusicIntensity = Math.min(1, ds.strikes / ds.maxStrikes);
  if (ds.current >= ds.posts.length || ds.strikes >= ds.maxStrikes) {
    ds.finished = true;
    stopGameMusic();
    startMusic();
  }
  renderDoomscroll();
}

// ============================================================
// WHACK-A-CAT MINI-GAME
// ============================================================
let whackACatActive = false;
let wac = {};

function startWhackACat() {
  closeModal();
  closeGamesFlyout();
  if (trayOpen) closeTray();
  document.getElementById('tray-toggle').style.display = 'none';
  whackACatActive = true;
  stopMusic();
  startWhackMusic();
  wac = {
    score: 0,
    misses: 0,
    maxMisses: 5,
    holes: [],
    cats: [],
    bonks: [],
    cheeses: [],
    timer: 45000,
    spawnTimer: 0,
    spawnInterval: 1200,
    gameOver: false,
    combo: 0,
    comboTimer: 0,
    cheerTimer: 0,
    cheerText: '',
    level: 1,
    catsWhacked: 0
  };
  // 9 holes in 3√ó3 grid
  const cols = 3, rows = 3;
  const gapX = GAME_W / (cols + 1);
  const gapY = (GAME_H - 60) / (rows + 1);
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      wac.holes.push({ x: gapX * (c + 1), y: 55 + gapY * (r + 1), cat: null });
    }
  }
}

function updateWhackACat(dt) {
  if (!whackACatActive) return;
  if (wac.gameOver) {
    if (wac.gameOverDelay > 0) wac.gameOverDelay -= dt;
    return;
  }

  wac.timer -= dt;
  if (wac.timer <= 0) { wac.gameOver = true; wac.gameOverDelay = 800; return; }

  if (wac.comboTimer > 0) { wac.comboTimer -= dt; if (wac.comboTimer <= 0) wac.combo = 0; }
  if (wac.cheerTimer > 0) wac.cheerTimer -= dt;

  // Difficulty ramp
  const elapsed = 45000 - wac.timer;
  if (elapsed > 30000) wac.level = 3;
  else if (elapsed > 15000) wac.level = 2;
  wac.spawnInterval = wac.level === 1 ? 1200 : wac.level === 2 ? 900 : 650;
  gameMusicIntensity = Math.min(1, elapsed / 40000);

  // Spawn cats
  wac.spawnTimer -= dt;
  if (wac.spawnTimer <= 0) {
    wac.spawnTimer = wac.spawnInterval * (0.7 + Math.random() * 0.6);
    const emptyHoles = wac.holes.filter(h => !h.cat);
    if (emptyHoles.length > 0) {
      const hole = emptyHoles[Math.floor(Math.random() * emptyHoles.length)];
      const isCheese = Math.random() < 0.15;
      const popDuration = isCheese ? 2500 : (wac.level === 1 ? 2000 : wac.level === 2 ? 1500 : 1000);
      hole.cat = {
        type: isCheese ? 'cheese' : (Math.random() < 0.2 ? 'golden' : 'normal'),
        popTimer: popDuration,
        maxPop: popDuration,
        riseAnim: 0,
        bonked: false
      };
    }
    // Spawn 2 at once in later levels
    if (wac.level >= 2 && Math.random() < 0.4) {
      const emptyHoles2 = wac.holes.filter(h => !h.cat);
      if (emptyHoles2.length > 0) {
        const hole2 = emptyHoles2[Math.floor(Math.random() * emptyHoles2.length)];
        const dur2 = wac.level === 2 ? 1500 : 1000;
        hole2.cat = { type: Math.random() < 0.25 ? 'golden' : 'normal', popTimer: dur2, maxPop: dur2, riseAnim: 0, bonked: false };
      }
    }
  }

  // Update cats in holes
  wac.holes.forEach(h => {
    if (!h.cat) return;
    const cat = h.cat;
    cat.riseAnim = Math.min(1, cat.riseAnim + dt * 0.005);
    cat.popTimer -= dt;
    if (cat.popTimer <= 0 && !cat.bonked) {
      if (cat.type !== 'cheese') {
        wac.misses++;
        if (wac.misses >= wac.maxMisses) { wac.gameOver = true; wac.gameOverDelay = 800; }
      }
      h.cat = null;
    } else if (cat.bonked && cat.popTimer <= 0) {
      h.cat = null;
    }
  });

  // Update bonk effects
  wac.bonks.forEach(b => b.timer -= dt);
  wac.bonks = wac.bonks.filter(b => b.timer > 0);
}

function handleWhackInput(sx, sy) {
  const pos = screenToGame(sx, sy);

  // Exit button
  if (pos.x >= GAME_W - 42 && pos.x <= GAME_W - 6 && pos.y >= 4 && pos.y <= 22) {
    endWhackACat(); return;
  }
  if (wac.gameOver) { if (wac.gameOverDelay <= 0) endWhackACat(); return; }

  // Check hole hits
  const hitRadius = 32;
  for (const h of wac.holes) {
    if (!h.cat || h.cat.bonked) continue;
    const dx = pos.x - h.x, dy = pos.y - h.y;
    if (dx * dx + dy * dy < hitRadius * hitRadius) {
      const cat = h.cat;
      if (cat.type === 'cheese') {
        // Penalty for hitting cheese
        wac.misses++;
        wac.combo = 0;
        wac.bonks.push({ x: h.x, y: h.y, timer: 600, text: 'üò¢ -1', color: '#e06050' });
        cat.bonked = true;
        cat.popTimer = 400;
        sfxCrash();
        if (wac.misses >= wac.maxMisses) { wac.gameOver = true; wac.gameOverDelay = 800; }
      } else {
        // Bonk the cat!
        cat.bonked = true;
        cat.popTimer = 400;
        wac.combo++;
        wac.comboTimer = 2000;
        wac.catsWhacked++;
        const pts = cat.type === 'golden' ? 5 : (wac.combo >= 5 ? 3 : wac.combo >= 3 ? 2 : 1);
        wac.score += pts;
        sfxCheeseCollect();
        const label = cat.type === 'golden' ? `‚≠ê+${pts}` : (pts > 1 ? `üí•√ó${pts}` : 'üí•');
        wac.bonks.push({ x: h.x, y: h.y - 15, timer: 800, text: label, color: '#f5d68a' });

        // Cheer from mice
        if (wac.catsWhacked % 5 === 0) {
          const cheers = ['get rekt cat! üò§', 'BONK üî®', 'lmaooo üê≠', 'no cats allowed!', 'skill issue üòé',
            'ratio + L + bonked', 'certified bonker üí™', 'cat down! üìâ', '*pip approves* ‚ú®'];
          wac.cheerText = cheers[Math.floor(Math.random() * cheers.length)];
          wac.cheerTimer = 2000;
        }
      }
      return;
    }
  }
}

function drawWhackACat() {
  if (!whackACatActive) return;
  const t = Date.now() / 1000;

  // Grassy background
  ctx.fillStyle = '#1a2a10';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // Grass texture
  for (let i = 0; i < GAME_W; i += 8) {
    const gh = 3 + Math.sin(i * 0.5 + t) * 1.5;
    ctx.fillStyle = `rgba(60,120,40,${0.3 + Math.sin(i * 0.3) * 0.1})`;
    ctx.fillRect(i, GAME_H - gh, 4, gh);
  }

  // Draw holes and cats
  wac.holes.forEach(h => {
    // Hole shadow
    ctx.fillStyle = '#0a0a05';
    ctx.beginPath();
    ctx.ellipse(h.x, h.y + 8, 26, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hole body
    ctx.fillStyle = '#1a1008';
    ctx.beginPath();
    ctx.ellipse(h.x, h.y + 4, 24, 14, 0, 0, Math.PI * 2);
    ctx.fill();

    // Dirt rim
    ctx.strokeStyle = '#5a3e20';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.ellipse(h.x, h.y + 4, 24, 14, 0, 0, Math.PI * 2);
    ctx.stroke();

    if (h.cat) {
      const cat = h.cat;
      const rise = cat.bonked ? Math.max(0, cat.riseAnim - 0.3) : Math.min(1, cat.riseAnim);
      const yOff = (1 - rise) * 28;

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(h.x, h.y + 4, 23, 13, 0, 0, Math.PI * 2);
      ctx.clip();

      if (cat.type === 'cheese') {
        // Cheese decoy ‚Äî draw cheese wedge popping up
        const cy = h.y - 8 + yOff;
        ctx.font = '22px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üßÄ', h.x, cy);
        ctx.fillStyle = 'rgba(255,215,0,0.15)';
        ctx.beginPath();
        ctx.arc(h.x, cy, 16, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Cat head
        const cy = h.y - 6 + yOff;
        const isGolden = cat.type === 'golden';
        const headColor = isGolden ? '#DAA520' : '#5a3020';
        const earColor = isGolden ? '#B8860B' : '#3d1a0a';

        // Head
        ctx.fillStyle = headColor;
        ctx.beginPath();
        ctx.arc(h.x, cy, 14, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.fillStyle = earColor;
        ctx.beginPath();
        ctx.moveTo(h.x - 12, cy - 8);
        ctx.lineTo(h.x - 6, cy - 18);
        ctx.lineTo(h.x - 2, cy - 6);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(h.x + 12, cy - 8);
        ctx.lineTo(h.x + 6, cy - 18);
        ctx.lineTo(h.x + 2, cy - 6);
        ctx.fill();

        if (cat.bonked) {
          // Dizzy eyes
          ctx.font = '8px monospace';
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.fillText('‚úï', h.x - 5, cy + 1);
          ctx.fillText('‚úï', h.x + 5, cy + 1);
        } else {
          // Evil eyes
          ctx.fillStyle = isGolden ? '#ff4444' : '#44ee44';
          ctx.beginPath();
          ctx.ellipse(h.x - 5, cy - 1, 3, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(h.x + 5, cy - 1, 3, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          // Slit pupils
          ctx.fillStyle = '#000';
          ctx.fillRect(h.x - 5.7, cy - 3.5, 1.5, 5);
          ctx.fillRect(h.x + 4.2, cy - 3.5, 1.5, 5);
        }

        // Nose
        ctx.fillStyle = '#ff9999';
        ctx.beginPath();
        ctx.arc(h.x, cy + 5, 2, 0, Math.PI * 2);
        ctx.fill();

        // Golden glow
        if (isGolden && !cat.bonked) {
          ctx.strokeStyle = `rgba(255,215,0,${0.4 + Math.sin(t * 5) * 0.2})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(h.x, cy, 17, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      ctx.restore();

      // Pop timer bar (only for alive cats, not cheese)
      if (!cat.bonked && cat.type !== 'cheese') {
        const barW = 30;
        const frac = cat.popTimer / cat.maxPop;
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(h.x - barW / 2, h.y + 18, barW, 3);
        ctx.fillStyle = frac > 0.3 ? '#6c6' : '#e55';
        ctx.fillRect(h.x - barW / 2, h.y + 18, barW * frac, 3);
      }
    }
  });

  // Bonk effects
  wac.bonks.forEach(b => {
    const alpha = b.timer / 800;
    const rise = (800 - b.timer) * 0.03;
    ctx.font = '14px monospace';
    ctx.fillStyle = b.color || '#f5d68a';
    ctx.globalAlpha = alpha;
    ctx.textAlign = 'center';
    ctx.fillText(b.text, b.x, b.y - rise);
    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';
  });

  // Mouse cheerleaders (Pip and Chai on the sides)
  const pipFrame = Math.floor(t * 4) % 4;
  drawMouse(8, GAME_H - 35, CONFIG.mice.pip, 1, pipFrame, 'idle');
  drawMouse(GAME_W - 32, GAME_H - 35, CONFIG.mice.chai, -1, pipFrame, 'idle');

  // Cheer text
  if (wac.cheerTimer > 0) {
    const alpha = Math.min(1, wac.cheerTimer / 500);
    ctx.globalAlpha = alpha;
    ctx.font = '12px monospace';
    ctx.fillStyle = '#f5d68a';
    ctx.textAlign = 'center';
    ctx.fillText(wac.cheerText, GAME_W / 2, GAME_H - 15);
    ctx.textAlign = 'left';
    ctx.globalAlpha = 1;
  }

  // HUD
  ctx.fillStyle = 'rgba(26,20,10,0.75)';
  ctx.fillRect(0, 0, GAME_W, 28);
  ctx.fillStyle = '#f5d68a';
  ctx.font = '11px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`‚≠ê${wac.score}`, 10, 19);
  if (wac.combo >= 3) {
    ctx.fillStyle = '#ffaa44';
    ctx.fillText(`√ó${wac.combo}`, 55, 19);
  }
  ctx.fillStyle = '#f5d68a';
  ctx.textAlign = 'center';
  ctx.fillText('WHACK-A-CAT', GAME_W / 2, 12);
  // Timer
  const secs = Math.max(0, Math.ceil(wac.timer / 1000));
  ctx.fillStyle = secs <= 10 ? '#e06050' : '#a89070';
  ctx.font = '10px monospace';
  ctx.fillText(`${secs}s`, GAME_W / 2, 23);
  // Misses (hearts)
  ctx.textAlign = 'right';
  ctx.fillStyle = '#f5d68a';
  ctx.font = '11px monospace';
  let hearts = '';
  for (let i = 0; i < wac.maxMisses; i++) hearts += i < wac.maxMisses - wac.misses ? '‚ù§Ô∏è' : 'üñ§';
  ctx.fillText(hearts, GAME_W - 50, 19);
  // EXIT
  ctx.fillStyle = 'rgba(180,100,100,0.7)';
  ctx.beginPath(); ctx.roundRect(GAME_W - 42, 4, 36, 18, 4); ctx.fill();
  ctx.fillStyle = '#fdd'; ctx.font = '10px monospace';
  ctx.fillText('EXIT', GAME_W - 24, 16);
  ctx.textAlign = 'left';

  // Game over overlay
  if (wac.gameOver) {
    ctx.fillStyle = 'rgba(10,15,5,0.85)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.textAlign = 'center';
    const outOfTime = wac.timer <= 0;
    ctx.fillStyle = '#f5d68a'; ctx.font = '24px monospace';
    ctx.fillText(outOfTime ? '‚è∞ Time\'s Up!' : 'üòø Too Many Escapes!', GAME_W / 2, GAME_H / 2 - 40);
    ctx.font = '14px monospace'; ctx.fillStyle = '#e8d5b5';
    ctx.fillText(`Cats bonked: ${wac.catsWhacked}  |  ‚≠ê ${wac.score} pts`, GAME_W / 2, GAME_H / 2 - 5);
    const earned = wac.score * 2;
    ctx.fillStyle = '#f5d68a'; ctx.font = '16px monospace';
    ctx.fillText(`Earned: üßÄ ${earned} coins!`, GAME_W / 2, GAME_H / 2 + 25);
    ctx.fillStyle = '#a89070'; ctx.font = '12px monospace';
    ctx.fillText('press any key or tap to finish', GAME_W / 2, GAME_H / 2 + 55);
    ctx.textAlign = 'left';
  }
}

function endWhackACat() {
  stopGameMusic();
  const earned = wac.score * 2;
  state.coins += earned;
  state.totalCoinsEarned += earned;
  addHappiness(6);
  updateCoinDisplay();
  state.stats.gamesPlayed.whack++;
  if (wac.catsWhacked >= 30) unlockAchievement('cat-bonker');
  checkAchievements();
  saveGame();
  whackACatActive = false;
  document.getElementById('tray-toggle').style.display = 'flex';
  startMusic();
  sfxCoinCollect();
  spawnCoinEffect(earned, GAME_W / 2, GAME_H / 2 - 20);
  showToast(`Whack-a-Cat: earned üßÄ ${earned} coins!`);
}

// ============================================================
// PAC MOUSE MINI-GAME
// ============================================================
let mouseMazeActive = false;
let mz = {};

function generateMaze(cols, rows) {
  // Recursive backtracker algorithm
  const grid = [];
  for (let r = 0; r < rows; r++) {
    grid[r] = [];
    for (let c = 0; c < cols; c++) {
      grid[r][c] = { top: true, right: true, bottom: true, left: true, visited: false };
    }
  }
  const stack = [];
  let cur = { r: 0, c: 0 };
  grid[0][0].visited = true;
  const dirs = [
    { dr: -1, dc: 0, wall: 'top', opp: 'bottom' },
    { dr: 1, dc: 0, wall: 'bottom', opp: 'top' },
    { dr: 0, dc: -1, wall: 'left', opp: 'right' },
    { dr: 0, dc: 1, wall: 'right', opp: 'left' }
  ];
  function neighbors(r, c) {
    return dirs.filter(d => {
      const nr = r + d.dr, nc = c + d.dc;
      return nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].visited;
    });
  }
  let totalVisited = 1;
  const totalCells = rows * cols;
  while (totalVisited < totalCells) {
    const nb = neighbors(cur.r, cur.c);
    if (nb.length > 0) {
      const pick = nb[Math.floor(Math.random() * nb.length)];
      stack.push(cur);
      grid[cur.r][cur.c][pick.wall] = false;
      cur = { r: cur.r + pick.dr, c: cur.c + pick.dc };
      grid[cur.r][cur.c][pick.opp] = false;
      grid[cur.r][cur.c].visited = true;
      totalVisited++;
    } else {
      cur = stack.pop();
    }
  }
  // Open many extra walls to create loops (Pac-Man-like open layout)
  const extraOpenings = Math.floor(cols * rows * 0.45);
  for (let i = 0; i < extraOpenings; i++) {
    const r = Math.floor(Math.random() * rows);
    const c = Math.floor(Math.random() * cols);
    const d = dirs[Math.floor(Math.random() * dirs.length)];
    const nr = r + d.dr, nc = c + d.dc;
    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
      grid[r][c][d.wall] = false;
      grid[nr][nc][d.opp] = false;
    }
  }
  return grid;
}

function startMouseMaze() {
  closeModal();
  closeGamesFlyout();
  if (trayOpen) closeTray();
  document.getElementById('tray-toggle').style.display = 'none';
  mouseMazeActive = true;
  stopMusic();
  startMazeMusic();
  showMazeDpad();
  mz = {
    level: 1,
    totalScore: 0,
    totalBerries: 0,
    lives: 3
  };
  initMazeLevel(mz.level);
}

function initMazeLevel(level) {
  gameMusicIntensity = (level - 1) / 2;
  const cols = 8 + level * 2;   // 10, 12, 14
  const rows = 6 + level;       // 7, 8, 9
  const grid = generateMaze(cols, rows);
  const cellW = Math.floor((GAME_W - 20) / cols);
  const cellH = Math.floor((GAME_H - 50) / rows);
  const cellSize = Math.min(cellW, cellH, 36);
  const mazeW = cols * cellSize;
  const mazeH = rows * cellSize;
  const ox = Math.floor((GAME_W - mazeW) / 2);
  const oy = Math.floor((GAME_H - 30 - mazeH) / 2) + 28;

  // Place blueberries in every cell except start
  const berries = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (r === 0 && c === 0) continue;
      berries.push({ r, c, collected: false, isPower: false });
    }
  }

  // Place 2-3 power cheese (replace some berries)
  const numPower = 2 + (level > 2 ? 1 : 0);
  const powerCandidates = berries.filter(b =>
    !(b.r === 0 && b.c <= 1) && !(b.r <= 1 && b.c === 0));
  powerCandidates.sort(() => Math.random() - 0.5);
  for (let i = 0; i < Math.min(numPower, powerCandidates.length); i++) {
    powerCandidates[i].isPower = true;
  }

  // Cat starts at bottom-right corner
  const catStartR = rows - 1, catStartC = cols - 1;

  Object.assign(mz, {
    grid, cols, rows, cellSize, ox, oy,
    playerR: 0, playerC: 0,
    playerDir: 'right', nextDir: null,
    berries,
    totalBerriesThisLevel: berries.length,
    cat: { r: catStartR, c: catStartC, dir: 'left', moveTimer: 0,
           scared: false, scareTimer: 0, eaten: false, respawnTimer: 0,
           startR: catStartR, startC: catStartC },
    catSpeed: 320 - level * 50,  // ms per move: 270, 220, 170
    catGraceTimer: 3000,  // 3s before cat starts chasing
    powerTimer: 0,
    moves: 0,
    startTime: Date.now(),
    elapsed: 0,
    levelComplete: false,
    gameOver: false,
    deathPause: 0,
    animX: 0, animY: 0,
    moveTimer: 0,
    moveInterval: 85, // ms per continuous move
    heldKeys: { up: false, down: false, left: false, right: false }
  });
}

// BFS pathfinding for cat AI
function mazeBFS(grid, fromR, fromC, toR, toC, rows, cols) {
  if (fromR === toR && fromC === toC) return null;
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  const queue = [{ r: fromR, c: fromC, firstDir: null }];
  visited[fromR][fromC] = true;
  const dirMap = [
    { dr: -1, dc: 0, wall: 'top', name: 'up' },
    { dr: 1, dc: 0, wall: 'bottom', name: 'down' },
    { dr: 0, dc: -1, wall: 'left', name: 'left' },
    { dr: 0, dc: 1, wall: 'right', name: 'right' }
  ];
  while (queue.length > 0) {
    const cur = queue.shift();
    for (const d of dirMap) {
      const nr = cur.r + d.dr, nc = cur.c + d.dc;
      if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
      if (visited[nr][nc]) continue;
      if (grid[cur.r][cur.c][d.wall]) continue;
      visited[nr][nc] = true;
      const first = cur.firstDir || d.name;
      if (nr === toR && nc === toC) return first;
      queue.push({ r: nr, c: nc, firstDir: first });
    }
  }
  return null;
}

function updateMouseMaze(dt) {
  if (!mouseMazeActive) return;

  // Death pause
  if (mz.deathPause > 0) {
    mz.deathPause -= dt;
    if (mz.deathPause <= 0) {
      if (mz.lives <= 0) {
        mz.gameOver = true;
      } else {
        // Reset positions
        mz.playerR = 0; mz.playerC = 0;
        mz.playerDir = 'right'; mz.nextDir = null;
        mz.animX = 0; mz.animY = 0;
        mz.cat.r = mz.cat.startR; mz.cat.c = mz.cat.startC;
        mz.cat.scared = false; mz.cat.scareTimer = 0;
        mz.cat.eaten = false; mz.cat.respawnTimer = 0;
        mz.catGraceTimer = 2000;
      }
    }
    return;
  }

  if (mz.gameOver || mz.levelComplete) return;
  mz.elapsed = Date.now() - mz.startTime;

  // Smooth animation toward current cell
  mz.animX += (0 - mz.animX) * 0.35;
  mz.animY += (0 - mz.animY) * 0.35;

  // Continuous movement: check held keys for direction
  const held = mz.heldKeys;
  const activeDir = held.up ? 'up' : held.down ? 'down' : held.left ? 'left' : held.right ? 'right' : null;
  if (activeDir) mz.nextDir = activeDir;

  mz.moveTimer -= dt;
  if (mz.moveTimer <= 0) {
    mz.moveTimer = mz.moveInterval;
    // Only auto-repeat if a key is held; single press moves once via keydown
    if (activeDir) {
      if (mz.nextDir && canMazeMove(mz.nextDir)) {
        mz.playerDir = mz.nextDir;
        mz.nextDir = null;
        doMazeMove(mz.playerDir);
      } else if (canMazeMove(mz.playerDir)) {
        doMazeMove(mz.playerDir);
      }
    }
  }

  // Power-up timer
  if (mz.powerTimer > 0) {
    mz.powerTimer -= dt;
    if (mz.powerTimer <= 0) {
      mz.cat.scared = false;
    }
  }

  // Cat AI
  if (mz.catGraceTimer > 0) {
    mz.catGraceTimer -= dt;
  } else if (mz.cat.eaten) {
    mz.cat.respawnTimer -= dt;
    if (mz.cat.respawnTimer <= 0) {
      mz.cat.eaten = false;
      mz.cat.r = mz.cat.startR;
      mz.cat.c = mz.cat.startC;
      mz.cat.scared = false;
    }
  } else {
    mz.cat.moveTimer -= dt;
    if (mz.cat.moveTimer <= 0) {
      mz.cat.moveTimer = mz.cat.scared ? mz.catSpeed * 1.8 : mz.catSpeed;
      moveCat();
    }
    // Check collision
    if (mz.cat.r === mz.playerR && mz.cat.c === mz.playerC) {
      if (mz.cat.scared) {
        // Eat the cat!
        mz.cat.eaten = true;
        mz.cat.respawnTimer = 3000;
        mz.totalScore += 10;
        sfxGoalComplete();
        const px = mz.ox + mz.cat.c * mz.cellSize + mz.cellSize / 2;
        const py = mz.oy + mz.cat.r * mz.cellSize + mz.cellSize / 2;
        spawnFloatingEffect(px, py, '+10 ‚≠ê');
      } else {
        // Cat catches mouse
        mz.lives--;
        mz.deathPause = 1500;
        const px = mz.ox + mz.playerC * mz.cellSize + mz.cellSize / 2;
        const py = mz.oy + mz.playerR * mz.cellSize + mz.cellSize / 2;
        spawnFloatingEffect(px, py, 'üíÄ');
      }
    }
  }

  // Check level complete (all berries collected)
  const allCollected = mz.berries.every(b => b.collected);
  if (allCollected) {
    mz.levelComplete = true;
    const timeBonus = Math.max(0, 30 - Math.floor(mz.elapsed / 1000));
    const lifeBonus = mz.lives * 5;
    mz.totalScore += timeBonus + lifeBonus;
    sfxGoalComplete();
  }
}

function canMazeMove(dir) {
  const cell = mz.grid[mz.playerR][mz.playerC];
  if (dir === 'up') return !cell.top;
  if (dir === 'down') return !cell.bottom;
  if (dir === 'left') return !cell.left;
  if (dir === 'right') return !cell.right;
  return false;
}

function doMazeMove(dir) {
  let dr = 0, dc = 0;
  if (dir === 'up') dr = -1;
  else if (dir === 'down') dr = 1;
  else if (dir === 'left') dc = -1;
  else if (dir === 'right') dc = 1;

  mz.animX = -dc * mz.cellSize;
  mz.animY = -dr * mz.cellSize;
  mz.playerR += dr;
  mz.playerC += dc;
  mz.moves++;

  // Collect berries
  mz.berries.forEach(b => {
    if (!b.collected && b.r === mz.playerR && b.c === mz.playerC) {
      b.collected = true;
      if (b.isPower) {
        // Power cheese! Cat becomes scared
        mz.totalScore += 5;
        mz.totalBerries++;
        mz.powerTimer = 6000;
        mz.cat.scared = true;
        sfxGoalComplete();
        const px = mz.ox + mz.playerC * mz.cellSize + mz.cellSize / 2;
        const py = mz.oy + mz.playerR * mz.cellSize + mz.cellSize / 2;
        spawnFloatingEffect(px, py, '‚ö°');
      } else {
        mz.totalScore += 1;
        mz.totalBerries++;
        sfxCheeseCollect();
      }
    }
  });

  // Check cat collision after moving
  if (!mz.cat.eaten && mz.cat.r === mz.playerR && mz.cat.c === mz.playerC) {
    if (mz.cat.scared) {
      mz.cat.eaten = true;
      mz.cat.respawnTimer = 3000;
      mz.totalScore += 10;
      sfxGoalComplete();
      const px = mz.ox + mz.cat.c * mz.cellSize + mz.cellSize / 2;
      const py = mz.oy + mz.cat.r * mz.cellSize + mz.cellSize / 2;
      spawnFloatingEffect(px, py, '+10 ‚≠ê');
    } else {
      mz.lives--;
      mz.deathPause = 1500;
      const px = mz.ox + mz.playerC * mz.cellSize + mz.cellSize / 2;
      const py = mz.oy + mz.playerR * mz.cellSize + mz.cellSize / 2;
      spawnFloatingEffect(px, py, 'üíÄ');
    }
  }
}

function moveCat() {
  const cat = mz.cat;
  if (cat.scared) {
    // Flee: move AWAY from player ‚Äî pick direction that increases distance
    const cell = mz.grid[cat.r][cat.c];
    const possibleDirs = [];
    if (!cell.top) possibleDirs.push({ dr: -1, dc: 0 });
    if (!cell.bottom) possibleDirs.push({ dr: 1, dc: 0 });
    if (!cell.left) possibleDirs.push({ dr: 0, dc: -1 });
    if (!cell.right) possibleDirs.push({ dr: 0, dc: 1 });
    if (possibleDirs.length === 0) return;
    const curDist = Math.abs(cat.r - mz.playerR) + Math.abs(cat.c - mz.playerC);
    // Sort by distance from player (farthest first) with some randomness
    possibleDirs.sort((a, b) => {
      const da = Math.abs(cat.r + a.dr - mz.playerR) + Math.abs(cat.c + a.dc - mz.playerC);
      const db = Math.abs(cat.r + b.dr - mz.playerR) + Math.abs(cat.c + b.dc - mz.playerC);
      return db - da;
    });
    // 80% pick farthest, 20% random
    const pick = Math.random() < 0.8 ? possibleDirs[0] : possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
    cat.r += pick.dr;
    cat.c += pick.dc;
  } else {
    // Chase: BFS toward player
    const dir = mazeBFS(mz.grid, cat.r, cat.c, mz.playerR, mz.playerC, mz.rows, mz.cols);
    if (dir) {
      if (dir === 'up') cat.r--;
      else if (dir === 'down') cat.r++;
      else if (dir === 'left') cat.c--;
      else if (dir === 'right') cat.c++;
      cat.dir = dir;
    }
  }
}

function drawMouseMaze() {
  if (!mouseMazeActive) return;
  const t = Date.now() / 1000;

  // Background
  ctx.fillStyle = '#0a0515';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // HUD bar
  ctx.fillStyle = 'rgba(10,5,20,0.9)';
  ctx.fillRect(0, 0, GAME_W, 26);
  ctx.fillStyle = '#f5d68a';
  ctx.font = '11px monospace';
  ctx.textAlign = 'left';
  // Lives as mouse emoji
  let livesStr = '';
  for (let i = 0; i < mz.lives; i++) livesStr += 'üê≠';
  ctx.fillText(livesStr || 'üíÄ', 8, 17);
  ctx.fillText(`ü´ê${mz.totalBerries}`, 60, 17);
  ctx.textAlign = 'center';
  ctx.fillText(`PAC MOUSE  Lv${mz.level}`, GAME_W / 2, 17);
  ctx.textAlign = 'right';
  ctx.fillText(`‚≠ê${mz.totalScore}`, GAME_W - 50, 17);
  // Exit button
  ctx.fillStyle = 'rgba(180,100,100,0.7)';
  ctx.beginPath();
  ctx.roundRect(GAME_W - 42, 4, 36, 18, 4);
  ctx.fill();
  ctx.fillStyle = '#fdd';
  ctx.font = '10px monospace';
  ctx.fillText('EXIT', GAME_W - 24, 16);
  ctx.textAlign = 'left';

  const { grid, cols, rows, cellSize, oy } = mz;
  // Recalculate ox for current GAME_W (handles orientation changes mid-game)
  const ox = Math.floor((GAME_W - cols * cellSize) / 2);

  // Maze floor
  ctx.fillStyle = '#120828';
  ctx.fillRect(ox - 2, oy - 2, cols * cellSize + 4, rows * cellSize + 4);

  // Draw cells
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cx = ox + c * cellSize;
      const cy = oy + r * cellSize;
      const cell = grid[r][c];

      // Cell floor (dark blue-purple checkerboard)
      ctx.fillStyle = (r + c) % 2 === 0 ? '#1a0e30' : '#160b28';
      ctx.fillRect(cx, cy, cellSize, cellSize);

      // Walls (glowing blue)
      ctx.strokeStyle = '#3040aa';
      ctx.lineWidth = 2;
      if (cell.top) {
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + cellSize, cy); ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy + cellSize); ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath(); ctx.moveTo(cx, cy + cellSize); ctx.lineTo(cx + cellSize, cy + cellSize); ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath(); ctx.moveTo(cx + cellSize, cy); ctx.lineTo(cx + cellSize, cy + cellSize); ctx.stroke();
      }
    }
  }

  // Outer border
  ctx.strokeStyle = '#5060dd';
  ctx.lineWidth = 3;
  ctx.strokeRect(ox, oy, cols * cellSize, rows * cellSize);

  // Blueberries and power cheese
  mz.berries.forEach(b => {
    if (b.collected) return;
    const bx = ox + b.c * cellSize + cellSize / 2;
    const by = oy + b.r * cellSize + cellSize / 2;
    if (b.isPower) {
      // Power cheese ‚Äî large, pulsing
      const pulse = 0.7 + 0.3 * Math.sin(t * 4);
      const sz = Math.min(cellSize * 0.4, 8) * pulse;
      ctx.fillStyle = `rgba(255, 220, 60, ${pulse})`;
      ctx.beginPath();
      ctx.arc(bx, by, sz, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = `rgba(255, 255, 200, ${pulse * 0.5})`;
      ctx.beginPath();
      ctx.arc(bx, by, sz + 3, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Blueberry dot
      const sz = Math.min(cellSize * 0.15, 3);
      ctx.fillStyle = '#6070ff';
      ctx.beginPath();
      ctx.arc(bx, by, sz, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  // Cat ghost (if active and not eaten)
  if (mz.catGraceTimer <= 0 && !mz.cat.eaten) {
    const cat = mz.cat;
    const catX = ox + cat.c * cellSize + cellSize / 2;
    const catY = oy + cat.r * cellSize + cellSize / 2;
    const catSz = Math.min(cellSize * 0.4, 12);

    if (cat.scared) {
      // Scared cat ‚Äî blue, wobbling
      const wobble = Math.sin(t * 8) * 2;
      const flash = mz.powerTimer < 2000 ? Math.sin(t * 12) > 0 : true;
      if (flash) {
        ctx.fillStyle = 'rgba(60,60,200,0.8)';
        ctx.beginPath();
        ctx.arc(catX + wobble, catY, catSz, 0, Math.PI * 2);
        ctx.fill();
        // Scared face
        ctx.fillStyle = '#fff';
        ctx.fillRect(catX + wobble - 4, catY - 3, 2, 2);
        ctx.fillRect(catX + wobble + 2, catY - 3, 2, 2);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(catX + wobble - 4, catY + 3);
        for (let i = 0; i < 4; i++) {
          ctx.lineTo(catX + wobble - 4 + i * 3, catY + 3 + (i % 2 ? -1 : 1));
        }
        ctx.stroke();
      }
    } else {
      // Evil cat head ‚Äî glowing, menacing
      const glow = 0.6 + 0.3 * Math.sin(t * 2);
      // Glow aura
      const aura = ctx.createRadialGradient(catX, catY, catSz * 0.5, catX, catY, catSz * 2);
      aura.addColorStop(0, `rgba(200, 50, 50, ${glow * 0.3})`);
      aura.addColorStop(1, 'rgba(200, 50, 50, 0)');
      ctx.fillStyle = aura;
      ctx.fillRect(catX - catSz * 2, catY - catSz * 2, catSz * 4, catSz * 4);
      // Head
      ctx.fillStyle = `rgba(60, 20, 60, ${0.85 + glow * 0.15})`;
      ctx.beginPath();
      ctx.arc(catX, catY, catSz, 0, Math.PI * 2);
      ctx.fill();
      // Ears (triangles)
      ctx.fillStyle = '#4a1a4a';
      ctx.beginPath();
      ctx.moveTo(catX - catSz * 0.7, catY - catSz * 0.5);
      ctx.lineTo(catX - catSz * 0.3, catY - catSz * 1.2);
      ctx.lineTo(catX - catSz * 0.05, catY - catSz * 0.5);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(catX + catSz * 0.7, catY - catSz * 0.5);
      ctx.lineTo(catX + catSz * 0.3, catY - catSz * 1.2);
      ctx.lineTo(catX + catSz * 0.05, catY - catSz * 0.5);
      ctx.fill();
      // Evil eyes (glowing red/green)
      const eyeGlow = 0.8 + 0.2 * Math.sin(t * 3);
      ctx.fillStyle = `rgba(255, ${Math.floor(40 + 30 * Math.sin(t * 2))}, 20, ${eyeGlow})`;
      ctx.beginPath();
      ctx.ellipse(catX - catSz * 0.3, catY - catSz * 0.1, catSz * 0.22, catSz * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(catX + catSz * 0.3, catY - catSz * 0.1, catSz * 0.22, catSz * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();
      // Pupils (slitted)
      ctx.fillStyle = '#000';
      ctx.fillRect(catX - catSz * 0.32, catY - catSz * 0.2, catSz * 0.06, catSz * 0.22);
      ctx.fillRect(catX + catSz * 0.28, catY - catSz * 0.2, catSz * 0.06, catSz * 0.22);
      // Mouth (smirk)
      ctx.strokeStyle = `rgba(200,80,80,${glow})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(catX, catY + catSz * 0.35, catSz * 0.3, 0.2, Math.PI - 0.2);
      ctx.stroke();
    }
  }

  // Player mouse with smooth animation
  if (mz.deathPause <= 0) {
    const pxBase = ox + mz.playerC * cellSize;
    const pyBase = oy + mz.playerR * cellSize;
    const px = pxBase + mz.animX;
    const py = pyBase + mz.animY;
    const mouseDrawSize = Math.min(cellSize - 4, 28);
    const mScale = mouseDrawSize / 28;
    ctx.save();
    const mcx = px + cellSize / 2;
    const mcy = py + cellSize / 2;
    ctx.translate(mcx, mcy);
    ctx.scale(mScale, mScale);
    ctx.translate(-mcx, -mcy);
    const faceDir = (mz.playerDir === 'left') ? -1 : 1;
    drawMouse(px + (cellSize - 28) / 2, py + (cellSize - 20) / 2 - 2, CONFIG.mice.pip, faceDir, Math.floor(t * 6) % 4, 'walking');
    ctx.restore();

    // Chomping effect (brief flash when collecting)
    if (mz.moves > 0 && mz.animX !== 0 || mz.animY !== 0) {
      const chompPhase = Math.sin(t * 15);
      if (chompPhase > 0.5) {
        ctx.fillStyle = 'rgba(255,255,200,0.15)';
        ctx.beginPath();
        ctx.arc(px + cellSize / 2 + mz.animX * 0.3, py + cellSize / 2, cellSize * 0.2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
  drawFloatingEffects();

  // Death flash
  if (mz.deathPause > 1000) {
    ctx.fillStyle = `rgba(255,50,50,${(mz.deathPause - 1000) / 500 * 0.3})`;
    ctx.fillRect(0, 0, GAME_W, GAME_H);
  }

  // Level complete overlay
  if (mz.levelComplete) {
    ctx.fillStyle = 'rgba(10,5,20,0.8)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.fillStyle = '#f5d68a';
    ctx.font = '22px monospace';
    ctx.textAlign = 'center';
    if (mz.level >= 3) {
      ctx.fillText('üéâ All Levels Clear!', GAME_W / 2, GAME_H / 2 - 40);
      ctx.font = '12px monospace';
      ctx.fillStyle = '#e8d5b5';
      ctx.fillText(`ü´ê ${mz.totalBerries}  |  ‚≠ê ${mz.totalScore} pts  |  üê≠ √ó${mz.lives}`, GAME_W / 2, GAME_H / 2 - 5);
      ctx.fillStyle = '#f5d68a';
      ctx.font = '15px monospace';
      ctx.fillText(`Earned: üßÄ ${mz.totalScore} coins!`, GAME_W / 2, GAME_H / 2 + 25);
      ctx.fillStyle = '#a89070';
      ctx.font = '11px monospace';
      ctx.fillText('press any key or tap to finish', GAME_W / 2, GAME_H / 2 + 50);
    } else {
      ctx.fillText(`‚úÖ Level ${mz.level} Clear!`, GAME_W / 2, GAME_H / 2 - 25);
      ctx.font = '12px monospace';
      ctx.fillStyle = '#e8d5b5';
      ctx.fillText(`ü´ê ${mz.totalBerries}  |  ‚≠ê ${mz.totalScore}  |  üê≠ √ó${mz.lives}`, GAME_W / 2, GAME_H / 2 + 5);
      ctx.fillStyle = '#a89070';
      ctx.font = '11px monospace';
      ctx.fillText('press any key or tap for next level', GAME_W / 2, GAME_H / 2 + 35);
    }
    ctx.textAlign = 'left';
  }

  // Game over overlay
  if (mz.gameOver) {
    ctx.fillStyle = 'rgba(10,5,20,0.85)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.fillStyle = '#e06050';
    ctx.font = '24px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('üòø Game Over!', GAME_W / 2, GAME_H / 2 - 30);
    ctx.fillStyle = '#e8d5b5';
    ctx.font = '12px monospace';
    ctx.fillText(`ü´ê ${mz.totalBerries}  |  ‚≠ê ${mz.totalScore} pts`, GAME_W / 2, GAME_H / 2 + 5);
    ctx.fillStyle = '#f5d68a';
    ctx.font = '15px monospace';
    ctx.fillText(`Earned: üßÄ ${mz.totalScore} coins!`, GAME_W / 2, GAME_H / 2 + 30);
    ctx.fillStyle = '#a89070';
    ctx.font = '11px monospace';
    ctx.fillText('press any key or tap to finish', GAME_W / 2, GAME_H / 2 + 55);
    ctx.textAlign = 'left';
  }
}

function endMouseMaze() {
  stopGameMusic();
  hideMazeDpad();
  const earned = mz.totalScore;
  state.coins += earned;
  state.totalCoinsEarned += earned;
  addHappiness(6);
  updateCoinDisplay();
  state.stats.gamesPlayed.maze++;
  if (mz.level >= 3 && mz.levelComplete) unlockAchievement('pac-pro');
  checkAchievements();
  saveGame();
  mouseMazeActive = false;
  document.getElementById('tray-toggle').style.display = 'flex';
  startMusic();
  sfxCoinCollect();
  spawnCoinEffect(earned, GAME_W / 2, GAME_H / 2 - 20);
  showToast(`Pac Mouse: earned üßÄ ${earned} coins!`);
}

function handleMazeInput(sx, sy) {
  const pos = screenToGame(sx, sy);
  // Exit button check (top-right corner of HUD)
  if (pos.x >= GAME_W - 42 && pos.x <= GAME_W - 6 && pos.y >= 4 && pos.y <= 22) {
    endMouseMaze();
    return;
  }
  if (mz.gameOver) {
    endMouseMaze();
    return;
  }
  if (mz.levelComplete) {
    if (mz.level >= 3) {
      endMouseMaze();
    } else {
      mz.level++;
      initMazeLevel(mz.level);
    }
    return;
  }
}

// Maze swipe/drag support
let mazeSwipeStart = null;

function mazeSwipeBegin(sx, sy) {
  mazeSwipeStart = { x: sx, y: sy };
}

function mazeSwipeEnd(sx, sy) {
  if (!mazeSwipeStart) return;
  const dx = sx - mazeSwipeStart.x;
  const dy = sy - mazeSwipeStart.y;
  mazeSwipeStart = null;
  const minDist = 15;
  if (Math.abs(dx) < minDist && Math.abs(dy) < minDist) return;
  const dir = Math.abs(dx) > Math.abs(dy)
    ? (dx > 0 ? 'right' : 'left')
    : (dy > 0 ? 'down' : 'up');
  mz.nextDir = dir;
  if (canMazeMove(dir)) {
    mz.playerDir = dir;
    doMazeMove(dir);
    mz.moveTimer = mz.moveInterval;
  }
}

// D-Pad controller for mobile maze play
function showMazeDpad() {
  document.getElementById('maze-dpad').classList.add('visible');
}
function hideMazeDpad() {
  document.getElementById('maze-dpad').classList.remove('visible');
}
document.querySelectorAll('#maze-dpad .dpad-btn').forEach(btn => {
  function fireDpad(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!mouseMazeActive || !mz || mz.levelComplete || mz.gameOver) return;
    const dir = btn.dataset.dir;
    mz.nextDir = dir;
    if (canMazeMove(dir)) {
      mz.playerDir = dir;
      doMazeMove(dir);
      mz.moveTimer = mz.moveInterval;
    }
  }
  btn.addEventListener('touchstart', fireDpad, { passive: false });
  btn.addEventListener('mousedown', fireDpad);
});

// ============================================================
// BIRTHDAY EVENT
// ============================================================
function triggerBirthdayEvent() {
  if (state.birthdayEventSeen) return;
  state.birthdayEventSeen = true;

  // Give birthday items
  if (!state.ownedItems.includes('birthday-cake')) state.ownedItems.push('birthday-cake');
  if (!state.ownedItems.includes('party-banner')) state.ownedItems.push('party-banner');

  // Place them in the living room
  state.placedItems.push({ itemId: 'party-banner', room: 2, gridX: 3, gridY: 0 });
  state.placedItems.push({ itemId: 'birthday-cake', room: 2, gridX: 8, gridY: GRID_ROWS - 1 });

  // Bonus coins
  state.coins += 100;
  state.totalCoinsEarned += 100;
  updateCoinDisplay();

  // Both mice to living room for the party
  state.miceState.pip.room = 2;
  state.miceState.pip.x = 150;
  state.miceState.pip.action = 'idle';
  state.miceState.pip.actionTimer = 6000;
  state.miceState.chai.room = 2;
  state.miceState.chai.x = 280;
  state.miceState.chai.action = 'idle';
  state.miceState.chai.actionTimer = 6000;

  // Switch to living room
  state.currentRoom = 2;
  buildRoomTabs();

  addHappiness(20);
  saveGame();

  // Celebration sequence
  setTimeout(() => {
    sfxFanfare();
    showToast(`üéÇ Happy Birthday ${CONFIG.twins.name1} & ${CONFIG.twins.name2}! üéâ`);
    // Confetti burst
    for (let i = 0; i < 20; i++) {
      setTimeout(() => {
        spawnFloatingEffect(
          80 + Math.random() * (GAME_W - 160),
          ROOM_Y + 50 + Math.random() * 100,
          ['üéâ','üéä','üéÇ','üßÄ','üíõ','‚≠ê','üéà','‚ú®'][Math.floor(Math.random() * 8)]
        );
      }, i * 80);
    }
  }, 500);

  setTimeout(() => {
    showToast('üßÄ +100 bonus coins! The mice threw a party!');
  }, 4000);

  setTimeout(() => {
    showToast('üíå Check the letter button for a special message!');
  }, 7500);
}

// ============================================================
// BIRTHDAY LETTER
// ============================================================
function openLetter() {
  state.letterRead = true;
  saveGame();
  const container = document.getElementById('modal-container');
  const msgHtml = CONFIG.birthdayMessage.replace(/\n/g, '<br>');
  container.innerHTML = `<div class="modal-overlay" onclick="if(event.target===this)closeModal()">
    <div class="modal-content" style="max-width:480px;">
      <h2>üíå A Letter for You</h2>
      <div class="letter-content">
        <h3>üê≠ Special Delivery üê≠</h3>
        ${msgHtml}
      </div>
      <button class="close-btn" onclick="closeModal()">üíõ</button>
    </div>
  </div>`;
}

// ============================================================
// PARTY HATS (drawn on mice during birthday)
// ============================================================
function drawPartyHat(x, y, action, dir, cfg, roomIdx) {
  if (!state.birthdayEventSeen) return;
  // Only wear hats when a birthday cake is in this room
  const cakeInRoom = state.placedItems.some(p => p.itemId === 'birthday-cake' && p.room === roomIdx);
  if (!cakeInRoom) return;
  const mouseScale = (cfg && cfg.scale) || 1.0;
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  const t = Date.now() / 1000;
  const bob = action === 'sleeping' ? 0 : Math.sin(t * 3) * 0.6;

  ctx.save();

  // Apply same scale transform as drawMouse so hat aligns
  if (mouseScale !== 1.0) {
    const pivotX = cx + 14;
    const pivotY = cy + 20;
    ctx.translate(pivotX, pivotY);
    ctx.scale(mouseScale, mouseScale);
    ctx.translate(-pivotX, -pivotY);
  }
  // Apply same flip as drawMouse so hat stays on top of head
  if (dir < 0) {
    ctx.translate(cx + 14, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(cx + 14), 0);
  }

  let hatX, hatY;
  if (action === 'sleeping') {
    hatX = cx + 17; hatY = cy + 1;
  } else {
    hatX = cx + 19; hatY = cy - 6 + bob;
  }

  // Hat body (cone)
  ctx.fillStyle = '#FF1493';
  ctx.beginPath();
  ctx.moveTo(hatX, hatY - 10);
  ctx.lineTo(hatX - 5, hatY + 2);
  ctx.lineTo(hatX + 5, hatY + 2);
  ctx.closePath();
  ctx.fill();

  // Stripe
  ctx.fillStyle = '#FFD700';
  ctx.fillRect(hatX - 4, hatY - 2, 8, 2);

  // Pom pom on top
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.arc(hatX, hatY - 10, 2.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// ============================================================
// COIN FLOATING ANIMATION
// ============================================================
function spawnCoinEffect(amount, x, y) {
  if (x === undefined) x = GAME_W / 2;
  if (y === undefined) y = 30;
  for (let i = 0; i < Math.min(amount / 2, 8); i++) {
    setTimeout(() => {
      spawnFloatingEffect(
        x + (Math.random() - 0.5) * 40,
        y + Math.random() * 20,
        'üßÄ'
      );
    }, i * 120);
  }
}

// ============================================================
// HAPPINESS SYSTEM
// ============================================================
const HAPPINESS_DECAY_RATE = 0.0002; // ~1 point per 5 seconds ‚Üí hungry after ~5.4 min

function getAverageHappiness() {
  return Math.round((state.miceState.pip.happiness + state.miceState.chai.happiness) / 2);
}

function addHappiness(amount) {
  state.miceState.pip.happiness = Math.min(100, state.miceState.pip.happiness + amount);
  state.miceState.chai.happiness = Math.min(100, state.miceState.chai.happiness + amount);
  updateHappinessDisplay();
}

let _lastHungerState = false;
let _achCheckTimer = 0;
function updateHappiness(dt) {
  state.miceState.pip.happiness = Math.max(10, state.miceState.pip.happiness - HAPPINESS_DECAY_RATE * dt);
  state.miceState.chai.happiness = Math.max(10, state.miceState.chai.happiness - HAPPINESS_DECAY_RATE * dt);
  updateHappinessDisplay();
  // Periodic achievement check (every 5s)
  _achCheckTimer -= dt;
  if (_achCheckTimer <= 0) { _achCheckTimer = 5000; checkAchievements(); }
  // Update goal display when hunger state changes
  const anyHungry = state.miceState.pip.happiness < 35 || state.miceState.chai.happiness < 35;
  if (anyHungry !== _lastHungerState) {
    _lastHungerState = anyHungry;
    updateGoalDisplay();
  }
}

function updateHappinessDisplay() {
  const avg = getAverageHappiness();
  const el = document.getElementById('happiness-value');
  if (el) el.textContent = avg;
  const color = avg >= 70 ? '#f5d68a' : avg >= 40 ? '#e8a040' : '#e06050';
  const hd = document.getElementById('happiness-display');
  if (hd) hd.style.color = color;
}

// ============================================================
// GOALS / WISHES SYSTEM
// ============================================================
const GOAL_TEMPLATES = [
  { text: '{mouse} wants a cozy bed üõè', itemId: 'matchbox-bed' },
  { text: '{mouse} is craving cheese üßÄ', itemId: 'cheese-wheel' },
  { text: '{mouse} wants a coffee ‚òï', itemId: 'thimble-cup' },
  { text: '{mouse} wants to doomscroll üíª', itemId: 'tiny-laptop' },
  { text: '{mouse} needs a yoga session üßò', itemId: 'yoga-mat' },
  { text: '{mouse} wants to watch TV üì∫', itemId: 'eraser-tv' },
  { text: '{mouse} wants aesthetic lights ‚ú®', itemId: 'fairy-lights' },
  { text: '{mouse} wants a plant friend ü™¥', itemId: 'tiny-plant' },
  { text: '{mouse} needs a disco ball ü™©', itemId: 'disco-ball' },
  { text: '{mouse} wants to sit somewhere üõã', itemId: 'cardboard-couch' },
  { text: '{mouse} craves sourdough üçû', itemId: 'sourdough' },
  { text: '{mouse} wants the vibes sign üìú', itemId: 'live-laugh-cheese' },
];

let goalCooldown = 20000 + Math.random() * 15000;

function updateGoals(dt) {
  // Check if current goal is fulfilled
  if (state.activeGoal) {
    // Auto-expire stale goals after 2 minutes
    const age = Date.now() - (state.activeGoal.created || 0);
    if (age > 120000) {
      state.activeGoal = null;
      updateGoalDisplay();
      saveGame();
      goalCooldown = 15000 + Math.random() * 10000;
      return;
    }
    const isPlaced = state.placedItems.some(p => p.itemId === state.activeGoal.itemId);
    if (isPlaced) {
      // Goal completed!
      const bonus = 15;
      const goalMouseKey = state.activeGoal.mouseKey;
      const goalItemId = state.activeGoal.itemId;
      state.coins += bonus;
      state.totalCoinsEarned += bonus;
      addHappiness(10);
      updateCoinDisplay();
      spawnCoinEffect(bonus);
      sfxGoalComplete();
      showToast(`‚úÖ Goal complete! ${state.activeGoal.text} ‚Äî +üßÄ${bonus} +‚ù§Ô∏è!`);
      state.activeGoal = null;
      state.stats.goalsCompleted++;
      updateGoalDisplay();
      checkAchievements();
      saveGame();
      goalCooldown = 25000 + Math.random() * 20000;

      // Requesting mouse seeks out the item and interacts with it
      const goalMouse = state.miceState[goalMouseKey];
      const goalPlaced = state.placedItems.find(p => p.itemId === goalItemId);
      const goalItem = FURNITURE.find(f => f.id === goalItemId);
      if (goalPlaced && goalItem && goalMouse.action !== 'wheeling' && goalMouse.action !== 'flung' && goalMouse.action !== 'climbing' && !goalMouse.onFurniture) {
        const itemPos = gridToGame(goalPlaced.gridX, goalPlaced.gridY);
        const fw = goalItem.w * GRID_SIZE;
        goalMouse.pendingClimb = null;
        goalMouse.pendingRoomChange = null;
        goalMouse.pendingFurniture = null;
        goalMouse.onFurniture = null;

        // Navigate to the item's room if needed
        if (goalMouse.room !== goalPlaced.room) {
          const nextRoom = ringStepToward(goalMouse.room, goalPlaced.room);
          const exitDir = nextRoom === roomRight(goalMouse.room) ? 1 : -1;
          goalMouse.level = 'main-floor';
          goalMouse.action = 'walking';
          goalMouse.targetX = exitDir > 0 ? ROOM_W - 5 : 5;
          goalMouse.dir = exitDir;
          goalMouse.actionTimer = 12000;
          goalMouse.pendingRoomChange = { newRoom: nextRoom, exitDir };
        } else {
          // Same room ‚Äî walk to item, then interact
          goalMouse.level = 'main-floor';
          goalMouse.action = 'walking';
          goalMouse.targetX = itemPos.x + fw / 2;
          goalMouse.dir = goalMouse.targetX > goalMouse.x ? 1 : -1;
          goalMouse.actionTimer = 8000;
          // For hammock/rope, use the pendingFurniture + climb system
          if ((goalItem.mouseBehavior === 'sleeping' && goalItemId === 'hammock') ||
              goalItem.mouseBehavior === 'swinging') {
            goalMouse.pendingFurniture = { behavior: goalItem.mouseBehavior, placed: goalPlaced, timer: 5000 };
            const furnPlatform = getFurniturePlatform(goalPlaced.room, goalPlaced);
            if (goalMouse.level !== furnPlatform) {
              const room = ROOMS[goalMouse.room];
              const ramp = room.ramps && room.ramps.find(r =>
                (r.from === goalMouse.level && r.to === furnPlatform) ||
                (r.to === goalMouse.level && r.from === furnPlatform));
              if (ramp) {
                const goingUp = ramp.from === goalMouse.level;
                goalMouse.targetX = goingUp ? ramp.x1 : ramp.x2;
                goalMouse.dir = goalMouse.targetX > goalMouse.x ? 1 : -1;
                goalMouse.pendingClimb = { ramp, targetLevel: furnPlatform, goingUp };
              }
            }
          }
        }

        // Grateful speech from requesting mouse (after reaching item)
        const gratefulPip = ['FINALLY ü•π', 'you actually listened!', 'best day ever ‚ú®',
          'I manifested this', 'crying rn üò≠', 'YESSS', 'literally perfect', 'slay üíÖ'];
        const gratefulChai = ['omg thank you ü•∫', 'this is everything', 'so blessed ‚ú®',
          'I feel seen', 'actually crying', 'needed this so bad', 'perfect vibes', 'love this for me'];
        const gratefulQuotes = goalMouseKey === 'pip' ? gratefulPip : gratefulChai;

        // Celebration burst and speech after mouse reaches item
        setTimeout(() => {
          // Speech
          speechBubbles = speechBubbles.filter(b => b.mouseKey !== goalMouseKey);
          speechBubbles.push({
            x: goalMouse.x + 14, y: getMouseFloorY(goalMouse) - 10,
            text: gratefulQuotes[Math.floor(Math.random() * gratefulQuotes.length)],
            timer: 3500, maxTimer: 3500, mouseKey: goalMouseKey
          });
          // Celebration emoji burst
          if (goalMouse.room === state.currentRoom) {
            const burstEmoji = ['üéâ', '‚ú®', 'üíï', '‚≠ê', 'ü•≥', 'üíñ'];
            for (let i = 0; i < 5; i++) {
              setTimeout(() => {
                spawnFloatingEffect(
                  goalMouse.x + 14 + (Math.random() - 0.5) * 30,
                  getMouseFloorY(goalMouse) - Math.random() * 15,
                  burstEmoji[Math.floor(Math.random() * burstEmoji.length)]
                );
              }, i * 150);
            }
          }
          // Start the item's behavior (if it has one)
          if (goalItem.mouseBehavior && goalItem.mouseBehavior !== 'eating' && !goalMouse.onFurniture) {
            goalMouse.action = goalItem.mouseBehavior;
            goalMouse.actionTimer = 4000 + Math.random() * 3000;
          } else if (goalItem.mouseBehavior === 'eating') {
            goalMouse.action = 'eating';
            goalMouse.actionTimer = 6000;
          } else {
            // Decorative items: happy idle admiring
            goalMouse.action = 'idle';
            goalMouse.actionTimer = 3000 + Math.random() * 2000;
          }
        }, 2500);

        // Other mouse reacts with jealousy or support
        const otherKey = goalMouseKey === 'pip' ? 'chai' : 'pip';
        const otherMouse = state.miceState[otherKey];
        setTimeout(() => {
          const jealousPip = ['why not ME though', 'I wanted that too üò§', 'ok wow favoritism',
            'hello?? I exist too', 'not jealous... (jealous)', 'plot twist: it\'s mine now'];
          const jealousChai = ['that\'s nice I guess', 'happy for you (lying)', 'ok but when is MY turn',
            '*stares longingly*', 'cool cool cool cool', 'sharing is caring right??'];
          const supportPip = ['W gift tbh', 'valid choice', 'I approve üëè', 'good for her honestly'];
          const supportChai = ['that\'s so sweet ü•∞', 'taste!', 'aesthetic ‚ú®', 'we love to see it'];
          const isJealous = Math.random() < 0.6;
          let otherQuotes;
          if (isJealous) {
            otherQuotes = otherKey === 'pip' ? jealousPip : jealousChai;
          } else {
            otherQuotes = otherKey === 'pip' ? supportPip : supportChai;
          }
          speechBubbles = speechBubbles.filter(b => b.mouseKey !== otherKey);
          speechBubbles.push({
            x: otherMouse.x + 14, y: getMouseFloorY(otherMouse) - 10,
            text: otherQuotes[Math.floor(Math.random() * otherQuotes.length)],
            timer: 3000, maxTimer: 3000, mouseKey: otherKey
          });
        }, 3500);
      }
      return;
    }
  }

  // Generate new goal if none active
  if (!state.activeGoal) {
    goalCooldown -= dt;
    if (goalCooldown <= 0) {
      generateNewGoal();
      goalCooldown = 30000 + Math.random() * 20000;
    }
  }
}

function generateNewGoal() {
  // Pick a goal for an item not yet placed
  const unplaced = GOAL_TEMPLATES.filter(g =>
    !state.placedItems.some(p => p.itemId === g.itemId)
  );
  if (unplaced.length === 0) return;

  const template = unplaced[Math.floor(Math.random() * unplaced.length)];
  const mouseKey = Math.random() < 0.5 ? 'pip' : 'chai';
  const mouseName = CONFIG.mice[mouseKey].name;
  const text = template.text.replace('{mouse}', mouseName);

  state.activeGoal = { text, itemId: template.itemId, mouseKey, created: Date.now() };
  updateGoalDisplay();
  saveGame();

  // Mouse says the wish
  const mouse = state.miceState[mouseKey];
  speechBubbles.push({
    x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
    text: text, timer: 4000, maxTimer: 4000, mouseKey
  });
}

function updateGoalDisplay() {
  const el = document.getElementById('goal-display');
  const row2 = document.getElementById('hud-row2');
  if (!el || !row2) return;

  // Hunger warnings take priority over goals
  const pipHungry = (state.miceState.pip.happiness ?? 80) < 35;
  const chaiHungry = (state.miceState.chai.happiness ?? 80) < 35;
  const hasFood = state.placedItems.some(p => {
    const item = FURNITURE.find(f => f.id === p.itemId);
    return item && item.servings && (p.servings === undefined || p.servings > 0);
  });

  if (pipHungry || chaiHungry) {
    const names = [pipHungry && 'Pip', chaiHungry && 'Chai'].filter(Boolean).join(' & ');
    el.textContent = hasFood ? `üçΩ ${names} ${pipHungry && chaiHungry ? 'are' : 'is'} hungry! Food is available.`
                             : `‚ö†Ô∏è ${names} ${pipHungry && chaiHungry ? 'are' : 'is'} hungry! Buy food from aMouseZon!`;
    el.style.color = '#e06050';
    row2.classList.add('visible');
    return;
  }

  el.style.color = '';
  if (state.activeGoal) {
    el.textContent = `üéØ ${state.activeGoal.text}`;
    el.title = `Place ${FURNITURE.find(f => f.id === state.activeGoal.itemId)?.name || 'the item'} to complete!`;
    row2.classList.add('visible');
  } else {
    el.textContent = '';
    el.title = '';
    row2.classList.remove('visible');
  }
}

// ============================================================
// MOUSE SPRITE DRAWING
// ============================================================
const MOUSE_FLOOR_Y = ROOM_Y + ROOM_H - FLOOR_H - 20;

function getMouseFloorY(mouse) {
  const room = ROOMS[mouse.room];
  if (!room || !room.platforms) return MOUSE_FLOOR_Y;
  // During climbing, interpolate Y along the ramp
  if (mouse.action === 'climbing' && mouse.climbRamp) {
    return getRampY(mouse.climbRamp, mouse.x, mouse.room) - 20;
  }
  const plat = room.platforms.find(p => p.id === mouse.level);
  if (!plat) return MOUSE_FLOOR_Y;
  // main-floor y already has the -20 offset baked in; other platforms need it
  return plat.id === 'main-floor' ? plat.y : plat.y - 20;
}

function getMousePlatform(mouse) {
  const room = ROOMS[mouse.room];
  if (!room || !room.platforms) return null;
  return room.platforms.find(p => p.id === mouse.level) || room.platforms[0];
}

function getRampAtX(roomIndex, x, fromLevel, toLevel) {
  const room = ROOMS[roomIndex];
  if (!room || !room.ramps) return null;
  return room.ramps.find(r =>
    ((r.from === fromLevel && r.to === toLevel) || (r.from === toLevel && r.to === fromLevel)) &&
    x >= r.x1 - 5 && x <= r.x2 + 5
  ) || null;
}

function getRampY(ramp, x, roomIndex) {
  const room = ROOMS[roomIndex];
  const fromPlat = room.platforms.find(p => p.id === ramp.from);
  const toPlat = room.platforms.find(p => p.id === ramp.to);
  if (!fromPlat || !toPlat) return MOUSE_FLOOR_Y;
  const t = Math.max(0, Math.min(1, (x - ramp.x1) / (ramp.x2 - ramp.x1)));
  return fromPlat.y + (toPlat.y - fromPlat.y) * t;
}

function drawMouse(x, y, cfg, dir, frame, action, startled, mouseState) {
  const mouseScale = cfg.scale || 1.0;
  const cx = Math.floor(x);
  // Startled: slight vertical jump
  const startleJump = startled ? -3 : 0;
  const cy = Math.floor(y) + startleJump;
  const t = Date.now() / 1000;

  ctx.save();
  // Apply mouse-specific scale (Pip is larger)
  if (mouseScale !== 1.0) {
    const pivotX = cx + 14;
    const pivotY = cy + 20; // scale from feet so they stay on ground
    ctx.translate(pivotX, pivotY);
    ctx.scale(mouseScale, mouseScale);
    ctx.translate(-pivotX, -pivotY);
  }
  if (dir < 0) {
    ctx.translate(cx + 14, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(cx + 14), 0);
  }

  if (action === 'sleeping') {
    // Breathing cycle ‚Äî gentle body scale pulse
    const sleepBreath = Math.sin(t * 1.8) * 0.03;
    ctx.translate(cx + 10, cy + 14);
    ctx.scale(1 + sleepBreath, 1 - sleepBreath * 0.5);
    ctx.translate(-(cx + 10), -(cy + 14));

    // Body
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 12, 11, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    // Belly highlight
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 13, 7, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    // Head tucked in
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy + 8, 6, 5, 0.3, 0, Math.PI * 2);
    ctx.fill();
    // Ear with occasional twitch
    const earTwitch = (Math.sin(t * 0.7) > 0.92) ? Math.sin(t * 12) * 0.3 : 0;
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 3, 4, 5, 0.4 + earTwitch, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 19, cy + 3, 2.5, 3, 0.4 + earTwitch, 0, Math.PI * 2);
    ctx.fill();
    // Tail curled
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy + 12);
    ctx.quadraticCurveTo(cx - 8, cy + 6, cx - 4, cy + 2);
    ctx.stroke();
    // Zzz (slower float)
    const zOff = Math.sin(t * 1.2) * 3;
    ctx.fillStyle = 'rgba(200,200,255,0.6)';
    ctx.font = '8px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('z', cx + 22, cy - 1 + zOff);
    ctx.font = '11px monospace';
    ctx.fillText('z', cx + 27, cy - 7 + zOff * 1.3);
    ctx.font = '13px monospace';
    ctx.fillText('Z', cx + 32, cy - 14 + zOff * 1.6);
    ctx.textAlign = 'left';

    // Dream thought bubble
    if (mouseState && mouseState._dreamContent && mouseState._dreamFade > 0) {
      const dAlpha = Math.min(1, mouseState._dreamFade / 600) * 0.9;
      const dFloat = Math.sin(t * 0.8) * 2;
      ctx.globalAlpha = dAlpha;
      // Thought trail (small circles leading to cloud)
      ctx.fillStyle = 'rgba(230,225,255,0.85)';
      ctx.beginPath(); ctx.arc(cx + 24, cy - 10, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 28, cy - 16, 3, 0, Math.PI * 2); ctx.fill();
      // Cloud bubble
      const bx = cx + 36, by = cy - 30 + dFloat;
      ctx.fillStyle = 'rgba(240,235,255,0.92)';
      ctx.beginPath();
      ctx.arc(bx, by, 10, 0, Math.PI * 2); ctx.fill();
      ctx.arc(bx - 8, by + 2, 7, 0, Math.PI * 2); ctx.fill();
      ctx.arc(bx + 8, by + 2, 7, 0, Math.PI * 2); ctx.fill();
      ctx.arc(bx - 4, by - 5, 6, 0, Math.PI * 2); ctx.fill();
      ctx.arc(bx + 5, by - 5, 6, 0, Math.PI * 2); ctx.fill();
      // Border
      ctx.strokeStyle = 'rgba(180,170,220,0.5)';
      ctx.lineWidth = 0.8;
      ctx.beginPath();
      ctx.arc(bx, by, 10, 0, Math.PI * 2); ctx.stroke();
      ctx.arc(bx - 8, by + 2, 7, 0, Math.PI * 2); ctx.stroke();
      ctx.arc(bx + 8, by + 2, 7, 0, Math.PI * 2); ctx.stroke();
      // Dream emoji content
      ctx.font = '8px serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#000';
      ctx.fillText(mouseState._dreamContent, bx, by + 3);
      ctx.textAlign = 'left';
      ctx.globalAlpha = 1.0;
    }
  } else if (action === 'zoomies') {
    // Fast running mouse with motion blur!
    const zBob = Math.sin(t * 14) * 2;
    const zFrame = Math.floor(t * 12) % 2;

    // Motion lines behind
    ctx.strokeStyle = 'rgba(200,180,140,0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(cx - 4 - i * 6, cy + 6 + i * 3 + zBob);
      ctx.lineTo(cx - 12 - i * 6, cy + 6 + i * 3 + zBob);
      ctx.stroke();
    }

    // Shadow (stretched)
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(cx + 14, cy + 20, 16, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tail streaming
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(cx, cy + 10 + zBob);
    ctx.quadraticCurveTo(cx - 12, cy + 4 + zBob, cx - 16, cy + 8 + zBob);
    ctx.stroke();
    ctx.lineCap = 'butt';

    // Legs (alternating fast)
    ctx.fillStyle = cfg.bodyColor;
    const legOff = zFrame * 4;
    ctx.fillRect(cx + 4 + legOff, cy + 15 + zBob, 3, 6);
    ctx.fillRect(cx + 14 - legOff, cy + 15 + zBob, 3, 6);
    ctx.fillStyle = cfg.bellyColor;
    ctx.fillRect(cx + 3 + legOff, cy + 20 + zBob, 5, 2);
    ctx.fillRect(cx + 13 - legOff, cy + 20 + zBob, 5, 2);

    // Body (stretched)
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 12, cy + 10 + zBob, 12, 7, -0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 12, cy + 12 + zBob, 7, 4, -0.1, 0, Math.PI * 2);
    ctx.fill();

    // Head (forward-leaning)
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 22, cy + 4 + zBob, 7, 5.5, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Ears (windswept)
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy - 3 + zBob, 4, 5, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 17, cy - 3 + zBob, 2.5, 3, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 24, cy - 2 + zBob, 4, 5, -0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 24, cy - 2 + zBob, 2.5, 3, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // Wide excited eyes
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.ellipse(cx + 20, cy + 2 + zBob, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 25, cy + 2 + zBob, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(cx + 20.5, cy + 1 + zBob, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + 25.5, cy + 1 + zBob, 1, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = cfg.noseColor;
    ctx.beginPath();
    ctx.ellipse(cx + 29, cy + 4 + zBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Open mouth (excitement!)
    ctx.fillStyle = '#2a1a1a';
    ctx.beginPath();
    ctx.ellipse(cx + 27, cy + 6 + zBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

  } else {
    // Standing / walking / idle / furniture-interaction mouse
    const isFurnitureAction = ['doomscrolling','watching','yoga','eating','playing','grooming','stretching','mischief','hiding','chewing','swinging'].includes(action);

    // Breathing: visible body pulse
    const breathe = Math.sin(t * 3) * 0.8;
    // Walk cycle: head bobs with slight offset from body
    const walkCycle = action === 'walking' ? Math.sin(t * 10) : 0;
    const bob = action === 'walking' ? walkCycle * 1.8 : breathe;
    // Idle sub-animation offsets
    const idleSub = mouseState ? mouseState._idleSub : null;
    const lookAroundX = (action === 'idle' && idleSub === 'lookAround') ? Math.sin(t * 2.5) * 2 : 0;
    const sniffBob = (action === 'idle' && idleSub === 'sniff') ? Math.sin(t * 12) * 1.5 : 0;
    const headBob = action === 'walking' ? Math.sin(t * 10 + 0.5) * 1.2 : breathe * 0.6 + sniffBob;
    const lean = action === 'walking' ? Math.sin(t * 10) * 0.04 :
                 action === 'yoga' ? Math.sin(t * 2) * 0.06 : 0;

    // Blink timer: eyes close briefly every 3-6 seconds
    const blinkPhase = t % (3 + (cx % 3)); // vary per mouse position
    const isBlinking = blinkPhase < 0.12 || (action === 'idle' && idleSub === 'yawn');

    // Ear twitch: random brief twitch when idle
    const earTwitchL = (Math.sin(t * 0.6 + cx) > 0.9) ? Math.sin(t * 14) * 0.25 : 0;
    const earTwitchR = (Math.sin(t * 0.8 + cx * 0.7) > 0.92) ? Math.sin(t * 16) * 0.2 : 0;

    ctx.translate(cx + 14, cy + 18);
    ctx.rotate(lean);
    ctx.translate(-(cx + 14), -(cy + 18));

    // Shadow on floor
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(cx + 14, cy + 20, 12, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tail ‚Äî expressive based on action
    ctx.strokeStyle = cfg.bodyColor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    let tailWag, tailCurveY, tailEndY;
    if (action === 'eating') {
      // Happy fast wag
      tailWag = Math.sin(t * 8) * 6;
      tailCurveY = cy + 2; tailEndY = cy + tailWag;
    } else if (action === 'zoomies') {
      tailWag = Math.sin(t * 6) * 5;
      tailCurveY = cy + 1; tailEndY = cy + 5 + tailWag;
    } else if (action === 'walking') {
      // Bouncing tail synced to walk
      tailWag = Math.sin(t * 5) * 4;
      tailCurveY = cy + 4 + walkCycle; tailEndY = cy + 8 + tailWag;
    } else if (isFurnitureAction) {
      // Gentle slow sway
      tailWag = Math.sin(t * 2) * 3;
      tailCurveY = cy + 5; tailEndY = cy + 9 + tailWag;
    } else {
      // Idle ‚Äî occasional lazy swish
      tailWag = Math.sin(t * 2.5) * 3;
      tailCurveY = cy + 4; tailEndY = cy + 8 + tailWag;
    }
    ctx.beginPath();
    ctx.moveTo(cx + 2, cy + 12 + bob);
    ctx.quadraticCurveTo(cx - 8, tailCurveY + bob, cx - 12, tailEndY + bob);
    ctx.stroke();
    ctx.lineCap = 'butt';

    // Back legs ‚Äî better walk stride
    const legAnim = action === 'walking' ? Math.sin(t * 10) * 4 : 0;
    const legLift = action === 'walking' ? Math.max(0, Math.sin(t * 10)) * 2 : 0;
    const legLift2 = action === 'walking' ? Math.max(0, -Math.sin(t * 10)) * 2 : 0;
    ctx.fillStyle = cfg.bodyColor;
    ctx.fillRect(cx + 4 - legAnim, cy + 16 + bob - legLift, 4, 5 + legLift);
    ctx.fillRect(cx + 12 + legAnim, cy + 16 + bob - legLift2, 4, 5 + legLift2);
    // Tiny feet
    ctx.fillStyle = cfg.bellyColor;
    ctx.fillRect(cx + 3 - legAnim, cy + 20 + bob, 5, 2);
    ctx.fillRect(cx + 11 + legAnim, cy + 20 + bob, 5, 2);

    // Body (rounded) ‚Äî breathing scale
    const bodyBreath = 1 + Math.sin(t * 3) * 0.015;
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 11 + bob, 10 * bodyBreath, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly
    ctx.fillStyle = cfg.bellyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 10, cy + 13 + bob, 6, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head ‚Äî offset bob for walking liveliness
    ctx.fillStyle = cfg.bodyColor;
    ctx.beginPath();
    ctx.ellipse(cx + 19 + lookAroundX, cy + 5 + headBob, 7, 6, 0.15, 0, Math.PI * 2);
    ctx.fill();

    // Ears (big & round!) with twitching
    // Left ear
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 15 + lookAroundX, cy - 4 + headBob, 5, 6, -0.3 + earTwitchL, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 15 + lookAroundX, cy - 4 + headBob, 3, 4, -0.3 + earTwitchL, 0, Math.PI * 2);
    ctx.fill();
    // Right ear
    ctx.fillStyle = cfg.earColor;
    ctx.beginPath();
    ctx.ellipse(cx + 23 + lookAroundX, cy - 4 + headBob, 5, 6, 0.3 + earTwitchR, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffb8c0';
    ctx.beginPath();
    ctx.ellipse(cx + 23 + lookAroundX, cy - 4 + headBob, 3, 4, 0.3 + earTwitchR, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (big & cute) ‚Äî with blinking
    if (isBlinking) {
      // Blink ‚Äî thin horizontal lines
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx + 15 + lookAroundX, cy + 3 + headBob);
      ctx.lineTo(cx + 19 + lookAroundX, cy + 3 + headBob);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + 20 + lookAroundX, cy + 3 + headBob);
      ctx.lineTo(cx + 24 + lookAroundX, cy + 3 + headBob);
      ctx.stroke();
    } else if (action === 'doomscrolling' || action === 'watching') {
      // Screen-glow eyes
      ctx.fillStyle = '#66ccff';
      ctx.beginPath();
      ctx.ellipse(cx + 17 + lookAroundX, cy + 3 + headBob, 2.2, 2.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22 + lookAroundX, cy + 3 + headBob, 2.2, 2.8, 0, 0, Math.PI * 2);
      ctx.fill();
    } else if (action === 'yoga') {
      // Closed peaceful eyes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx + 17 + lookAroundX, cy + 3 + headBob, 2, 0.3, Math.PI - 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx + 22 + lookAroundX, cy + 3 + headBob, 2, 0.3, Math.PI - 0.3);
      ctx.stroke();
    } else if (action === 'eating' || action === 'grooming') {
      // Happy squinty eyes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx + 17 + lookAroundX, cy + 4 + headBob, 2, Math.PI + 0.3, -0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx + 22 + lookAroundX, cy + 4 + headBob, 2, Math.PI + 0.3, -0.3);
      ctx.stroke();
    } else if (startled) {
      // Startled ‚Äî wide round eyes!
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(cx + 17 + lookAroundX, cy + 3 + headBob, 3, 3.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22 + lookAroundX, cy + 3 + headBob, 3, 3.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(cx + 17 + lookAroundX, cy + 3 + headBob, 1.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 22 + lookAroundX, cy + 3 + headBob, 1.8, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.ellipse(cx + 17 + lookAroundX, cy + 3 + headBob, 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 22 + lookAroundX, cy + 3 + headBob, 2, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx + 17.5 + lookAroundX, cy + 2 + headBob, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 22.5 + lookAroundX, cy + 2 + headBob, 0.8, 0, Math.PI * 2);
      ctx.fill();
    }

    // Nose (tiny pink)
    ctx.fillStyle = cfg.noseColor;
    ctx.beginPath();
    ctx.ellipse(cx + 26 + lookAroundX, cy + 5 + headBob, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Yawn: open mouth below nose
    if (action === 'idle' && idleSub === 'yawn') {
      ctx.fillStyle = '#ff99aa';
      ctx.beginPath();
      ctx.ellipse(cx + 24 + lookAroundX, cy + 8 + headBob, 2.5, 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Whiskers
    const whiskerTwitch = (action === 'idle' && idleSub === 'sniff') ? Math.sin(t * 14) * 2 : 0;
    ctx.strokeStyle = 'rgba(180,160,140,0.5)';
    ctx.lineWidth = 0.7;
    ctx.beginPath();
    ctx.moveTo(cx + 25 + lookAroundX, cy + 5 + headBob);
    ctx.lineTo(cx + 32 + lookAroundX, cy + 2 + headBob + whiskerTwitch);
    ctx.moveTo(cx + 25 + lookAroundX, cy + 6 + headBob);
    ctx.lineTo(cx + 32 + lookAroundX, cy + 7 + headBob - whiskerTwitch);
    ctx.moveTo(cx + 25 + lookAroundX, cy + 5.5 + headBob);
    ctx.lineTo(cx + 33 + lookAroundX, cy + 4.5 + headBob + whiskerTwitch * 0.5);
    ctx.stroke();

    // Tiny smile
    ctx.strokeStyle = 'rgba(100,60,60,0.3)';
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(cx + 23 + lookAroundX, cy + 6 + headBob, 3, 0.2, 1.2);
    ctx.stroke();

    // Scratch: back leg lifts behind ear
    if (action === 'idle' && idleSub === 'scratch') {
      const scratchCycle = Math.sin(t * 10) * 2;
      ctx.fillStyle = cfg.bodyColor;
      ctx.fillRect(cx + 8, cy - 2 + headBob + scratchCycle, 3, 6);
      ctx.fillStyle = cfg.bellyColor;
      ctx.fillRect(cx + 7, cy - 3 + headBob + scratchCycle, 4, 2);
    }

    // Hiccup visual jolt
    if (mouseState && mouseState._hiccups > 0 && mouseState._hiccupJolt) {
      ctx.fillStyle = 'rgba(255,200,200,0.3)';
      ctx.beginPath();
      ctx.ellipse(cx + 14, cy + 10 + bob, 12, 8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Grooming: paw raised to face, licking motion
    if (action === 'grooming') {
      const lickCycle = Math.sin(t * 6) * 2;
      ctx.fillStyle = cfg.bellyColor;
      ctx.beginPath();
      ctx.ellipse(cx + 22, cy + 8 + headBob + lickCycle, 3, 2, 0.3, 0, Math.PI * 2);
      ctx.fill();
      // Tiny tongue
      ctx.fillStyle = '#ff9999';
      ctx.beginPath();
      ctx.ellipse(cx + 24, cy + 7 + headBob + lickCycle * 0.5, 1.5, 1, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Mischief: sly look ‚Äî one eyebrow raised (draw after eyes)
    if (action === 'mischief') {
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx + 20, cy - 1 + headBob);
      ctx.lineTo(cx + 24, cy - 2 + headBob);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ============================================================
// MOUSE AI
// ============================================================
function updateMouse(mouse, dt, personality) {
  // Welcome back ‚Äî rush to center and greet player
  if (state._welcomeBack && mouse.room === state.currentRoom) {
    mouse.action = 'walking';
    mouse.level = 'main-floor';
    mouse.targetX = ROOM_W / 2 + (mouse === state.miceState.pip ? -20 : 20);
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 3000;
    mouse.pendingClimb = null;
    mouse.pendingRoomChange = null;
    mouse.pendingFurniture = null;
    mouse.onFurniture = null;

    const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
    const mins = state._absenceMinutes;
    let quotes;
    if (mins > 60) {
      quotes = ['you ABANDONED us üò≠', 'FINALLY', 'we almost called CPS', 'do you even care?!', 'the audacity üò§'];
    } else if (mins > 10) {
      quotes = ['you\'re BACK! ü•∫', 'we missed you!!', 'where were you?!', 'don\'t leave again üò¢', 'FINALLY omg'];
    } else {
      quotes = ['oh hi! üëã', 'welcome back!', 'missed u ‚ù§Ô∏è', 'hey! üê≠', 'you came back! ü•∞'];
    }
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
    speechBubbles.push({
      x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
      text: quotes[Math.floor(Math.random() * quotes.length)],
      timer: 3000, maxTimer: 3000, mouseKey
    });
    sfxChitter();
  }
  // Clear after both mice have been processed
  if (state._welcomeBack) {
    state._welcomeBackProcessed = (state._welcomeBackProcessed || 0) + 1;
    if (state._welcomeBackProcessed >= 2) {
      state._welcomeBack = false;
      state._welcomeBackProcessed = 0;
    }
  }

  // Handle flung state separately
  if (mouse.action === 'flung') {
    updateFlungMouse(mouse, dt);
    return;
  }

  // Wheeling mice don't move normally ‚Äî they're on the wheel
  if (mouse.action === 'wheeling') {
    mouse.actionTimer -= dt;
    if (mouse.actionTimer <= 0) {
      mouse.action = 'idle';
      mouse.level = 'main-floor';
      mouse.actionTimer = 2000 + Math.random() * 2000;
      // Step off the wheel ‚Äî reposition to nearby floor
      const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === mouse.room);
      if (wheelPlaced) {
        const center = getWheelCenter(wheelPlaced);
        mouse.x = center.x + (Math.random() < 0.5 ? -40 : 40);
      }
    }
    return;
  }

  // On-furniture mice (hammock, rope) ‚Äî frozen in place, drawn by furniture renderer
  if (mouse.onFurniture) {
    mouse.actionTimer -= dt;
    // Periodic snore while sleeping on furniture
    if (mouse.action === 'sleeping' && mouse.room === state.currentRoom) {
      if (!mouse._snoreTimer) mouse._snoreTimer = 2000 + Math.random() * 1500;
      mouse._snoreTimer -= dt;
      if (mouse._snoreTimer <= 0) { sfxSnore(); mouse._snoreTimer = 2500 + Math.random() * 2000; }
      // Dream bubbles
      if (!mouse._dreamTimer) { mouse._dreamTimer = 1500 + Math.random() * 1500; }
      mouse._dreamTimer -= dt;
      if (mouse._dreamTimer <= 0) {
        mouse._dreamContent = pickDream();
        mouse._dreamFade = 3500;
        mouse._dreamTimer = 4000 + Math.random() * 2000;
        const mk = mouse === state.miceState.pip ? 'pip' : 'chai';
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== mk);
      }
      if (mouse._dreamFade > 0) mouse._dreamFade -= dt;
    }
    const critHungry = (mouse.happiness ?? 80) <= 15;
    if (mouse.actionTimer <= 0 || !state.placedItems.includes(mouse.onFurniture) || critHungry) {
      const pos = mouse.onFurniture ? gridToGame(mouse.onFurniture.gridX, mouse.onFurniture.gridY) : null;
      mouse.onFurniture = null;
      mouse.pendingFurniture = null;
      mouse.action = 'idle';
      mouse.level = 'main-floor';
      mouse.actionTimer = 1500 + Math.random() * 2000;
      if (pos) mouse.x = pos.x + Math.random() * 30;
      if (critHungry) pickNewAction(mouse, personality);
    }
    return;
  }

  // Climbing ramp animation
  if (mouse.action === 'climbing' && mouse.climbRamp) {
    const ramp = mouse.climbRamp;
    const speed = 0.035 * dt;
    const targetX = mouse.climbGoingUp ? ramp.x2 : ramp.x1;
    const dist = targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.x = targetX;
      mouse.level = mouse.climbTargetLevel;
      mouse.climbRamp = null;
      mouse.climbTargetLevel = null;
      mouse.climbGoingUp = null;
      // If pending furniture interaction, continue walking to the item
      if (mouse.pendingFurniture) {
        const pf = mouse.pendingFurniture;
        const itemDef = FURNITURE.find(f => f.id === pf.placed.itemId);
        const fw = (itemDef ? itemDef.w : 1) * GRID_SIZE;
        const targetPos = gridToGame(pf.placed.gridX, pf.placed.gridY);
        mouse.action = 'walking';
        mouse.targetX = targetPos.x + fw / 2;
        mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
        mouse.actionTimer = 6000;
      } else {
        mouse.action = 'idle';
        mouse.actionTimer = 600 + Math.random() * 1000;
      }
    }
    // Animate frame during climb
    mouse.animTimer += dt;
    if (mouse.animTimer > 180) { mouse.frame = (mouse.frame + 1) % 4; mouse.animTimer = 0; }
    clampMouseToPlatform(mouse);
    return;
  }

  // Animation timer
  mouse.animTimer += dt;
  if (mouse.animTimer > 180) {
    mouse.frame = (mouse.frame + 1) % 4;
    mouse.animTimer = 0;
  }

  // Periodic sounds for ongoing actions (only when mouse is in current room)
  if (mouse.room === state.currentRoom) {
    if (mouse.action === 'sleeping' && !mouse.onFurniture) {
      if (!mouse._snoreTimer) mouse._snoreTimer = 2000 + Math.random() * 1500;
      mouse._snoreTimer -= dt;
      if (mouse._snoreTimer <= 0) { sfxSnore(); mouse._snoreTimer = 2500 + Math.random() * 2000; }
      // Dream bubbles
      if (!mouse._dreamTimer) { mouse._dreamTimer = 1500 + Math.random() * 1500; }
      mouse._dreamTimer -= dt;
      if (mouse._dreamTimer <= 0) {
        mouse._dreamContent = pickDream();
        mouse._dreamFade = 3500;
        mouse._dreamTimer = 4000 + Math.random() * 2000;
        const mk = mouse === state.miceState.pip ? 'pip' : 'chai';
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== mk);
      }
      if (mouse._dreamFade > 0) mouse._dreamFade -= dt;
    } else if (mouse.action === 'grooming') {
      if (!mouse._groomTimer) mouse._groomTimer = 1500 + Math.random() * 1000;
      mouse._groomTimer -= dt;
      if (mouse._groomTimer <= 0) { sfxGroom(); mouse._groomTimer = 1800 + Math.random() * 1200; }
    } else if (mouse.action === 'chewing') {
      if (!mouse._chewTimer) mouse._chewTimer = 800 + Math.random() * 600;
      mouse._chewTimer -= dt;
      if (mouse._chewTimer <= 0) { sfxChew(); mouse._chewTimer = 1000 + Math.random() * 800; }
    }
  }

  // Idle sub-animation cycling
  if (mouse.action === 'idle') {
    if (!mouse._idleSubTimer) { mouse._idleSubTimer = 1500 + Math.random() * 1500; mouse._idleSub = 'stand'; }
    mouse._idleSubTimer -= dt;
    if (mouse._idleSubTimer <= 0) {
      mouse._idleSubTimer = 1500 + Math.random() * 1500;
      const roll = Math.random();
      if (roll < 0.30) mouse._idleSub = 'stand';
      else if (roll < 0.475) mouse._idleSub = 'lookAround';
      else if (roll < 0.65) mouse._idleSub = 'yawn';
      else if (roll < 0.825) mouse._idleSub = 'sniff';
      else mouse._idleSub = 'scratch';
    }
  } else {
    mouse._idleSub = null;
    mouse._idleSubTimer = 0;
  }

  // Hiccup processing
  if (mouse._hiccups > 0) {
    if (!mouse._hiccupTimer) mouse._hiccupTimer = 800;
    mouse._hiccupTimer -= dt;
    if (mouse._hiccupTimer <= 0) {
      mouse._hiccups--;
      mouse._hiccupTimer = 800;
      mouse._hiccupJolt = true;
      setTimeout(() => { mouse._hiccupJolt = false; }, 150);
      if (mouse.room === state.currentRoom) {
        sfxSqueak();
        const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
        speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
          text: Math.random() < 0.5 ? '*hic*' : '*hic!*', timer: 700, maxTimer: 700, mouseKey });
      }
    }
  }

  // Action timer countdown ‚Äî skip if walking to a pending transition or walking to food
  // Safety valve: if timer is very negative (stuck > 5s), allow pickNewAction to unstick
  mouse.actionTimer -= dt;
  const walkingToFood = mouse.action === 'eating' && mouse.targetX !== undefined;
  // Critical hunger interrupt: bypass timer when starving
  const criticallyHungry = (mouse.happiness ?? 80) <= 15;
  const canInterrupt = mouse.action !== 'climbing' && mouse.action !== 'flung' && mouse.action !== 'wheeling' && !mouse.pendingRoomChange && !mouse.pendingClimb;
  // Safety valve: if stuck with pending state for >3s past timer, force unstick
  if (mouse.actionTimer < -3000 && (mouse.pendingRoomChange || mouse.pendingClimb || mouse.pendingFurniture)) {
    mouse.pendingRoomChange = null;
    mouse.pendingClimb = null;
    mouse.pendingFurniture = null;
    mouse.onFurniture = null;
    mouse.targetX = undefined;
    pickNewAction(mouse, personality);
  } else if (criticallyHungry && canInterrupt && mouse.action !== 'eating') {
    pickNewAction(mouse, personality);
  } else if (mouse.actionTimer <= 0 && !mouse.pendingRoomChange && !mouse.pendingClimb && !mouse.pendingFurniture && (!walkingToFood || mouse.actionTimer < -5000)) {
    pickNewAction(mouse, personality);
  }

  // Movement
  if (mouse.action === 'walking' && mouse.targetX !== undefined) {
    const speed = 0.065 * dt;
    const dist = mouse.targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.x = mouse.targetX;
      mouse.targetX = undefined;
      // Check if we have a pending furniture interaction
      if (mouse.pendingFurniture) {
        const pf = mouse.pendingFurniture;
        mouse.action = pf.behavior;
        mouse.onFurniture = pf.placed;
        mouse.actionTimer = pf.timer;
        mouse.pendingFurniture = null;
        return;
      }
      // Check if we have a pending climb to start
      if (mouse.pendingClimb) {
        const pc = mouse.pendingClimb;
        mouse.action = 'climbing';
        mouse.climbRamp = pc.ramp;
        mouse.climbTargetLevel = pc.targetLevel;
        mouse.climbGoingUp = pc.goingUp;
        mouse.pendingClimb = null;
        return;
      }
      // Check if we have a pending room change (mouse reached the exit edge)
      if (mouse.pendingRoomChange) {
        const prc = mouse.pendingRoomChange;
        mouse.pendingRoomChange = null;
        mouse.room = prc.newRoom;
        mouse.level = 'main-floor';
        const plat = ROOMS[prc.newRoom].platforms ? ROOMS[prc.newRoom].platforms[0] : null;
        const xMin = plat ? plat.xMin + 10 : 30;
        const xMax = plat ? plat.xMax - 40 : ROOM_W - 60;
        // Enter from the opposite edge (exit right ‚Üí enter left, and vice versa)
        mouse.x = prc.exitDir > 0 ? xMin : xMax;
        mouse.dir = prc.exitDir;
        // Walk inward from the entrance
        mouse.action = 'walking';
        mouse.targetX = xMin + Math.random() * (xMax - xMin);
        mouse.actionTimer = 4000;
        return;
      }
      mouse.action = 'idle';
      mouse.actionTimer = 600 + Math.random() * 1000;
    }
  } else if (mouse.action === 'zoomies') {
    const plat = getMousePlatform(mouse);
    const xMin = plat ? plat.xMin + 10 : 20;
    const xMax = plat ? plat.xMax - 40 : ROOM_W - 50;
    const speed = 0.15 * dt;
    mouse.x += mouse.dir * speed;
    if (mouse.x > xMax) { mouse.dir = -1; }
    if (mouse.x < xMin) { mouse.dir = 1; }
  } else if (mouse.targetX !== undefined) {
    // Walk toward furniture target for any behavior
    const speed = 0.055 * dt;
    const dist = mouse.targetX - mouse.x;
    if (Math.abs(dist) > speed) {
      mouse.dir = dist > 0 ? 1 : -1;
      mouse.x += mouse.dir * speed;
    } else {
      mouse.targetX = undefined;
    }
  }

  // Food consumption: when eating near a food item with servings
  if (mouse.action === 'eating' && mouse.targetX === undefined) {
    if (!mouse._eatCooldown || mouse._eatCooldown <= 0) {
      const nearbyFood = state.placedItems.find(p => {
        if (p.room !== mouse.room) return false;
        const item = FURNITURE.find(f => f.id === p.itemId);
        if (!item || item.mouseBehavior !== 'eating' || !item.servings) return false;
        const pos = gridToGame(p.gridX, p.gridY);
        return Math.abs(mouse.x - pos.x) < 30;
      });
      if (nearbyFood) {
        if (nearbyFood.servings === undefined) nearbyFood.servings = FURNITURE.find(f => f.id === nearbyFood.itemId).servings;
        nearbyFood.servings--;
        const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
        // Happiness boost per bite
        mouse.happiness = Math.min(100, (mouse.happiness ?? 80) + 15);
        updateHappinessDisplay();
        if (mouse.room === state.currentRoom) {
          sfxMunch();
          const eatQuotes = ['*nom nom*', 'yum! üòã', 'so good', 'more pls', '*crunch*', 'delish ‚ú®'];
          speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
          speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
            text: eatQuotes[Math.floor(Math.random() * eatQuotes.length)],
            timer: 1500, maxTimer: 1500, mouseKey });
        }
        if (nearbyFood.servings <= 0) {
          // Food consumed ‚Äî remove from placed items
          state.placedItems = state.placedItems.filter(p => p !== nearbyFood);
          if (mouse.room === state.currentRoom) {
            const pos = gridToGame(nearbyFood.gridX, nearbyFood.gridY);
            spawnFloatingEffect(pos.x + 12, pos.y + 12, '‚ú®');
          }
          mouse.action = 'idle';
          mouse.actionTimer = 1000;
        }
        mouse._eatCooldown = 800; // 0.8 seconds between bites
        saveGame();
      } else {
        // No food nearby ‚Äî recover from stuck eating state
        mouse.action = 'idle';
        mouse.actionTimer = 500;
      }
    } else {
      mouse._eatCooldown -= dt;
    }
  }

  // Clamp to current platform bounds
  clampMouseToPlatform(mouse);
}

function clampMouseToPlatform(mouse) {
  // Don't clamp when walking to the room edge for a room transition
  if (mouse.pendingRoomChange) return;
  const plat = getMousePlatform(mouse);
  if (plat) {
    mouse.x = Math.max(plat.xMin + 5, Math.min(plat.xMax - 35, mouse.x));
  } else {
    mouse.x = Math.max(15, Math.min(ROOM_W - 45, mouse.x));
  }
}

function pickNewAction(mouse, personality) {
  // Clear any pending transitions and sound timers from a previous action
  mouse.pendingClimb = null;
  mouse.pendingRoomChange = null;
  mouse.pendingFurniture = null;
  mouse.onFurniture = null;
  mouse._snoreTimer = null;
  mouse._groomTimer = null;
  mouse._chewTimer = null;
  mouse._dreamTimer = null;
  mouse._dreamContent = null;
  mouse._dreamFade = 0;
  const roll = Math.random();
  const room = ROOMS[mouse.room];

  // Hunger-driven food seeking ‚Äî checked FIRST so hungry mice always prioritize food
  const isHungry = (mouse.happiness ?? 80) < 35;
  if (isHungry) {
    // Check all rooms for food with servings remaining
    const allFood = state.placedItems.filter(p => {
      const item = FURNITURE.find(f => f.id === p.itemId);
      return item && item.servings && (p.servings === undefined || p.servings > 0);
    });
    const foodInRoom = allFood.filter(p => p.room === mouse.room);

    if (foodInRoom.length > 0) {
      // Rush to nearest food in this room ‚Äî drop to main-floor first
      const target = foodInRoom[Math.floor(Math.random() * foodInRoom.length)];
      const pos = gridToGame(target.gridX, target.gridY);
      mouse.level = 'main-floor';
      mouse.action = 'eating';
      mouse.targetX = pos.x + Math.random() * 10;
      mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
      mouse.actionTimer = 8000;
      return;
    }
    // No food in this room ‚Äî walk to exit edge, then step one room toward food
    const foodElsewhere = allFood.filter(p => p.room !== mouse.room);
    if (foodElsewhere.length > 0) {
      const target = foodElsewhere[Math.floor(Math.random() * foodElsewhere.length)];
      const nextRoom = ringStepToward(mouse.room, target.room);
      const exitDir = nextRoom === roomRight(mouse.room) ? 1 : -1;
      const exitX = exitDir > 0 ? ROOM_W - 5 : 5;
      mouse.level = 'main-floor';
      mouse.action = 'walking';
      mouse.targetX = exitX;
      mouse.dir = exitDir;
      mouse.actionTimer = 12000;
      mouse.pendingRoomChange = { newRoom: nextRoom, exitDir };
      return;
    }
    // Truly no food anywhere ‚Äî complain
    if (mouse.room === state.currentRoom && Math.random() < 0.3) {
      sfxHungryWhimper();
      const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
      const noFoodQuotes = ['where\'s the food?! üò∞', '*stomach growls*', 'buy us food! üò©', 'empty bowl era üò¢'];
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
      speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: noFoodQuotes[Math.floor(Math.random() * noFoodQuotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey });
    }
  }

  // Chance to switch rooms ‚Äî 18%, moves to adjacent room on the ring
  // Mouse walks to the exit edge, then transitions to the new room
  if (roll < 0.18) {
    const otherMouse = mouse === state.miceState.pip ? state.miceState.chai : state.miceState.pip;
    let newRoom;
    if (otherMouse.room !== mouse.room && Math.random() < 0.7) {
      newRoom = ringStepToward(mouse.room, otherMouse.room);
    } else {
      newRoom = Math.random() < 0.5 ? roomLeft(mouse.room) : roomRight(mouse.room);
    }
    if (newRoom !== mouse.room) {
      // Determine exit direction: left neighbor = walk left, right neighbor = walk right
      const exitDir = newRoom === roomRight(mouse.room) ? 1 : -1;
      // Target the actual room wall edge (beyond platform clamp)
      const exitX = exitDir > 0 ? ROOM_W - 5 : 5;
      // Walk to the exit edge, then room switch happens on arrival
      mouse.level = 'main-floor';
      mouse.action = 'walking';
      mouse.targetX = exitX;
      mouse.dir = exitDir;
      mouse.actionTimer = 12000;
      mouse.pendingRoomChange = { newRoom, exitDir };
      return;
    }
    mouse.action = 'idle';
    mouse.actionTimer = 800 + Math.random() * 1200;
    return;
  }

  // Chance to switch levels (climb ramp) ‚Äî 30% if room has ramps
  if (room.ramps && room.ramps.length > 0 && roll < 0.48) {
    // Find a ramp accessible from current level
    const availableRamps = room.ramps.filter(r => r.from === mouse.level || r.to === mouse.level);
    if (availableRamps.length > 0) {
      const ramp = availableRamps[Math.floor(Math.random() * availableRamps.length)];
      const goingUp = ramp.from === mouse.level;
      const targetLevel = goingUp ? ramp.to : ramp.from;

      // First walk to the ramp entrance, then climb
      const rampEntryX = goingUp ? ramp.x1 : ramp.x2;
      mouse.action = 'walking';
      mouse.targetX = rampEntryX;
      mouse.dir = rampEntryX > mouse.x ? 1 : -1;
      mouse.actionTimer = 6000;

      // Set up climb state ‚Äî will activate when mouse reaches ramp
      mouse.pendingClimb = { ramp, targetLevel, goingUp };
      return;
    }
  }

  // Check what furniture behaviors are available in this room
  const roomItems = state.placedItems.filter(p => p.room === mouse.room);
  const furnitureBehaviors = [];
  roomItems.forEach(placed => {
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (item && item.mouseBehavior && !furnitureBehaviors.includes(item.mouseBehavior)) {
      furnitureBehaviors.push({ behavior: item.mouseBehavior, placed });
    }
  });

  // 40% chance to interact with furniture if any is available
  if (furnitureBehaviors.length > 0 && Math.random() < 0.4) {
    let pick;
    // Pip is hungrier ‚Äî strongly prefers food items
    const foodBehaviors = furnitureBehaviors.filter(fb => fb.behavior === 'eating');
    if (personality === 'chaotic' && foodBehaviors.length > 0 && Math.random() < 0.6) {
      pick = foodBehaviors[Math.floor(Math.random() * foodBehaviors.length)];
    } else {
      // Both mice love the exercise wheel ‚Äî high preference
      const wheelBehaviors = furnitureBehaviors.filter(fb => fb.behavior === 'wheeling');
      if (wheelBehaviors.length > 0 && Math.random() < 0.5) {
        pick = wheelBehaviors[0];
      } else {
        pick = furnitureBehaviors[Math.floor(Math.random() * furnitureBehaviors.length)];
      }
    }
    mouse.action = pick.behavior;
    // Play sound when behavior starts (only if mouse is in visible room)
    if (mouse.room === state.currentRoom) {
      if (pick.behavior === 'zoomies') sfxZoomieSqueak();
      else if (pick.behavior === 'hiding') sfxHide();
      else if (pick.behavior === 'swinging') sfxSwing();
    }
    const targetPos = gridToGame(pick.placed.gridX, pick.placed.gridY);
    mouse.targetX = targetPos.x + Math.random() * 10;
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 3000 + Math.random() * 4000;
    if (pick.behavior === 'sleeping') mouse.actionTimer = 6000 + Math.random() * 6000;
    if (pick.behavior === 'zoomies') mouse.actionTimer = 2000 + Math.random() * 2000;
    if (pick.behavior === 'wheeling') mouse.actionTimer = 4000 + Math.random() * 5000;
    if (pick.behavior === 'hiding') mouse.actionTimer = 3000 + Math.random() * 3000;
    if (pick.behavior === 'chewing') mouse.actionTimer = 2000 + Math.random() * 2000;
    if (pick.behavior === 'swinging') mouse.actionTimer = 4000 + Math.random() * 4000;
    // Hammock and climbing rope: walk to the item first, then mount it
    if ((pick.behavior === 'sleeping' && pick.placed.itemId === 'hammock') ||
        pick.behavior === 'swinging') {
      const itemDef = FURNITURE.find(f => f.id === pick.placed.itemId);
      const fw = (itemDef ? itemDef.w : 1) * GRID_SIZE;
      mouse.pendingFurniture = { behavior: pick.behavior, placed: pick.placed, timer: mouse.actionTimer };
      mouse.action = 'walking';
      mouse.actionTimer = 10000;
      // Check if mouse needs to climb to the furniture's platform
      const furnPlatform = getFurniturePlatform(mouse.room, pick.placed);
      if (mouse.level !== furnPlatform) {
        const room = ROOMS[mouse.room];
        const ramp = room.ramps && room.ramps.find(r =>
          (r.from === mouse.level && r.to === furnPlatform) ||
          (r.to === mouse.level && r.from === furnPlatform));
        if (ramp) {
          const goingUp = ramp.from === mouse.level;
          mouse.targetX = goingUp ? ramp.x1 : ramp.x2;
          mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
          mouse.pendingClimb = { ramp, targetLevel: furnPlatform, goingUp };
        } else {
          mouse.targetX = targetPos.x + fw / 2;
          mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
        }
      } else {
        mouse.targetX = targetPos.x + fw / 2;
        mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
      }
    }
    // Speech for new behaviors
    if (mouse.room === state.currentRoom) {
      const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
      let quotes = null;
      if (pick.behavior === 'hiding') {
        quotes = mouseKey === 'pip'
          ? ['you can\'t see me! ü´£', '*tunneling*', 'stealth 100', 'am I invisible yet?', 'secret passage!']
          : ['cozy in here ü•∞', '*peeks out*', 'introvert recharging', 'my safe space', 'tunnel vision'];
      } else if (pick.behavior === 'chewing') {
        quotes = mouseKey === 'pip'
          ? ['*cronch cronch*', 'teething era ü¶∑', 'this is mine now', 'stress relief üíØ', 'good texture']
          : ['*nibble nibble*', 'therapeutic', 'chew toy acquired', 'zen mode üßò', 'very satisfying'];
      } else if (pick.behavior === 'swinging') {
        quotes = mouseKey === 'pip'
          ? ['PARKOUR! üí™', 'spider-mouse!', 'look no paws!', 'vertical zoomies!', 'I\'m basically an acrobat']
          : ['wheee! üé™', 'hang in there', 'this is fun actually', '*swings gently*', 'circus era'];
      }
      if (quotes) {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
        speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
          text: quotes[Math.floor(Math.random() * quotes.length)],
          timer: 2500, maxTimer: 2500, mouseKey });
      }
    }
    return;
  }

  // Personality-weighted action selection ‚Äî both mice are hyper
  let weights;
  if (personality === 'chaotic') {
    // Pip: very active, lots of zoomies and mischief
    weights = [
      { action: 'idle', w: 4 },
      { action: 'walking', w: 34 },
      { action: 'sleeping', w: 6 },
      { action: 'zoomies', w: 24 },
      { action: 'grooming', w: 8 },
      { action: 'mischief', w: 16 }
    ];
  } else {
    // Chai: still hyper but slightly more balanced
    weights = [
      { action: 'idle', w: 6 },
      { action: 'walking', w: 30 },
      { action: 'sleeping', w: 10 },
      { action: 'zoomies', w: 18 },
      { action: 'grooming', w: 12 },
      { action: 'mischief', w: 12 }
    ];
  }

  const totalW = weights.reduce((s, w) => s + w.w, 0);
  let pick = Math.random() * totalW;
  let chosen = 'idle';
  for (const w of weights) {
    pick -= w.w;
    if (pick <= 0) { chosen = w.action; break; }
  }

  mouse.action = chosen;

  if (chosen === 'walking') {
    const plat = getMousePlatform(mouse);
    const xMin = plat ? plat.xMin + 10 : 20;
    const xMax = plat ? plat.xMax - 40 : ROOM_W - 70;
    mouse.targetX = xMin + Math.random() * (xMax - xMin);
    mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    mouse.actionTimer = 5000;
  } else if (chosen === 'sleeping') {
    // Seek hammock if available ‚Äî strong preference for cozy sleeping
    const hammocks = state.placedItems.filter(p => p.itemId === 'hammock');
    const hammockInRoom = hammocks.find(p => p.room === mouse.room);
    if (hammockInRoom) {
      const pos = gridToGame(hammockInRoom.gridX, hammockInRoom.gridY);
      const fw = 3 * GRID_SIZE;
      mouse.pendingFurniture = { behavior: 'sleeping', placed: hammockInRoom, timer: 5000 + Math.random() * 4000 };
      mouse.action = 'walking';
      mouse.actionTimer = 10000;
      // Climb to hammock's platform if needed
      const furnPlatform = getFurniturePlatform(mouse.room, hammockInRoom);
      if (mouse.level !== furnPlatform) {
        const room = ROOMS[mouse.room];
        const ramp = room.ramps && room.ramps.find(r =>
          (r.from === mouse.level && r.to === furnPlatform) ||
          (r.to === mouse.level && r.from === furnPlatform));
        if (ramp) {
          const goingUp = ramp.from === mouse.level;
          mouse.targetX = goingUp ? ramp.x1 : ramp.x2;
          mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
          mouse.pendingClimb = { ramp, targetLevel: furnPlatform, goingUp };
        } else {
          mouse.targetX = pos.x + fw / 2;
          mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
        }
      } else {
        mouse.targetX = pos.x + fw / 2;
        mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
      }
      if (mouse.room === state.currentRoom && Math.random() < 0.4) {
        const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
        speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
          text: ['hammock time üõèÔ∏è', 'nap pod activated', 'the coziest spot', '*climbs in*', 'hammock calls'][Math.floor(Math.random() * 5)],
          timer: 2500, maxTimer: 2500, mouseKey });
      }
    } else if (hammocks.length > 0 && Math.random() < 0.4) {
      // Hammock in another room ‚Äî walk toward it
      const target = hammocks[0];
      const nextRoom = ringStepToward(mouse.room, target.room);
      const exitDir = nextRoom === roomRight(mouse.room) ? 1 : -1;
      mouse.action = 'walking';
      mouse.level = 'main-floor';
      mouse.targetX = exitDir > 0 ? ROOM_W - 5 : 5;
      mouse.dir = exitDir;
      mouse.actionTimer = 12000;
      mouse.pendingRoomChange = { newRoom: nextRoom, exitDir };
      return;
    } else {
      mouse.actionTimer = 3000 + Math.random() * 4000;
    }
  } else if (chosen === 'zoomies') {
    mouse.actionTimer = 2500 + Math.random() * 2000;
    mouse.dir = Math.random() < 0.5 ? 1 : -1;
    if (mouse.room === state.currentRoom) sfxZoomies();
  } else if (chosen === 'grooming') {
    mouse.actionTimer = 2500 + Math.random() * 2500;
    if (mouse.room === state.currentRoom) {
      const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
      const groomQuotes = ['*lick lick*', 'gotta stay clean', 'spa day üíÖ', 'self-care era', '*grooming intensifies*'];
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
      speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: groomQuotes[Math.floor(Math.random() * groomQuotes.length)],
        timer: 2000, maxTimer: 2000, mouseKey });
    }
  } else if (chosen === 'mischief') {
    mouse.actionTimer = 3000 + Math.random() * 3000;
    const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';
    // Walk to a random furniture item or shelf
    const roomItems = state.placedItems.filter(p => p.room === mouse.room);
    if (roomItems.length > 0) {
      const target = roomItems[Math.floor(Math.random() * roomItems.length)];
      const tPos = gridToGame(target.gridX, target.gridY);
      mouse.targetX = tPos.x + Math.random() * 10;
      mouse.dir = mouse.targetX > mouse.x ? 1 : -1;
    }
    if (mouse.room === state.currentRoom) {
      state.stats.mischiefsWitnessed++;
      const pipMischief = [
        '*knocks thing off shelf*', 'oops üòà', 'wasn\'t me', 'chaos is a ladder',
        '*pushes to edge*', 'no thoughts just crimes', '*yeets item*',
        'watch this‚Äî', 'what does this button do', '*chews on wire*',
        'gravity test! üìâ', 'for science üî¨', 'the shelf had it coming'
      ];
      const chaiMischief = [
        '*claims this spot*', 'this is mine now', '*hides*', 'you can\'t see me üëÄ',
        '*box acquired*', 'stealth mode', '*reorganizes everything*',
        'I live here now', '*tunnels into blanket*', 'invisible mouse activated',
        'if I fits I sits', '*rearranges furniture*', 'feng shui üéã'
      ];
      const quotes = personality === 'chaotic' ? pipMischief : chaiMischief;
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
      speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: quotes[Math.floor(Math.random() * quotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey });
      // Visual mischief effect
      if (roomItems.length > 0 && Math.random() < 0.4) {
        const effectItem = roomItems[Math.floor(Math.random() * roomItems.length)];
        const ePos = gridToGame(effectItem.gridX, effectItem.gridY);
        const effects = ['üí•', '‚≠ê', '‚ùó', 'üí´', 'üåÄ'];
        spawnFloatingEffect(ePos.x + 12, ePos.y + 6, effects[Math.floor(Math.random() * effects.length)]);
      }
    }
  } else {
    mouse.actionTimer = 800 + Math.random() * 1200;
  }
}

// Draw status bar at the bottom showing mouse names + actions
function drawMouseStatus() {
  const pip = state.miceState.pip;
  const chai = state.miceState.chai;
  const y = GAME_H - 8;

  ctx.save();
  ctx.font = '10px monospace';
  ctx.textBaseline = 'alphabetic';

  const actionIcons = { sleeping: 'üí§', walking: 'üêæ', zoomies: 'üí®', eating: 'üòã',
    doomscrolling: 'üì±', watching: 'üì∫', yoga: 'üßò', playing: 'üèÉ',
    wheeling: 'üé°', flung: 'üòµ‚Äçüí´', climbing: 'ü™ú', grooming: 'üíÖ', mischief: 'üòà', stretching: 'üôÜ',
    hiding: 'ü´£', chewing: 'ü™µ', swinging: 'ü™¢' };

  // Pip status (left)
  const sIcon = actionIcons[pip.action] || '‚ú®';
  let pipText = `${sIcon} ${CONFIG.mice.pip.name}: ${pip.action}`;
  const pipHappy = pip.happiness ?? 80;
  if (pipHappy < 35) pipText += ' üçΩ';
  if (pip.room !== state.currentRoom) {
    pipText += ` (${ROOMS[pip.room].icon})`;
  }
  ctx.fillStyle = pipHappy < 35 ? '#e06050' : '#888';
  ctx.textAlign = 'left';
  ctx.fillText(pipText, 8, y);

  // Chai status (right)
  const cIcon = actionIcons[chai.action] || '‚ú®';
  let chaiText = `${cIcon} ${CONFIG.mice.chai.name}: ${chai.action}`;
  const chaiHappy = chai.happiness ?? 80;
  if (chaiHappy < 35) chaiText += ' üçΩ';
  if (chai.room !== state.currentRoom) {
    chaiText += ` (${ROOMS[chai.room].icon})`;
  }
  ctx.fillStyle = chaiHappy < 35 ? '#e06050' : '#888';
  ctx.textAlign = 'right';
  ctx.fillText(chaiText, GAME_W - 8, y);

  ctx.restore();
}

// ============================================================
// SPEECH BUBBLES & FLOATING EFFECTS
// ============================================================
const PIP_QUOTES = [
  'no thoughts head empty', 'chaos mode activated', 'catch me if you can üí®',
  'it\'s giving... gremlin', 'slay', 'built different tbh', 'caught in 4k üì∏',
  'living my best cheese life', 'zero chill, full send', 'main character energy',
  'this is fine üî•', 'unhinged and unbothered', 'speed run any%', 'yeet',
  'bet', 'say less', 'lowkey feral rn', 'bestie wake up', 'ZOOM', 'not sorry üòà',
  'is there more cheese??', 'snack break? snack break.', 'I smell food üëÉ',
  'built different (and hungry)', 'cheese is a personality trait',
  'what if I just... *pushes thing*', 'crime time üê≠', 'no rules just vibes',
  '*stares at you*', 'u watching me? üëÄ', 'plot twist: I\'m the main character',
  'brb causing problems', '*knocks over cup*', 'the intrusive thoughts won',
  'alexa play despacito', 'I did NOT eat that', 'it was like that when I got here',
  'actually this is MY shelf', 'smol but mighty', 'touch grass? I AM grass',
  'certified hood classic', 'ratio', 'skill issue tbh', 'L + no cheese',
  'just vibing (chaotically)', '*exists aggressively*'
];
const CHAI_QUOTES = [
  'this is giving cozy', 'soft hours only üåô', 'no thoughts, just vibes',
  'not me napping again', 'it\'s giving... mouse', 'sleepy but slay',
  'wholesome content only', 'living slow üêå', 'comfort is key', 'gentle chaos',
  'self care is sleeping', 'cozy era', 'manifesting cheese ‚ú®', 'just existing üí´',
  'zzz is a lifestyle', 'pls don\'t wake me', 'warm thoughts only', 'soft launch üßÄ',
  'cottagecore mouse', 'peace was always an option üïä',
  '*contemplates existence*', 'this room has good energy', 'what a time to be alive',
  'dreaming of cheese rn', 'noted üìù', 'very demure, very mindful',
  'literally just standing here', 'quiet luxury üê≠', 'idk I just live here',
  '*stares into distance*', 'the floor is warm here', 'healing arc üåø',
  'today I choose peace', 'Pip is being chaotic again', '*judges silently*',
  'this is my emotional support room', 'I\'m baby ü•∫', 'nap first, think later',
  'the vibe is immaculate', '*blinks slowly*', 'it me'
];

const WHEEL_QUOTES = [
  'CARDIO üí™', 'fitness era', 'running from my problems',
  'marathon training arc', 'can\'t stop won\'t stop', 'legs go brrr',
  'gym rat? no. gym MOUSE', 'my fitbit is shaking',
  'hot mouse summer prep', 'this counts as a marathon right',
  'i am speed üèÉ', 'wheeeeel!', 'spinning into my best self'
];

let speechBubbles = [];  // { x, y, text, timer, maxTimer, mouseKey }
let floatingEffects = []; // { x, y, text, timer, vy }

let speechCooldown = 5000 + Math.random() * 5000; // 5-10 sec

function triggerSpeech(mouseKey) {
  const mouse = state.miceState[mouseKey];
  if (mouse.room !== state.currentRoom) return;
  // Sleeping mice dream instead of talking
  if (mouse.action === 'sleeping') return;
  let quotes;
  if (mouse.action === 'wheeling') {
    quotes = WHEEL_QUOTES;
  } else {
    // Mix personality quotes with context-sensitive ones
    const base = mouseKey === 'pip' ? PIP_QUOTES : CHAI_QUOTES;
    const contextual = [];
    // Room-specific
    const roomIdx = mouse.room;
    if (roomIdx === 0) contextual.push('bedroom vibes üõè', 'cozy in here', 'nap room best room');
    if (roomIdx === 1) contextual.push('kitchen raid üç≥', 'anything to eat?', 'chef mode');
    if (roomIdx === 2) contextual.push('living room energy', 'tv time?', 'prime hangout spot');
    if (roomIdx === 3) contextual.push('leg day üí™', 'gym arc', 'do I look buff?');
    // Action-specific
    if (mouse.action === 'zoomies') contextual.push('CAN\'T STOP üí®', 'SPEEED', 'I\'m fast as heck boi');
    if (mouse.action === 'grooming') contextual.push('glow up era ‚ú®', 'self care sunday', 'mirror mirror');
    // Happiness-dependent
    if ((mouse.happiness ?? 80) > 80) contextual.push('life is good üòä', 'peak happiness', '10/10 no notes');
    if ((mouse.happiness ?? 80) < 25) contextual.push('feed me pls üò©', 'fading...', 'hello? food?');
    // 30% chance of contextual quote if available
    if (contextual.length > 0 && Math.random() < 0.3) {
      quotes = contextual;
    } else {
      quotes = base;
    }
  }
  const text = quotes[Math.floor(Math.random() * quotes.length)];
  speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
  speechBubbles.push({
    x: mouse.x + 14,
    y: getMouseFloorY(mouse) - 10,
    text, timer: 3000, maxTimer: 3000, mouseKey
  });
  sfxChitter();
}

function updateSpeechBubbles(dt) {
  speechCooldown -= dt;
  if (speechCooldown <= 0) {
    speechCooldown = 5000 + Math.random() * 5000;
    // Pick a random mouse to speak
    const mouseKey = Math.random() < 0.5 ? 'pip' : 'chai';
    triggerSpeech(mouseKey);
  }
  speechBubbles.forEach(b => {
    b.timer -= dt;
    // Track mouse position (handle wheel and flung states)
    const mouse = state.miceState[b.mouseKey];
    if (mouse.action === 'flung' && mouse.flingX !== undefined) {
      b.x = mouse.flingX + 14;
      b.y = mouse.flingY - 10;
    } else if (mouse.action === 'wheeling') {
      const wheelPlaced = state.placedItems.find(p => p.itemId === 'exercise-wheel' && p.room === mouse.room);
      if (wheelPlaced) {
        const center = getWheelCenter(wheelPlaced);
        b.x = center.x;
        b.y = center.y - 40;
      }
    } else {
      b.x = mouse.x + 14;
      b.y = getMouseFloorY(mouse) - 10;
    }
  });
  speechBubbles = speechBubbles.filter(b => b.timer > 0);
}

function drawSpeechBubbles() {
  speechBubbles.forEach(b => {
    // Only draw bubbles for mice in the currently viewed room
    const mouse = state.miceState[b.mouseKey];
    if (mouse && mouse.room !== state.currentRoom) return;

    const alpha = Math.min(1, b.timer / 500); // fade out last 500ms
    ctx.globalAlpha = alpha;
    ctx.font = '9px monospace';
    const tw = ctx.measureText(b.text).width;
    const pw = tw + 12;
    const ph = 18;
    const px = Math.max(4, Math.min(GAME_W - pw - 4, b.x - pw / 2));
    const py = b.y - ph - 8;

    // Bubble bg
    ctx.fillStyle = 'rgba(255,250,240,0.92)';
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, 6);
    ctx.fill();
    // Bubble border
    ctx.strokeStyle = 'rgba(180,150,100,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, 6);
    ctx.stroke();
    // Tail triangle
    ctx.fillStyle = 'rgba(255,250,240,0.92)';
    ctx.beginPath();
    ctx.moveTo(b.x - 4, py + ph);
    ctx.lineTo(b.x, py + ph + 6);
    ctx.lineTo(b.x + 4, py + ph);
    ctx.fill();
    // Text
    ctx.fillStyle = '#3a2a1a';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.text, px + pw / 2, py + ph / 2);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.globalAlpha = 1.0;
  });
}

function spawnFloatingEffect(x, y, text) {
  floatingEffects.push({ x, y, text, timer: 1200, vy: -0.04 });
}

function updateFloatingEffects(dt) {
  floatingEffects.forEach(e => {
    e.timer -= dt;
    e.y += e.vy * dt;
    e.x += Math.sin(Date.now() / 200 + e.y) * 0.15;
  });
  floatingEffects = floatingEffects.filter(e => e.timer > 0);
}

function drawFloatingEffects() {
  floatingEffects.forEach(e => {
    const alpha = Math.min(1, e.timer / 400);
    ctx.globalAlpha = alpha;
    ctx.font = '14px serif';
    ctx.textAlign = 'center';
    ctx.fillText(e.text, e.x, e.y);
    ctx.textAlign = 'left';
    ctx.globalAlpha = 1.0;
  });
}

// ============================================================
// CLICK-TO-PET
// ============================================================
function tryPetMouse(gx, gy) {
  const mice = [
    { key: 'pip', state: state.miceState.pip, cfg: CONFIG.mice.pip },
    { key: 'chai', state: state.miceState.chai, cfg: CONFIG.mice.chai }
  ];
  for (const m of mice) {
    if (m.state.room !== state.currentRoom) continue;
    const mx = m.state.x;
    const my = getMouseFloorY(m.state);
    if (gx > mx - 5 && gx < mx + 30 && gy > my - 10 && gy < my + 25) {
      // Pet this mouse!
      sfxPet();
      // Petting costs 1 coin; if broke, reduced happiness gain
      const petCost = 1;
      let hapBoost = 5;
      if (state.coins >= petCost) {
        state.coins -= petCost;
        updateCoinDisplay();
      } else {
        hapBoost = 2;
      }
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          spawnFloatingEffect(
            mx + 10 + (Math.random() - 0.5) * 20,
            my - 5 - Math.random() * 15,
            ['‚ù§Ô∏è', 'üíï', 'üíñ', 'üíó', 'ü•∞'][Math.floor(Math.random() * 5)]
          );
        }, i * 100);
      }
      // Mouse reacts
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== m.key);
      const petQuotes = m.key === 'pip'
        ? ['okay that\'s nice', 'more pls ü•∫', '*purrs in mouse*', 'acceptable', 'don\'t stop üëÄ', 'feed me tho']
        : ['ü•∞ü•∞ü•∞', 'best day ever', '*happy squeak*', 'i love you', 'this is everything'];
      speechBubbles.push({
        x: mx + 14, y: my - 10,
        text: petQuotes[Math.floor(Math.random() * petQuotes.length)],
        timer: 2500, maxTimer: 2500, mouseKey: m.key
      });
      // Briefly pause their action (they enjoy it), then spring into action
      m.state.action = 'idle';
      m.state.actionTimer = 800;
      m.state.happiness = Math.min(100, (m.state.happiness ?? 80) + hapBoost);
      // After the pet reaction, motivate an active behavior
      const mouseRef = m.state;
      const pers = m.key === 'pip' ? 'chaotic' : 'chill';
      setTimeout(() => {
        if (mouseRef.action === 'idle') {
          const actions = ['walking', 'zoomies', 'mischief', 'walking'];
          const pick = actions[Math.floor(Math.random() * actions.length)];
          mouseRef.action = pick;
          if (pick === 'walking') {
            const plat = getMousePlatform(mouseRef);
            const xMin = plat ? plat.xMin + 10 : 20;
            const xMax = plat ? plat.xMax - 40 : ROOM_W - 70;
            mouseRef.targetX = xMin + Math.random() * (xMax - xMin);
            mouseRef.dir = mouseRef.targetX > mouseRef.x ? 1 : -1;
            mouseRef.actionTimer = 4000;
          } else if (pick === 'zoomies') {
            mouseRef.actionTimer = 2000 + Math.random() * 1500;
            mouseRef.dir = Math.random() < 0.5 ? 1 : -1;
            if (mouseRef.room === state.currentRoom) sfxZoomieSqueak();
          } else {
            mouseRef.actionTimer = 2000 + Math.random() * 2000;
          }
        }
      }, 900);
      return true;
    }
  }
  return false;
}

// ============================================================
// MOUSE INTERACTIONS (when both in same room)
// ============================================================
let interactionCooldown = 4000 + Math.random() * 4000;

function updateMouseInteractions(dt) {
  const s = state.miceState.pip;
  const c = state.miceState.chai;
  if (s.room !== c.room) { interactionCooldown = 2000 + Math.random() * 2000; return; }
  // Don't interrupt mice that are on furniture
  const sOnFurn = s.onFurniture || s.action === 'wheeling';
  const cOnFurn = c.onFurniture || c.action === 'wheeling';

  // Startled reaction: if one mouse zooms past the other
  if (s.action === 'zoomies' && c.action !== 'zoomies' && c.action !== 'sleeping' && c.action !== 'flung') {
    if (Math.abs(s.x - c.x) < 25 && !c._startled) {
      c._startled = true;
      c._startleTimer = 600;
      if (c.room === state.currentRoom) sfxStartled();
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'chai');
      speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
        text: ['‚ùó', 'AH!', 'omg', 'üò±', 'WHAT', 'excuse me?!', 'RUDE'][Math.floor(Math.random() * 7)],
        timer: 1200, maxTimer: 1200, mouseKey: 'chai' });
    }
  }
  if (c.action === 'zoomies' && s.action !== 'zoomies' && s.action !== 'sleeping' && s.action !== 'flung') {
    if (Math.abs(c.x - s.x) < 25 && !s._startled) {
      s._startled = true;
      s._startleTimer = 600;
      if (s.room === state.currentRoom) sfxStartled();
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip');
      speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
        text: ['‚ùó', 'AH!', 'bruh', 'üò±', 'HEY', 'personal space!', 'watch it!'][Math.floor(Math.random() * 7)],
        timer: 1200, maxTimer: 1200, mouseKey: 'pip' });
    }
  }
  // Decay startle
  if (s._startled) { s._startleTimer -= dt; if (s._startleTimer <= 0) s._startled = false; }
  if (c._startled) { c._startleTimer -= dt; if (c._startleTimer <= 0) c._startled = false; }

  // Copy-cat behavior: if one starts an action, other might copy
  if (!s._copyCooldown) s._copyCooldown = 0;
  if (!c._copyCooldown) c._copyCooldown = 0;
  s._copyCooldown = Math.max(0, s._copyCooldown - dt);
  c._copyCooldown = Math.max(0, c._copyCooldown - dt);
  const copyActions = ['zoomies', 'grooming', 'sleeping'];
  if (copyActions.includes(s.action) && c.action === 'idle' && !cOnFurn && c._copyCooldown <= 0 && Math.random() < 0.002) {
    c.action = s.action;
    c.actionTimer = s.actionTimer;
    c.dir = s.dir;
    c._copyCooldown = 10000;
    if (c.room === state.currentRoom) {
      sfxChitter();
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'chai');
      speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
        text: ['me too!', '*copies*', 'monkey see monkey do', 'same tbh', 'mood'][Math.floor(Math.random() * 5)],
        timer: 2000, maxTimer: 2000, mouseKey: 'chai' });
    }
  }
  if (copyActions.includes(c.action) && s.action === 'idle' && !sOnFurn && s._copyCooldown <= 0 && Math.random() < 0.002) {
    s.action = c.action;
    s.actionTimer = c.actionTimer;
    s.dir = c.dir;
    s._copyCooldown = 10000;
    if (s.room === state.currentRoom) {
      sfxChitter();
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip');
      speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
        text: ['wait me too', '*copies*', 'same energy', 'I also choose this', 'vibe check passed'][Math.floor(Math.random() * 5)],
        timer: 2000, maxTimer: 2000, mouseKey: 'pip' });
    }
  }

  interactionCooldown -= dt;
  if (interactionCooldown > 0) return;
  if (sOnFurn || cOnFurn) return;
  interactionCooldown = 5000 + Math.random() * 5000;

  const interaction = Math.random();

  if (interaction < 0.18) {
    // Nuzzle/nose-boop: move toward each other, then heart burst
    const midX = (s.x + c.x) / 2;
    s.action = 'walking'; s.targetX = midX - 12; s.dir = 1;
    c.action = 'walking'; c.targetX = midX + 12; c.dir = -1;
    s.actionTimer = 4000; c.actionTimer = 4000;
    setTimeout(() => {
      if (s.room === c.room && s.room === state.currentRoom) {
        sfxNuzzle();
        const boopX = (s.x + c.x) / 2 + 14;
        const boopY = getMouseFloorY(s) - 5;
        for (let i = 0; i < 4; i++) {
          setTimeout(() => {
            spawnFloatingEffect(boopX + (Math.random() - 0.5) * 20, boopY - Math.random() * 10,
              ['üíï', 'üíñ', '‚ú®', 'ü•∞'][i % 4]);
          }, i * 100);
        }
        triggerSpeech(Math.random() < 0.5 ? 'pip' : 'chai');
      }
    }, 2000);
  } else if (interaction < 0.32) {
    // Play-chase: Pip chases Chai (or vice versa)
    const chaser = Math.random() < 0.6 ? s : c;
    const runner = chaser === s ? c : s;
    const chaserKey = chaser === s ? 'pip' : 'chai';
    const runnerKey = chaser === s ? 'chai' : 'pip';
    runner.action = 'walking';
    runner.targetX = Math.random() < 0.5 ? 40 : ROOM_W - 60;
    runner.dir = runner.targetX > runner.x ? 1 : -1;
    runner.actionTimer = 4000;
    chaser.action = 'walking';
    chaser.dir = runner.dir;
    chaser.actionTimer = 4000;
    setTimeout(() => {
      chaser.targetX = runner.targetX + (Math.random() < 0.5 ? -20 : 20);
    }, 400);
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== chaserKey);
    speechBubbles.push({
      x: chaser.x + 14, y: getMouseFloorY(chaser) - 10,
      text: chaserKey === 'pip' ? 'get back here! üí®' : 'wheee! üèÉ',
      timer: 2000, maxTimer: 2000, mouseKey: chaserKey
    });
    // Runner reacts
    setTimeout(() => {
      if (runner.room === state.currentRoom) {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== runnerKey);
        speechBubbles.push({ x: runner.x + 14, y: getMouseFloorY(runner) - 10,
          text: ['you\'ll never catch me!', 'NOT AGAIN', '*screeee*', 'help! üòÇ', 'faster! üí®'][Math.floor(Math.random() * 5)],
          timer: 2000, maxTimer: 2000, mouseKey: runnerKey });
      }
    }, 800);
  } else if (interaction < 0.42) {
    // Synchronized sleeping: both curl up nearby
    if (s.action !== 'wheeling' && c.action !== 'wheeling') {
      const napX = 100 + Math.random() * (ROOM_W - 200);
      s.action = 'walking'; s.targetX = napX - 20; s.dir = 1; s.actionTimer = 3000;
      c.action = 'walking'; c.targetX = napX + 10; c.dir = -1; c.actionTimer = 3000;
      setTimeout(() => {
        if (s.room === c.room) {
          s.action = 'sleeping'; s.actionTimer = 6000 + Math.random() * 4000;
          c.action = 'sleeping'; c.actionTimer = 6000 + Math.random() * 4000;
          if (s.room === state.currentRoom) {
            spawnFloatingEffect((s.x + c.x) / 2 + 14, getMouseFloorY(s) - 15, 'üò¥');
          }
        }
      }, 2500);
    }
  } else if (interaction < 0.52) {
    // Play-grooming: one grooms the other
    const groomer = Math.random() < 0.5 ? s : c;
    const groomee = groomer === s ? c : s;
    const groomerKey = groomer === s ? 'pip' : 'chai';
    const groomeeKey = groomer === s ? 'chai' : 'pip';
    groomer.action = 'walking';
    groomer.targetX = groomee.x + (groomer.x > groomee.x ? 15 : -15);
    groomer.dir = groomee.x > groomer.x ? 1 : -1;
    groomer.actionTimer = 5000;
    setTimeout(() => {
      if (groomer.room === groomee.room) {
        groomer.action = 'grooming';
        groomer.actionTimer = 3000;
        groomer.dir = groomee.x > groomer.x ? 1 : -1;
        groomee.action = 'idle';
        groomee.actionTimer = 3000;
        if (groomer.room === state.currentRoom) {
          speechBubbles = speechBubbles.filter(b => b.mouseKey !== groomeeKey);
          speechBubbles.push({ x: groomee.x + 14, y: getMouseFloorY(groomee) - 10,
            text: ['thx bestie ü•∫', 'aww', 'don\'t stop', 'ü•∞', 'this is nice'][Math.floor(Math.random() * 5)],
            timer: 2500, maxTimer: 2500, mouseKey: groomeeKey });
        }
      }
    }, 1500);
  } else if (interaction < 0.62) {
    // Synchronized zoomies ‚Äî both go wild
    if (s.action !== 'wheeling' && c.action !== 'wheeling') {
      s.action = 'zoomies'; s.actionTimer = 2500 + Math.random() * 1500;
      c.action = 'zoomies'; c.actionTimer = 2500 + Math.random() * 1500;
      s.dir = 1; c.dir = -1;
      if (s.room === state.currentRoom) {
        sfxZoomieSqueak();
        sfxZoomies();
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip' && b.mouseKey !== 'chai');
        speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
          text: ['ZOOMIES!!! üí®', 'RACE!! üèÅ', 'CAN\'T STOP'][Math.floor(Math.random() * 3)],
          timer: 2000, maxTimer: 2000, mouseKey: 'pip' });
        speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
          text: ['WHEEE!', 'SO FAST!', 'NYOOOM üí®'][Math.floor(Math.random() * 3)],
          timer: 2000, maxTimer: 2000, mouseKey: 'chai' });
      }
    }
  } else if (interaction < 0.72) {
    // Stolen food drama ‚Äî one mouse walks to the other and they have a "moment"
    const thief = Math.random() < 0.6 ? s : c;
    const victim = thief === s ? c : s;
    const thiefKey = thief === s ? 'pip' : 'chai';
    const victimKey = thief === s ? 'chai' : 'pip';
    thief.action = 'walking';
    thief.targetX = victim.x + (thief.x > victim.x ? 15 : -15);
    thief.dir = victim.x > thief.x ? 1 : -1;
    thief.actionTimer = 4000;
    setTimeout(() => {
      if (thief.room === victim.room && thief.room === state.currentRoom) {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== thiefKey);
        speechBubbles.push({ x: thief.x + 14, y: getMouseFloorY(thief) - 10,
          text: thiefKey === 'pip'
            ? ['gimme your cheese üßÄ', '*steals snack*', 'what\'s yours is mine', 'sharing is caring (for me)'][Math.floor(Math.random() * 4)]
            : ['that\'s MY spot', '*claims territory*', 'excuse me this is taken', 'mine now üò§'][Math.floor(Math.random() * 4)],
          timer: 2500, maxTimer: 2500, mouseKey: thiefKey });
        setTimeout(() => {
          if (victim.room === state.currentRoom) {
            speechBubbles = speechBubbles.filter(b => b.mouseKey !== victimKey);
            speechBubbles.push({ x: victim.x + 14, y: getMouseFloorY(victim) - 10,
              text: ['hey! üò†', 'not cool', 'RUDE', 'I\'m telling', '...wow'][Math.floor(Math.random() * 5)],
              timer: 2500, maxTimer: 2500, mouseKey: victimKey });
          }
        }, 1000);
      }
    }, 1500);
  } else if (interaction < 0.82) {
    // Staring contest ‚Äî both face each other and just... stare
    const midX = (s.x + c.x) / 2;
    s.dir = c.x > s.x ? 1 : -1;
    c.dir = s.x > c.x ? 1 : -1;
    s.action = 'idle'; s.actionTimer = 4000;
    c.action = 'idle'; c.actionTimer = 4000;
    if (s.room === state.currentRoom) {
      setTimeout(() => {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'pip');
        speechBubbles.push({ x: s.x + 14, y: getMouseFloorY(s) - 10,
          text: ['üëÅüëÅ', '...', 'don\'t blink', '*stares*', 'ü§®'][Math.floor(Math.random() * 5)],
          timer: 3000, maxTimer: 3000, mouseKey: 'pip' });
      }, 500);
      setTimeout(() => {
        speechBubbles = speechBubbles.filter(b => b.mouseKey !== 'chai');
        speechBubbles.push({ x: c.x + 14, y: getMouseFloorY(c) - 10,
          text: ['...what', 'stop it', 'üòê', '*blinks*', 'I win'][Math.floor(Math.random() * 5)],
          timer: 3000, maxTimer: 3000, mouseKey: 'chai' });
      }, 1500);
    }
  } else if (interaction < 0.92) {
    // Judging: one mouse stares at the other
    const judger = Math.random() < 0.6 ? s : c;
    const judgerKey = judger === s ? 'pip' : 'chai';
    judger.action = 'idle';
    judger.actionTimer = 4000;
    judger.dir = (judger === s ? c.x : s.x) > judger.x ? 1 : -1;
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== judgerKey);
    speechBubbles.push({
      x: judger.x + 14, y: getMouseFloorY(judger) - 10,
      text: judgerKey === 'pip'
        ? ['sus ü§®', 'cringe', 'who asked?', 'bruh', 'oof'][Math.floor(Math.random() * 5)]
        : ['rude', 'don\'t look at me', 'why tho', 'üòê', 'I saw that'][Math.floor(Math.random() * 5)],
      timer: 3000, maxTimer: 3000, mouseKey: judgerKey
    });
  } else {
    // 4th wall break ‚Äî mouse looks at the player
    const breaker = Math.random() < 0.5 ? s : c;
    const breakerKey = breaker === s ? 'pip' : 'chai';
    breaker.action = 'idle';
    breaker.actionTimer = 3000;
    if (breaker.room === state.currentRoom) {
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== breakerKey);
      speechBubbles.push({
        x: breaker.x + 14, y: getMouseFloorY(breaker) - 10,
        text: breakerKey === 'pip'
          ? ['are you watching me? üëÄ', 'hi human!', '*waves*', 'buy me cheese pls', 'why are you just standing there'][Math.floor(Math.random() * 5)]
          : ['oh hi ü•∫', 'don\'t mind me', '*acknowledges your existence*', 'are we the game?', 'we see you'][Math.floor(Math.random() * 5)],
        timer: 3000, maxTimer: 3000, mouseKey: breakerKey
      });
    }
  }
}
// ============================================================
// MOUSE DREAM BUBBLES
// ============================================================
const DREAM_THEMES = [
  'üßÄüèîÔ∏è',   // cheese mountain
  'üê±üò±',   // nightmare about cats
  'üèÉ‚Äç‚ôÇÔ∏èüßÄüí®', // chasing cheese
  'üåô‚ú®üê≠',  // mouse in the stars
  'üßÄüßÄüßÄ',  // so much cheese
  'üé°üé†üé™',  // amusement park
  'üê±üî•üò§',  // fighting a cat
  'üõÅü´ßüê≠',  // bath time dreams
  'üëëüê≠üè∞',  // mouse royalty
  'üß∂üê≠üí§',  // yarn ball nap
  'üåàü¶ãüå∏',  // pretty meadow
  'üçïüç©üßÅ',  // junk food heaven
  'üê∂üò±üí®',  // chased by dog
  'üöÄüåïüê≠',  // mouse on the moon
  'üé∏üé§üê≠',  // rock star mouse
  'üßÄ‚ùåüò¢',  // no cheese nightmare
  'üê≠üëªüò∞',  // spooky dream
  'üèñÔ∏èüåäüêö',  // beach vacation
  'üéÆüïπÔ∏èüèÜ',  // gaming champion
  'üê≠üí™üèãÔ∏è',  // swole mouse
];

function pickDream() {
  return DREAM_THEMES[Math.floor(Math.random() * DREAM_THEMES.length)];
}

// ============================================================
// MICRO-EVENTS
// ============================================================
let microEventCooldown = 15000 + Math.random() * 15000;
const MICRO_EVENTS = ['bug', 'foundCoin', 'hiccups', 'sillyNap'];
let microEventBug = { active: false, x: 0, y: 0, timer: 0 };

function updateMicroEvents(dt) {
  // Update active bug animation
  if (microEventBug.active) {
    microEventBug.timer -= dt;
    microEventBug.x += (ROOM_W / 4000) * dt;
    microEventBug.y += Math.sin(Date.now() / 300) * 0.3;
    if (microEventBug.timer <= 0) microEventBug.active = false;
  }

  microEventCooldown -= dt;
  if (microEventCooldown > 0) return;
  microEventCooldown = 25000 + Math.random() * 25000;

  // Only fire if game is active, no mini-game, at least one mouse in current room
  if (cheeseChaseActive || whackACatActive || mouseMazeActive) return;
  const pip = state.miceState.pip;
  const chai = state.miceState.chai;
  const miceInRoom = [];
  if (pip.room === state.currentRoom) miceInRoom.push(pip);
  if (chai.room === state.currentRoom) miceInRoom.push(chai);
  if (miceInRoom.length === 0) return;

  const event = MICRO_EVENTS[Math.floor(Math.random() * MICRO_EVENTS.length)];
  const mouse = miceInRoom[Math.floor(Math.random() * miceInRoom.length)];
  const mouseKey = mouse === state.miceState.pip ? 'pip' : 'chai';

  if (event === 'bug') {
    microEventBug = { active: true, x: 10, y: ROOM_Y + ROOM_H - FLOOR_H - 5, timer: 4000 };
    const quotes = ['EW!', 'WHAT IS THAT', 'a friend? üêõ', '*investigates*'];
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
    speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
      text: quotes[Math.floor(Math.random() * quotes.length)],
      timer: 2500, maxTimer: 2500, mouseKey });
    mouse._startled = true;
    setTimeout(() => { mouse._startled = false; }, 800);
    sfxChitter();
  } else if (event === 'foundCoin') {
    const coins = 1 + Math.floor(Math.random() * 3);
    state.coins += coins;
    updateCoinDisplay();
    const quotes = ['found a coin! ü™ô', 'finders keepers!', 'hidden treasure!'];
    speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
    speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
      text: quotes[Math.floor(Math.random() * quotes.length)],
      timer: 2500, maxTimer: 2500, mouseKey });
    spawnFloatingEffect(mouse.x + 14, getMouseFloorY(mouse) - 5, 'ü™ô');
    sfxCoinCollect();
  } else if (event === 'hiccups') {
    mouse._hiccups = 3 + Math.floor(Math.random() * 3);
    mouse._hiccupTimer = 0;
  } else if (event === 'sillyNap') {
    const furniture = state.placedItems.filter(p => p.room === state.currentRoom);
    if (furniture.length > 0) {
      const quotes = ['this looks comfy', 'nap anywhere era', 'if I fits I sits'];
      speechBubbles = speechBubbles.filter(b => b.mouseKey !== mouseKey);
      speechBubbles.push({ x: mouse.x + 14, y: getMouseFloorY(mouse) - 10,
        text: quotes[Math.floor(Math.random() * quotes.length)],
        timer: 3000, maxTimer: 3000, mouseKey });
      mouse.action = 'sleeping';
      mouse.actionTimer = 5000 + Math.random() * 3000;
    }
  }
}

function drawMicroEventBug(roomIndex) {
  if (!microEventBug.active || roomIndex !== state.currentRoom) return;
  ctx.save();
  ctx.font = '12px serif';
  ctx.fillText('üêõ', microEventBug.x, microEventBug.y);
  ctx.restore();
}

// ============================================================
// EDGE NAVIGATION ‚Äî hover arrows + swipe
// ============================================================
const EDGE_ZONE = 40; // px in game coords
let edgeHover = 0; // -1 = left edge, 0 = none, 1 = right edge
let roomSwipeStart = null;

function drawEdgeArrows() {
  if (roomTransition.active || cheeseChaseActive || whackACatActive || mouseMazeActive) return;
  if (edgeHover === 0) return;
  const arrowX = edgeHover > 0 ? GAME_W - 22 : 22;
  const arrowY = ROOM_Y + ROOM_H / 2;
  const arrowChar = edgeHover > 0 ? '‚ñ∂' : '‚óÄ';
  // Translucent pill background
  ctx.save();
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = 'rgba(30,20,10,0.7)';
  ctx.beginPath();
  ctx.roundRect(arrowX - 14, arrowY - 18, 28, 36, 8);
  ctx.fill();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = '#f5d68a';
  ctx.font = 'bold 20px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(arrowChar, arrowX, arrowY);
  ctx.restore();
}

canvas.addEventListener('mousedown', e => handleCanvasInput(e.clientX, e.clientY, e, false));
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  const pos = screenToGame(t.clientX, t.clientY);
  // Start swipe tracking (only in main game, not mini-games)
  if (!cheeseChaseActive && !whackACatActive && !mouseMazeActive) {
    roomSwipeStart = { x: pos.x, y: pos.y, time: Date.now() };
  }
  handleCanvasInput(t.clientX, t.clientY, e, true);
}, { passive: false });

function handleCanvasInput(sx, sy, originalEvent, isTouch) {
  const pos = screenToGame(sx, sy);

  // Cheese Chase input
  if (cheeseChaseActive) {
    handleCCInput(sx, sy);
    return;
  }

  // Whack-a-Cat input
  if (whackACatActive) {
    handleWhackInput(sx, sy);
    return;
  }

  // Pac Mouse input
  if (mouseMazeActive) {
    handleMazeInput(sx, sy);
    mazeSwipeBegin(pos.x, pos.y);
    return;
  }

  // Edge arrow click ‚Äî only on the arrow pill itself (28√ó36 centered on arrow)
  if (!roomTransition.active && edgeHover !== 0) {
    const arrowX = edgeHover > 0 ? GAME_W - 22 : 22;
    const arrowY = ROOM_Y + ROOM_H / 2;
    if (pos.x >= arrowX - 14 && pos.x <= arrowX + 14 && pos.y >= arrowY - 18 && pos.y <= arrowY + 18) {
      if (edgeHover < 0) switchRoom(roomLeft(state.currentRoom));
      else switchRoom(roomRight(state.currentRoom));
      return;
    }
  }

  // Check if clicking/touching a placed item to pick it up for repositioning
  const placedIdx = findPlacedItemAt(pos.x, pos.y);
  if (placedIdx >= 0) {
    const placed = state.placedItems[placedIdx];
    const item = FURNITURE.find(f => f.id === placed.itemId);
    if (item && !item.exerciseRoom) {
      startDrag(placed.itemId, sx, sy, true, placedIdx, isTouch);
      return;
    }
  }

  // Try petting a mouse
  if (tryPetMouse(pos.x, pos.y)) return;

  // Light dismiss: clicking empty canvas area closes shop flyout
  if (state.shopOpen && !state.placementMode && !state.dragState.active) {
    closeShopFlyout();
    return;
  }
}

// Double-click on placed furniture to reposition (opens shop if needed)
// Double-click on status bar room icon to jump to that mouse's room
canvas.addEventListener('dblclick', e => {
  if (cheeseChaseActive || whackACatActive || mouseMazeActive) return;
  const pos = screenToGame(e.clientX, e.clientY);

  // Check status bar area (bottom 20px) ‚Äî double-click room icon to jump
  if (pos.y > GAME_H - 20) {
    const pip = state.miceState.pip;
    const chai = state.miceState.chai;
    if (pos.x < GAME_W / 2 && pip.room !== state.currentRoom) {
      switchRoom(pip.room);
      showToast(`Jumped to ${CONFIG.mice.pip.name} in ${ROOMS[pip.room].icon} ${ROOMS[pip.room].name}`);
      return;
    }
    if (pos.x >= GAME_W / 2 && chai.room !== state.currentRoom) {
      switchRoom(chai.room);
      showToast(`Jumped to ${CONFIG.mice.chai.name} in ${ROOMS[chai.room].icon} ${ROOMS[chai.room].name}`);
      return;
    }
    return;
  }

  // Furniture reposition
  const placedIdx = findPlacedItemAt(pos.x, pos.y);
  if (placedIdx < 0) return;
  const placed = state.placedItems[placedIdx];
  const item = FURNITURE.find(f => f.id === placed.itemId);
  if (!item || item.exerciseRoom) return;
  if (!state.shopOpen) {
    state.shopOpen = true;
    refreshShopFlyout();
    refreshItemTray();
    document.getElementById('shop-flyout').classList.add('open');
    document.getElementById('item-tray').classList.add('open');
    if (gamesOpen) closeGamesFlyout();
  }
  startDrag(placed.itemId, e.clientX, e.clientY, true, placedIdx);
});

canvas.addEventListener('mousemove', e => {
  if (cheeseChaseActive && !cc.gameOver) ccInputY = screenToGame(e.clientX, e.clientY).y;
  if (state.dragState.active) updateDrag(e.clientX, e.clientY);
  // Track edge hover for navigation arrows
  if (!cheeseChaseActive && !whackACatActive && !mouseMazeActive && !roomTransition.active) {
    const pos = screenToGame(e.clientX, e.clientY);
    if (pos.y >= ROOM_Y && pos.y <= ROOM_Y + ROOM_H) {
      if (pos.x < EDGE_ZONE) edgeHover = -1;
      else if (pos.x > GAME_W - EDGE_ZONE) edgeHover = 1;
      else edgeHover = 0;
    } else {
      edgeHover = 0;
    }
  }
});
canvas.addEventListener('mouseleave', () => { edgeHover = 0; });
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (cheeseChaseActive && !cc.gameOver) ccInputY = screenToGame(e.touches[0].clientX, e.touches[0].clientY).y;
  if (state.dragState.active) updateDrag(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

canvas.addEventListener('mouseup', e => {
  if (mouseMazeActive && mazeSwipeStart) {
    const pos = screenToGame(e.clientX, e.clientY);
    mazeSwipeEnd(pos.x, pos.y);
  }
});
canvas.addEventListener('touchend', e => {
  if (mouseMazeActive && mazeSwipeStart) {
    const t = e.changedTouches[0];
    const pos = screenToGame(t.clientX, t.clientY);
    mazeSwipeEnd(pos.x, pos.y);
  }
  // Room swipe detection
  if (roomSwipeStart && !cheeseChaseActive && !whackACatActive && !mouseMazeActive && !roomTransition.active) {
    const t = e.changedTouches[0];
    const pos = screenToGame(t.clientX, t.clientY);
    const dx = pos.x - roomSwipeStart.x;
    const elapsed = Date.now() - roomSwipeStart.time;
    // Require minimum 50px swipe within 500ms
    if (Math.abs(dx) > 50 && elapsed < 500) {
      if (dx < 0) switchRoom(roomRight(state.currentRoom)); // swipe left ‚Üí next room
      else switchRoom(roomLeft(state.currentRoom));          // swipe right ‚Üí prev room
    }
  }
  roomSwipeStart = null;
});

document.addEventListener('keydown', e => {
  if (cheeseChaseActive && !cc.gameOver) {
    if (e.key === 'ArrowUp' || e.key === 'w') { e.preventDefault(); cc.heldKeys.up = true; }
    if (e.key === 'ArrowDown' || e.key === 's') { e.preventDefault(); cc.heldKeys.down = true; }
  }
  if (cheeseChaseActive && cc.gameOver) { endCheeseChase(); return; }
  if (cheeseChaseActive && e.key === 'Escape') { e.preventDefault(); endCheeseChase(); return; }
  if (whackACatActive && wac.gameOver && wac.gameOverDelay <= 0) { endWhackACat(); return; }
  if (whackACatActive && e.key === 'Escape') { e.preventDefault(); endWhackACat(); return; }
  if (mouseMazeActive && !mz.levelComplete && !mz.gameOver && mz.deathPause <= 0) {
    const mazeDir = ({ ArrowUp:'up', w:'up', ArrowDown:'down', s:'down',
                       ArrowLeft:'left', a:'left', ArrowRight:'right', d:'right' })[e.key];
    if (mazeDir) {
      e.preventDefault();
      mz.heldKeys[mazeDir] = true;
      // Immediate move on first press (no waiting for timer)
      if (canMazeMove(mazeDir)) {
        mz.playerDir = mazeDir;
        mz.nextDir = null;
        if (mz.moveTimer > 20) {
          doMazeMove(mazeDir);
          mz.moveTimer = mz.moveInterval;
        }
      } else {
        mz.nextDir = mazeDir;
      }
    }
  }
  if (mouseMazeActive && e.key === 'Escape') { e.preventDefault(); endMouseMaze(); }
  // Pac Mouse: any key advances from end screens
  if (mouseMazeActive && (mz.gameOver || mz.levelComplete)) {
    e.preventDefault();
    if (mz.gameOver) { endMouseMaze(); }
    else if (mz.level >= 3) { endMouseMaze(); }
    else { mz.level++; initMazeLevel(mz.level); }
    return;
  }
});

document.addEventListener('keyup', e => {
  if (cheeseChaseActive && cc.heldKeys) {
    if (e.key === 'ArrowUp' || e.key === 'w') cc.heldKeys.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') cc.heldKeys.down = false;
  }
  if (mouseMazeActive && mz.heldKeys) {
    const mazeDir = ({ ArrowUp:'up', w:'up', ArrowDown:'down', s:'down',
                       ArrowLeft:'left', a:'left', ArrowRight:'right', d:'right' })[e.key];
    if (mazeDir) mz.heldKeys[mazeDir] = false;
  }
});

// ============================================================
// TITLE SCREEN ‚Äî draw mice and spawn floating particles
// ============================================================
(function initTitleScreen() {
  // Animate title mice using the same drawMouse() as the game
  const pipCanvas = document.getElementById('title-pip');
  const chaiCanvas = document.getElementById('title-chai');
  if (!pipCanvas || !chaiCanvas) return;
  const pipCtx = pipCanvas.getContext('2d');
  const chaiCtx = chaiCanvas.getContext('2d');
  const savedCtx = ctx;
  let titleAnimId = null;

  // Personality-fitting action sequences
  const pipActions = ['zoomies', 'mischief', 'walking', 'eating', 'zoomies', 'grooming', 'doomscrolling', 'walking'];
  const chaiActions = ['yoga', 'idle', 'grooming', 'sleeping', 'walking', 'idle', 'eating', 'yoga'];
  let pipActionIdx = 0, chaiActionIdx = 0;
  let actionSwitchTimer = 0;
  const ACTION_DURATION = 3000; // ms per action

  // Rotating taglines
  const pipTaglines = ['chaos mode: ON üòà', 'no thoughts just vibes', 'snack enthusiast üßÄ', 'professional zoomie-er', 'caught in 4k', 'slay üíÖ'];
  const chaiTaglines = ['cozy vibes only ‚ú®', 'professional napper', 'zen mode activated üßò', 'soft & unbothered', 'inner peace achieved', 'self care era üíÖ'];
  let pipTagIdx = 0, chaiTagIdx = 0;
  const pipTagEl = document.getElementById('pip-tagline');
  const chaiTagEl = document.getElementById('chai-tagline');
  if (pipTagEl) pipTagEl.textContent = pipTaglines[0];
  if (chaiTagEl) chaiTagEl.textContent = chaiTaglines[0];

  setInterval(() => {
    pipTagIdx = (pipTagIdx + 1) % pipTaglines.length;
    chaiTagIdx = (chaiTagIdx + 1) % chaiTaglines.length;
    if (pipTagEl) { pipTagEl.style.opacity = '0'; setTimeout(() => { pipTagEl.textContent = pipTaglines[pipTagIdx]; pipTagEl.style.opacity = '1'; }, 400); }
    if (chaiTagEl) { chaiTagEl.style.opacity = '0'; setTimeout(() => { chaiTagEl.textContent = chaiTaglines[chaiTagIdx]; chaiTagEl.style.opacity = '1'; }, 400); }
  }, 4000);

  let lastTitleTime = performance.now();

  function animateTitleMice(now) {
    const dt = now - lastTitleTime;
    lastTitleTime = now;
    actionSwitchTimer += dt;
    if (actionSwitchTimer >= ACTION_DURATION) {
      actionSwitchTimer = 0;
      pipActionIdx = (pipActionIdx + 1) % pipActions.length;
      chaiActionIdx = (chaiActionIdx + 1) % chaiActions.length;
    }

    const t = Date.now() / 1000;
    const frame = Math.floor(t * 3) % 4;
    const pipAction = pipActions[pipActionIdx];
    const chaiAction = chaiActions[chaiActionIdx];

    // Pip ‚Äî facing right
    pipCtx.save();
    pipCtx.setTransform(1, 0, 0, 1, 0, 0);
    pipCtx.clearRect(0, 0, 200, 160);
    // Warm glow on mouse
    const spotPulse1 = 0.85 + Math.sin(t * 1.2) * 0.1;
    const spotGrad1 = pipCtx.createRadialGradient(100, 80, 10, 100, 80, 100);
    spotGrad1.addColorStop(0, `rgba(255,240,200,${0.14 * spotPulse1})`);
    spotGrad1.addColorStop(0.5, `rgba(255,220,160,${0.06 * spotPulse1})`);
    spotGrad1.addColorStop(1, 'rgba(255,220,160,0)');
    pipCtx.fillStyle = spotGrad1;
    pipCtx.fillRect(0, 0, 200, 160);
    pipCtx.translate(100, 85);
    pipCtx.scale(3, 3);
    pipCtx.translate(-14, -12);
    ctx = pipCtx;
    drawMouse(0, 0, CONFIG.mice.pip, 1, frame, pipAction, false);
    ctx = savedCtx;
    pipCtx.restore();

    // Chai ‚Äî facing left
    chaiCtx.save();
    chaiCtx.setTransform(1, 0, 0, 1, 0, 0);
    chaiCtx.clearRect(0, 0, 200, 160);
    // Warm glow on mouse
    const spotPulse2 = 0.85 + Math.sin(t * 1.2 + 1.5) * 0.1;
    const spotGrad2 = chaiCtx.createRadialGradient(100, 80, 10, 100, 80, 100);
    spotGrad2.addColorStop(0, `rgba(255,240,200,${0.14 * spotPulse2})`);
    spotGrad2.addColorStop(0.5, `rgba(255,220,160,${0.06 * spotPulse2})`);
    spotGrad2.addColorStop(1, 'rgba(255,220,160,0)');
    chaiCtx.fillStyle = spotGrad2;
    chaiCtx.fillRect(0, 0, 200, 160);
    chaiCtx.translate(100, 85);
    chaiCtx.scale(3, 3);
    chaiCtx.translate(-14, -12);
    ctx = chaiCtx;
    drawMouse(0, 0, CONFIG.mice.chai, -1, frame, chaiAction, false);
    ctx = savedCtx;
    chaiCtx.restore();

    if (!state.gameStarted) {
      titleAnimId = requestAnimationFrame(animateTitleMice);
    }
  }
  animateTitleMice(performance.now());

  // Spawn floating particles
  const titleEl = document.getElementById('title-screen');
  const emojis = ['üßÄ','‚ú®','üíï','üê≠','üåô','‚≠ê','üß∂','üçû','‚òï'];
  for (let i = 0; i < 12; i++) {
    const span = document.createElement('span');
    span.className = 'title-particle';
    span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    span.style.left = (5 + Math.random() * 90) + '%';
    span.style.bottom = (-10 - Math.random() * 20) + '%';
    span.style.animationDelay = (Math.random() * 6) + 's';
    span.style.animationDuration = (5 + Math.random() * 4) + 's';
    span.style.fontSize = (14 + Math.random() * 10) + 'px';
    titleEl.appendChild(span);
  }
})();

// Title screen ambient sound
let titleAudioCtx = null;
let titleMusicPlaying = false;
let titleMusicTimeout = null;
let titleMuted = false;

function initTitleAudio() {
  if (titleAudioCtx) return;
  titleAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

const TITLE_MELODY = [
  [392, 600], [330, 400], [294, 400], [262, 800], [0, 300],
  [294, 400], [330, 400], [392, 600], [330, 800], [0, 400],
  [262, 400], [294, 400], [330, 600], [392, 400], [330, 800], [0, 600],
];
let titleNoteIdx = 0;

function startTitleMusic() {
  if (!titleAudioCtx || titleMusicPlaying) return;
  titleMusicPlaying = true;
  titleNoteIdx = 0;
  playTitleNote();
}

function stopTitleMusic() {
  titleMusicPlaying = false;
  if (titleMusicTimeout) clearTimeout(titleMusicTimeout);
}

function playTitleNote() {
  if (!titleMusicPlaying || titleMuted) { titleMusicPlaying = false; return; }
  const [freq, dur] = TITLE_MELODY[titleNoteIdx % TITLE_MELODY.length];
  titleNoteIdx++;
  if (freq > 0) {
    const osc = titleAudioCtx.createOscillator();
    const g = titleAudioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0, titleAudioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.05, titleAudioCtx.currentTime + 0.05);
    g.gain.setTargetAtTime(0, titleAudioCtx.currentTime + (dur / 1000) * 0.5, (dur / 1000) * 0.2);
    osc.connect(g); g.connect(titleAudioCtx.destination);
    osc.start(titleAudioCtx.currentTime);
    osc.stop(titleAudioCtx.currentTime + dur / 1000 + 0.15);
  }
  titleMusicTimeout = setTimeout(playTitleNote, dur);
}

function toggleTitleMute() {
  titleMuted = !titleMuted;
  const btn = document.getElementById('title-mute-btn');
  btn.textContent = titleMuted ? 'üîá' : 'üîä';
  if (titleMuted) {
    stopTitleMusic();
  } else {
    initTitleAudio();
    startTitleMusic();
  }
}

function toggleTitleAbout() {
  const overlay = document.getElementById('title-about-overlay');
  overlay.classList.toggle('visible');
}
function closeTitleAbout() {
  document.getElementById('title-about-overlay').classList.remove('visible');
  // Reset the confirm state when closing about
  const link = document.getElementById('reset-game-link');
  if (link && link.dataset.armed) {
    link.dataset.armed = '';
    link.textContent = 'Reset Game';
    link.style.color = '#7a6a5a';
  }
}

let _resetGameTimer = null;
function confirmResetGame(el) {
  if (el.dataset.armed === 'true') {
    clearTimeout(_resetGameTimer);
    localStorage.removeItem('mouseHouseSave');
    location.reload();
    return;
  }
  el.dataset.armed = 'true';
  el.textContent = 'Tap again to confirm reset';
  el.style.color = '#cc4444';
  _resetGameTimer = setTimeout(() => {
    el.dataset.armed = '';
    el.textContent = 'Reset Game';
    el.style.color = '#7a6a5a';
  }, 3000);
}

// Start title music on first interaction (to satisfy autoplay policy)
let titleAudioStarted = false;
document.getElementById('title-screen').addEventListener('mousedown', () => {
  if (!titleAudioStarted) {
    titleAudioStarted = true;
    if (!titleMuted) { initTitleAudio(); startTitleMusic(); }
  }
}, { once: false });
document.getElementById('title-screen').addEventListener('touchstart', () => {
  if (!titleAudioStarted) {
    titleAudioStarted = true;
    if (!titleMuted) { initTitleAudio(); startTitleMusic(); }
  }
}, { passive: true });

document.getElementById('title-screen').addEventListener('click', e => {
  // Don't start game if about overlay is showing or clicking buttons
  if (document.getElementById('title-about-overlay').classList.contains('visible')) return;
  if (e.target.closest('.title-buttons')) return;
  startGame();
});
document.getElementById('title-screen').addEventListener('touchend', e => {
  if (document.getElementById('title-about-overlay').classList.contains('visible')) return;
  if (e.target.closest('.title-buttons')) return;
  e.preventDefault();
  // Start title audio on first touch
  if (!titleAudioStarted) {
    titleAudioStarted = true;
    if (!titleMuted) { initTitleAudio(); startTitleMusic(); }
  }
  startGame();
}, { passive: false });

// ============================================================
// GAME START
// ============================================================
function startGame() {
  if (state.gameStarted) return;
  state.gameStarted = true;
  // Request fullscreen on mobile (user gesture from tapping start screen)
  const isMobile = window.innerWidth <= 600 || (window.innerHeight <= 440 && window.innerWidth > window.innerHeight)
    || ('ontouchstart' in window && window.innerWidth <= 1024);
  if (isMobile && !document.fullscreenElement && !document.webkitFullscreenElement) {
    const el = document.documentElement;
    (el.requestFullscreen || el.webkitRequestFullscreen || function(){}).call(el).catch(() => {});
  }
  stopTitleMusic();
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('title-about-overlay').classList.remove('visible');
  document.getElementById('title-about-overlay').style.display = '';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('tray-toggle').style.display = 'flex';
  loadGame();
  loadAudioPrefs();
  initAudio();
  updateCoinDisplay();
  updateHappinessDisplay();
  updateGoalDisplay();
  buildRoomTabs();
  // Re-fit canvas now that HUD is visible (mobile needs HUD height)
  resizeCanvas();
  initParticles();
  ensureExerciseRoomSetup();
  triggerBirthdayEvent();
  if (!audioMuted) startMusic();
}

// ============================================================
// MAIN LOOP
// ============================================================
let lastTime = performance.now();

function gameLoop(now) {
  const dt = Math.min(now - lastTime, 50);
  lastTime = now;

  if (state.gameStarted) {
    if (cheeseChaseActive) {
      updateCheeseChase(dt);
      updateFloatingEffects(dt);
      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawCheeseChase();
    } else if (whackACatActive) {
      updateWhackACat(dt);
      updateFloatingEffects(dt);
      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawWhackACat();
    } else if (mouseMazeActive) {
      updateMouseMaze(dt);
      updateFloatingEffects(dt);
      ctx.clearRect(0, 0, GAME_W, GAME_H);
      drawMouseMaze();
    } else {
      updateParticles(dt);
      updateMouse(state.miceState.pip, dt, CONFIG.mice.pip.personality);
      updateMouse(state.miceState.chai, dt, CONFIG.mice.chai.personality);
      updateSpeechBubbles(dt);
      updateFloatingEffects(dt);
      updateMouseInteractions(dt);
      updateMicroEvents(dt);
      updateHappiness(dt);
      updateGoals(dt);
      updateExerciseWheel(dt);

      ctx.clearRect(0, 0, GAME_W, GAME_H);

      // Room slide transition
      if (roomTransition.active) {
        roomTransition.progress += dt;
        const t = Math.min(1, roomTransition.progress / roomTransition.duration);
        // Ease-out cubic for smooth deceleration
        const ease = 1 - Math.pow(1 - t, 3);
        // dir: +1 = moving right on ring ‚Üí rooms slide LEFT
        const slideOffset = ease * GAME_W * roomTransition.dir;
        drawRoomScene(roomTransition.from, -slideOffset);
        drawRoomScene(roomTransition.to, GAME_W * roomTransition.dir - slideOffset);
        if (t >= 1) roomTransition.active = false;
      } else {
        drawRoom(state.currentRoom);

        // Draw mice in current room (skip mice on the wheel or flung ‚Äî drawn separately)
        const pip = state.miceState.pip;
        const chai = state.miceState.chai;
        const pipFloorY = getMouseFloorY(pip);
        const chaiFloorY = getMouseFloorY(chai);
        if (pip.room === state.currentRoom && pip.action !== 'wheeling' && !pip.onFurniture) {
          if (pip.action === 'flung') {
            drawFlungMouse(pip, CONFIG.mice.pip);
          } else {
            drawMouse(pip.x, pipFloorY, CONFIG.mice.pip, pip.dir, pip.frame, pip.action, pip._startled, pip);
          }
          drawPartyHat(pip.action === 'flung' ? pip.flingX : pip.x,
                       pip.action === 'flung' ? pip.flingY : pipFloorY, pip.action, pip.dir, CONFIG.mice.pip, state.currentRoom);
        }
        if (chai.room === state.currentRoom && chai.action !== 'wheeling' && !chai.onFurniture) {
          if (chai.action === 'flung') {
            drawFlungMouse(chai, CONFIG.mice.chai);
          } else {
            drawMouse(chai.x, chaiFloorY, CONFIG.mice.chai, chai.dir, chai.frame, chai.action, chai._startled, chai);
          }
          drawPartyHat(chai.action === 'flung' ? chai.flingX : chai.x,
                       chai.action === 'flung' ? chai.flingY : chaiFloorY, chai.action, chai.dir, CONFIG.mice.chai, state.currentRoom);
        }
      }

      drawSpeechBubbles();
      drawFloatingEffects();
      drawEdgeArrows();
      drawMouseStatus();

      // Draw room name + stats on canvas
      {
        ctx.save();
        const isMob = window.innerWidth <= 600;
        const isLand = window.innerHeight <= 440 && window.innerWidth > window.innerHeight;
        const room = ROOMS[state.currentRoom];
        ctx.font = 'bold 12px monospace';
        ctx.textBaseline = 'middle';

        if (isMob || isLand) {
          // Mobile/landscape: room name on top bar
          const barY = ROOM_Y / 2;
          ctx.fillStyle = '#a89070';
          ctx.textAlign = 'right';
          ctx.fillText(room.icon + ' ' + room.name, GAME_W - 8, barY);
          if (isLand) {
            ctx.textAlign = 'left';
            ctx.fillStyle = '#f5d68a';
            ctx.fillText('\u{1f9c0} ' + state.coins, 8, barY);
            const hap = Math.round((state.miceState.pip.happiness + state.miceState.chai.happiness) / 2);
            ctx.fillStyle = hap < 35 ? '#e06050' : '#f5d68a';
            ctx.fillText('\u2764\ufe0f ' + hap + '%', 80, barY);
          }
        } else {
          // Desktop: room name on room wall bottom (HUD covers top bar)
          ctx.font = '11px monospace';
          const label = `${room.icon} ${room.name}`;
          const labelW = ctx.measureText(label).width + 20;
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.fillRect(GAME_W / 2 - labelW / 2, ROOM_Y + ROOM_H - 20, labelW, 18);
          ctx.fillStyle = '#d0c0a0';
          ctx.textAlign = 'center';
          ctx.fillText(label, GAME_W / 2, ROOM_Y + ROOM_H - 11);
        }
        ctx.restore();
      }

      // Selfie flash effect
      if (selfieFlash > 0) {
        selfieFlash -= dt;
        const alpha = selfieFlash > 300 ? (500 - selfieFlash) / 200 : selfieFlash / 300;
        ctx.fillStyle = `rgba(255,255,255,${Math.min(0.7, alpha * 0.7)})`;
        ctx.fillRect(0, 0, GAME_W, GAME_H);
      }
    }
  }

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
